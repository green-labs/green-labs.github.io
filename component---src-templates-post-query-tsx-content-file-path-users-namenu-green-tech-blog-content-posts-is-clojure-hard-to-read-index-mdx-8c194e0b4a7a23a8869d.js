"use strict";(self.webpackChunkmy=self.webpackChunkmy||[]).push([[55],{7695:function(e,n,a){a.r(n),a.d(n,{default:function(){return r}});var t=a(7294),l=a(9626);function i(e){var n=Object.assign({blockquote:"blockquote",p:"p",ul:"ul",li:"li",a:"a",h2:"h2",div:"div",pre:"pre",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",em:"em",h3:"h3",strong:"strong"},(0,l.ah)(),e.components),a=n.Author;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Author",!0),t.createElement(t.Fragment,null,t.createElement(a,{email:"bakyeono@gmail.com",name:"박연오",description:"프로그래머/개구리 애호가",date:"2022-06-17"}),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"이 글은 2022 송파 클로저 밋업 행사의 발표입니다. 유튜브에서 비디오를 볼 수 있습니다."),"\n"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,t.createElement(n.a,{href:"https://www.youtube.com/watch?v=2bIpCf53x6w"},"<","!발표 보기",">")),"\n"),"\n",t.createElement("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/2bIpCf53x6w",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),"\n",t.createElement(n.p,null,'여러분 안녕하세요? 소중한 금요일 저녁 시간에 클로저 밋업에 참석해주셔서 감사합니다. “클로저 코드는 정말 읽기 어려운가?”라는 주제로 발표를 맡았습니다. 발표 주제의 이름을 잘못 지은 것 같기도 합니다. "클로저 코드는 왜 이렇게 읽기 쉬울까?"라고 했으면 더 좋았을 것 같네요. 클로저가 어렵다는 편견이 있는 편인데, 그렇지 않다는 걸 말씀드리려고 합니다.'),"\n",t.createElement(n.h2,null,"리스프(LISP)"),"\n",t.createElement(n.p,null,"클로저는 리스프라는 프로그래밍 언어의 한 방언입니다. 리스프는 1958년에 처음 나온, 무려 64년이나 된 옛날 언어입니다. 리스프는 항상 새로운 아이디어로 가득한 혁신적인 언어였습니다. 하지만 리스프의 방언들은 인기가 높지는 않습니다. 그 이유가 뭘까요?"),"\n",t.createElement(n.p,null,"리스프가 배우기 어렵고 코드를 읽기 어렵기 때문이라는 주장을 종종 들어요. 이런 주장에는 두 가지 가정이 있는데요, 하나는 언어의 인기가 언어의 내재적인 특성에 근거한다는 가정입니다. 두번째 가정은 리스프가 어렵다는 것입니다."),"\n",t.createElement(n.p,null,"저는 이런 가정에 동의하지 않습니다. 먼저, 언어의 인기에는 언어의 특성보다는 외부적인이 더 영향이 커요. 예를 들어, 에스페란토보다는 영어가 훨씬 널리 쓰입니다. 그건 영어가 에스페란토보다 더 쉽기 때문이 아닙니다. 최근에 외국인들 사이에서 한국어의 인기가 높아졌고, 1980년대에 나온 파이썬이 최근에야 널리 사랑받게 되었죠. 이 또한 한국어나 파이썬이 갑자기 전보다 쉬워졌기 때문이 아닙니다. 언어를 둘러싼 사회적 배경이 더 중요하죠."),"\n",t.createElement(n.h2,null,"Write-only Language?"),"\n",t.createElement(n.p,null,"리스프를 놀리는 말 중에 '쓰기 전용'이라는 말이 있어요. 코드 작성자도 코드를 못 읽는다는 거죠."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 444px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/a8fae82c072e632eb322caa607823883/9b7bd/img2.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 136.144578313253%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAIAAADzvTiPAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAGW0lEQVQ4y02Ra1CTdxbG/6moFDBKQQwmkITcSEIISSDkDQmEkJg7hGsSTCDccjFBJBe5hYBcxQBFLBQtS6sUdbugS1vQ2loUpOrate20tX7oB+10xl5gZ7F2SoHydrL7YXfmN8+cL+c8zzkHUOhsnlAhFKul8gJIKOOJDmn0pSXmCvMRh8l2xOr2eNr9Jwb6uocGhsbH9GUlTEYcN5XATsYmkg+CmAPh2lxyfh5JLqOLs7FJjOhMmdp6zOlq8bp8Dc1dbZ0DJwfPDZ27OB4YDXDTqHx+IpROoFNjCbj9gELFKpXo3FyMXBGn0hCFWWR1vrq53ds76B8e6xkZD7x1eeTdGxcW7s5cmnlNwKfx0vBsZjyTiWcyE4BMozmkzlfkFxeWGg3mcrOt2t1c2959fHC47c3JwMTbAzPvjd28ff7R49mbN89lCmgQLzGVQ4T41HQeFUhVitxiTbGxwGDWm61lltrKBl/tyUDjyNiJ6Sunb9w4u7g0sXRn4qdnc10dVRBEkUiYomyGQEDjpZOA/rC2rKK42lpqdZiOuSt9bUdO9rlGRlomJ7uvzQ19+835n59dXfv39X8sj8plLJmcJRJS+Gl4PhefxsYCY1lBVY3O7jS6PBWtfuupvrqzrzdcmjpxYy7w2b3RH55M/Wvl6q9r7/d0mBXyFKWMkZWOy2BhIBYmNSUOmMoLqiw6R52x3mtu9Fl7ep2vj3r+drnt7sLA00dvrP546cWL2cdfjxr1GUoJNU9BVyuYh8T0nGw6xCMDm73I7TL4WsydHdVDg47z454rf/V9NN/58JOBp49Gf/pufP3XS6PDFUoprTAvSaNOlkjowgySgE9J55JBozu/tamk94Tp7HDNhTec01Puj+d8D251fnG399Gnge8en1m+2V6Qx9UoWTIpPUtAYiah6VQ0nRafSMYAW6XIXpNzvE7W2aI901eyeNV+b75+ed775ZLv2Vfdvzwd7GsvoVFxyQwCi01hc8hk0kEcLpZEisPFo4BGxSkuSqupEHhqxa925Pa35Xqc0nqHtNaW4z+u7mjSSkQMIh5FIaOpifGJZHQCNgaNisRjY2Ki9gCzAXJUCt1WUaMzR18I8QVMLjeJySTyuBQOh8RNo6ayiWwmAUqncVhkHpeeSMZQCDGcFCKNRgJ4LAYVi9t/ID4sIjY04mBUDCFqfwIaTSYkJBES6CwmD4LE/AxpcjKPSGLRkrioWGIchsBgpDKS2YBE2nvUEVrn3O0++nKTF9nkQfoaIjtaYwI92NOBhJFB8ulThNN9CYGuuP5efF8P7kyA0N9NPNlBqncmAqWKM/uObPIv0Dtvi86dSRnupw6dolx8U3B+nDcxljrQS5x6SzA7LZ+dlk9fFE+Oc4u14PqVl2AYPFjaBwp1uuoab5ZIq1QdtjtacrVmldpYVFyjN9iTGEJGcoZcoa892na0zp8jKSksMgMA/A0hMAxuX4sEVRYD6sD+kJAdSGQ4FouJjooMDd0JAAgL2717904kMnzHDkRU1L7Y2OiwsJ0oVAQAoKsVAcNgYW4vcHmtOl1xfX2dVCJ2Omxej8tg0MnlUgjiWixVHo/L39ocEhJ6EAW+uof45gH4+j748VsAb4Db8xGgf8CvUJZkZqlMJrtCUaLVGjOzVCyWAIXClZc71Wq9ze4FABmHARvPEfAG2F4HfzwH8G/g9vU9oLPbBqWBDB7IUyH56S9BXCCThGqUEVkZiFwVUireWajdl8lHmAxgax3Az8HWahB4HSx/gATtPY52H91uwfoaKZ5jxCMWnKUKU26MKdVF22vQpbroZDrgpARJY4OHi8G2zZWgLl6LAPUNpkpjiFGHqDGHVpp2lRaBisMh5YaX1fJdWlWoWrYrW4jIzgQiQZDP7yDg3xAbKwh4HdyaDwedvWWfLmGXP0R99O6+hblXHt7BXZvZe38BwDDY3gTwVrD4Hy+Cyf9YCx7s1lw4MJRr6p0HHNZXrJVIW9Vedx3KZNgz2IOA18DmCmJrFbG5Gsy5+Z9Vf19Frn2PXn2C2ViNDb6qsUX436nb2//nsAXgX4ImQdaCuv0cAb8AKz+Tv/xnwf3Foh+eGD5+PxLI1TmV1fxqS4ajVuxtUPvaCv1dhp7+irFxx4Up18Sk6/JM89/nOqYue3pPGRqbJH5/tt+fU27E52Ri/gQkMnJvukX4JwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/a8fae82c072e632eb322caa607823883/9b7bd/img2.png"\n        srcset="/static/a8fae82c072e632eb322caa607823883/6a5fb/img2.png 249w,\n/static/a8fae82c072e632eb322caa607823883/9b7bd/img2.png 444w"\n        sizes="(max-width: 444px) 100vw, 444px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"“유지보수하기 어렵게 코딩하는 방법”이라는 책이 있는데요 나쁜 코딩 스타일을 반어법으로 소개하는 재미있는 책입니다. 이 책은 반쯤은 유머로 이루어져 있는데요. 리스프로 환상적으로 읽기 어려운 코드를 작성할 수 있다고 소개하는 내용이 있습니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 996px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/c4c76ff1e1e0e20133187b91385c9ee7/525d3/img3.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 40.562248995983936%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA9UlEQVQY043QS26FIBgFYPe/HzdgjL2COnJmogMTB4KPHxBQQG4LfQx6m/QbkhwOnCRN07qum6ZBCBVFgTFGCOHgLWiaJs/zx+ORZRlCqCzLqqowxnmeJ23bUkoJIVtAgmmajuPw3t/37f+WdF1njAEAKSXnXAghpVTBeZ5a6/M8nXP3K0nf9957QkhMCiGUUlprxhjnHACEEM65183DMDjnAMAYEwu11r9fG09i4U84NiulrLXGGBv4//ls3vddKcUYA4C43DzP27Zxztd1va7re5T4HSmltfYjfF3XOI57MAzDPM+UUgBYloUG8VIW2C/vgz0BDKXDkNBH/I8AAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/c4c76ff1e1e0e20133187b91385c9ee7/5caea/img3.png"\n        srcset="/static/c4c76ff1e1e0e20133187b91385c9ee7/6a5fb/img3.png 249w,\n/static/c4c76ff1e1e0e20133187b91385c9ee7/79e1b/img3.png 498w,\n/static/c4c76ff1e1e0e20133187b91385c9ee7/5caea/img3.png 996w,\n/static/c4c76ff1e1e0e20133187b91385c9ee7/525d3/img3.png 1090w"\n        sizes="(max-width: 996px) 100vw, 996px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"그런데 이 코드는 읽기가 매우 어려운 게 사실입니다. 이건 일부러 읽기 어렵게 짠 코드이니까요. 하지만 일부러 읽기 어렵게 만든다면, 다른 프로그래밍 언어로도 읽기 어려운 코드를 만들 수 있습니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-text"},"(function(_0x26ea4d,_0x1a7432){var _0x32fcab=_0x4ac1,_0x459153=_0x26ea4d();while(!![]){try{var _0x3aa247=-parseInt(_0x32fcab(0x188))/0x1+parseInt(_0x32fcab(0x187))/0x2*(parseInt(_0x32fcab(0x18d))/0x3)+parseInt(_0x32fcab(0x18b))/0x4*(-parseInt(_0x32fcab(0x18c))/0x5)+-parseInt(_0x32fcab(0x18a))/0x6*(parseInt(_0x32fcab(0x186))/0x7)+-parseInt(_0x32fcab(0x189))/0x8+parseInt(_0x32fcab(0x18f))/0x9+parseInt(_0x32fcab(0x18e))/0xa;if(_0x3aa247===_0x1a7432)break;else _0x459153['push'](_0x459153['shift']());}catch(_0x4b5609){_0x459153['push'](_0x459153['shift']());}}}(_0x1a2d,0xb965f));function hi(){var _0x3abc24=_0x4ac1;console[_0x3abc24(0x190)]('Hello\\\\x20World!');}function _0x4ac1(_0x4ed394,_0x61ef96){var _0x1a2de4=_0x1a2d();return _0x4ac1=function(_0x4ac138,_0x495466){_0x4ac138=_0x4ac138-0x186;var _0x2f2dbd=_0x1a2de4[_0x4ac138];return _0x2f2dbd;},_0x4ac1(_0x4ed394,_0x61ef96);}hi();function _0x1a2d(){var _0x8ac2fc=['24304ySzTVX','286370zkQpmn','9621232DxRZqZ','1050888RPzHkL','930156jIVjDv','15ICQjgj','183oGpdZN','13070690XlMPPp','11231883UJewfa','log','14jghHbE'];_0x1a2d=function(){return _0x8ac2fc;};return _0x1a2d();}\n")),"\n",t.createElement(n.p,null,"코드를 읽기 어렵게 만들어주는 “난독화”프로그램도 있죠. 이 코드는 자바스크립트 코드를 난독화한 것인데, 자바스크립트 전문가가 읽기에도 난해할 겁니다. 리스프는 이런 놀림의 대상이 될 때가 종종 있어요. 저도 이런 유머를 좋아해요. 하지만 유머는 유머일뿐인 것이지, 그게 꼭 사실은 아닐 수도 있어요."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-text"},"(-> 1000\n    inc\n    (+ 500)\n    -\n    str)\n")),"\n",t.createElement(n.p,null,"그런데 클로저를 처음 접하는 분들이 보기에는 이 코드처럼 정상적인 클로저 코드도 난독화된 코드와 비슷하게 어렵게 보일 수도 있습니다. 그건 우리 뇌가 낯선 것과 어려운 것을 혼동하기 때문입니다. 리스프를 배울 때는 코드의 모양도 다르고 새로운 개념도 많습니다. 이전에 배운 언어와 다른 점이 많습니다. 하지만 리스프와 클로저를 배울수록, 그 낯선 것들이 오히려 코드를 더 쓰고 읽기 쉽게 해준다는 걸 알게 됩니다."),"\n",t.createElement(n.h2,null,"애리티(arity)"),"\n",t.createElement(n.p,null,"애리티라는 개념이 있습니다. 어떤 연산자나 함수가 취할 수 있는 인자의 개수를 뜻합니다."),"\n",t.createElement(n.table,null,t.createElement(n.thead,null,t.createElement(n.tr,null,t.createElement(n.th,null,"애리티"),t.createElement(n.th,null,"예"))),t.createElement(n.tbody,null,t.createElement(n.tr,null,t.createElement(n.td,null,"단항 연산자 (unary)"),t.createElement(n.td,null,t.createElement(n.code,null,"! x"))),t.createElement(n.tr,null,t.createElement(n.td,null,"이항 연산자 (binary)"),t.createElement(n.td,null,t.createElement(n.code,null,"x + y"))),t.createElement(n.tr,null,t.createElement(n.td,null,"삼항 연산자 (ternary)"),t.createElement(n.td,null,t.createElement(n.code,null,"condition ? x : y"))),t.createElement(n.tr,null,t.createElement(n.td,null,"무항 연산자 (nullary)"),t.createElement(n.td,null,t.createElement(n.em,null,"?"))),t.createElement(n.tr,null,t.createElement(n.td,null,"N항 연산자 (N-ary)"),t.createElement(n.td,null,t.createElement(n.em,null,"?"))))),"\n",t.createElement(n.p,null,"C 언어의 연산자 중 몇 가지를 애리티에 따라 분류해 보았는데요. 단항 연산자로는 부정 연산자, 증가 연산자 등이 있습니다. 이항 연산자는 and, or, 더하기, 나누기 등이 있습니다. 그리고 조건부 식 연산자는 삼항 연산자죠."),"\n",t.createElement(n.p,null,"그렇다면, 인자가 아예 없거나, 인자가 여러개인 N항 연산자도 생각해볼 수 있지 않을까요? 이런 연산들은 어떻게 표기해야 할까요?"),"\n",t.createElement(n.h3,null,"연산자의 모양"),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,'"형태는 기능을 따른다." - 루이스 설리반'),"\n"),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 729px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/8e2b7a80472faf7affe1b12b71bb3310/b2982/img4.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 23.69477911646586%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAwUlEQVQY03WNuw4BURRF58v9gR+QKEQUOiQ0NB5RqDwKMQqZkIi555z7vmOMuVcyU2JVq1l7R0SklCIixpisYMBCCNNjf39bhxC8L8MfIgCQUhJRLZxzACiKYh4Pzo+dy827LLwvffA/YkQUQiBi/YyEmtvNZTY+dIzTrWWDW1b9/4rTNBVCAEAtSChJb6+ryaErNPU2TZ3J0a6dwOl7IuKcO+eMMUopa602OrPPCxy310WWu8V5+Hy5eTy4i+Q7/gClCBhoPD4zewAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/8e2b7a80472faf7affe1b12b71bb3310/b2982/img4.png"\n        srcset="/static/8e2b7a80472faf7affe1b12b71bb3310/6a5fb/img4.png 249w,\n/static/8e2b7a80472faf7affe1b12b71bb3310/79e1b/img4.png 498w,\n/static/8e2b7a80472faf7affe1b12b71bb3310/b2982/img4.png 729w"\n        sizes="(max-width: 729px) 100vw, 729px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"수학 연산자들은 일찍부터 형태가 정해졌습니다. 이러한 기존 형태에서는 넣을 수 있는 인자의 수가 제한적이어서, 가변적인 N항 연산자를 표현할 수가 없습니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 753px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/d8566529324998e81d24a0d0aa150ab6/17a7a/img5.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 41.36546184738956%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAtUlEQVQY053QwQrCMAwGYN//JcSL+AB6EMGjehA32GEoQxSmU6y0q12atHXxMNlxMv9TIHz8IQMiMsaEELh/Bs45pRQRMXNd1/2w914phYj/NCOi1hoAjDFNeZN27sJEpLVGRLAAFtrFT/nFUsrqBZ5Cpa13Hq0DsMzsfRBCOOe6HlaqMs7W+fMYZ5uLOEfZCoEkPNI8Kq5FF7ZoLeA8HW9Py0U6OdyjaTJk5v1tN0tG/O46+wNfytLZeYHNiwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/d8566529324998e81d24a0d0aa150ab6/17a7a/img5.png"\n        srcset="/static/d8566529324998e81d24a0d0aa150ab6/6a5fb/img5.png 249w,\n/static/d8566529324998e81d24a0d0aa150ab6/79e1b/img5.png 498w,\n/static/d8566529324998e81d24a0d0aa150ab6/17a7a/img5.png 753w"\n        sizes="(max-width: 753px) 100vw, 753px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"프로그래밍 언어들은 연산자로 표현할 수 없는 N항의 연산을 위해 함수를 사용하고 있습니다. 함수의 형태에서는 취할 수 있는 인자의 개수가 제한되지 않습니다. 0개부터 N개까지 가변적인 애리티를 가질 수 있어요. 형태만 본다면, 함수는 연산자의 일반적인 표기법이라고 할 수 있습니다."),"\n",t.createElement(n.h2,null,"S-식(S-expression)"),"\n",t.createElement(n.p,null,"리스프에서는 이 함수의 형태을 응용한 S-식이라는 형식으로 연산자를 표기합니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,null,"(연산자 인자1 인자2 인자3 ... 인자N)\n")),"\n",t.createElement(n.p,null,"괄호를 열고, 연산자를 가장 앞에 적고, 인자들은 그 뒤에 나열합니다."),"\n",t.createElement(n.table,null,t.createElement(n.thead,null,t.createElement(n.tr,null,t.createElement(n.th,null,"연산자"),t.createElement(n.th,null,"C"),t.createElement(n.th,null,"클로저"))),t.createElement(n.tbody,null,t.createElement(n.tr,null,t.createElement(n.td,null,"단항 연산자"),t.createElement(n.td,null,t.createElement(n.code,null,"! x")),t.createElement(n.td,null,t.createElement(n.code,null,"(not x)"))),t.createElement(n.tr,null,t.createElement(n.td,null,"이항 연산자"),t.createElement(n.td,null,t.createElement(n.code,null,"x + y")),t.createElement(n.td,null,t.createElement(n.code,null,"(+ x y)"))),t.createElement(n.tr,null,t.createElement(n.td,null,"삼항 연산자"),t.createElement(n.td,null,t.createElement(n.code,null,"condition ? x : y")),t.createElement(n.td,null,t.createElement(n.code,null,"(if condition x y)"))))),"\n",t.createElement(n.p,null,"S-식에서는 단항 연산자, 이항 연산자, 삼항 연산자의 표기법이 모두 동일합니다. 연산자 자리에 함수를 대신 넣어도 돼요, 사실 리스프에서는 연산자와 함수가 같은 것입니다."),"\n",t.createElement(n.p,null,"S-식은 흔히 알려진 것처럼 그렇게 생소한 것이 아닙니다. 사실, 다른 언어의 함수 호출과 거의 똑같은 형태입니다."),"\n",t.createElement(n.table,null,t.createElement(n.thead,null,t.createElement(n.tr,null,t.createElement(n.th,null,"파이썬"),t.createElement(n.th,null,"클로저"))),t.createElement(n.tbody,null,t.createElement(n.tr,null,t.createElement(n.td,null,t.createElement(n.code,null,"abs(x)")),t.createElement(n.td,null,t.createElement(n.code,null,"(abs x)"))),t.createElement(n.tr,null,t.createElement(n.td,null,t.createElement(n.code,null,"map(f, sequence)")),t.createElement(n.td,null,t.createElement(n.code,null,"(map f sequence)"))),t.createElement(n.tr,null,t.createElement(n.td,null,t.createElement(n.code,null,"f4(f3(f2(f1(x))))")),t.createElement(n.td,null,t.createElement(n.code,null,"(f4 (f3 (f2 (f1 x))))"))))),"\n",t.createElement(n.p,null,"이 표는 파이썬과 클로저를 비교한 것인데요, 보다시피 여는 괄호의 위치만 다를 뿐 표기법이 거의 똑같죠."),"\n",t.createElement(n.p,null,"리스프에서는 함수와 연산자가 같습니다. 모양도 같고, 실행하는 방식도 같습니다. 이처럼 규칙에 일관성이 있으면 더 쉽습니다."),"\n",t.createElement(n.h3,null,"가변 애리티"),"\n",t.createElement(n.p,null,"S-식에는 몇가지 장점이 더 있습니다. S-식에서는 하나의 연산자가 가변적인 애리티를 가질 수 있습니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 788px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/29ae3f9a7de82190053ff0778861e370/ea7fb/img6.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 32.93172690763052%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAhUlEQVQY04XQwQ6EMAhFUf//X622UHhIUZM2mXQz9i5JTiBsKSXpPVMRUUoxs+ez7TgOMyMiVZ2xqtZaFzilBCDnzMwzFhEiWuDzPAEwMxFd1zWmrTVVBXDf9xfe932cDaCUEhEDj80LPB6Tc1ZVInL36LXWfof8xSLi7swMoNZqvbF/2QsdUZz2QAzKGwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/29ae3f9a7de82190053ff0778861e370/ea7fb/img6.png"\n        srcset="/static/29ae3f9a7de82190053ff0778861e370/6a5fb/img6.png 249w,\n/static/29ae3f9a7de82190053ff0778861e370/79e1b/img6.png 498w,\n/static/29ae3f9a7de82190053ff0778861e370/ea7fb/img6.png 788w"\n        sizes="(max-width: 788px) 100vw, 788px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"이 예는 클로저의 + 함수인데요. 원래는 + 연산자는 이항 연산자로서 애리티가 2로 고정되어 있습니다. 하지만 클로저에서는 보다시피 인자가 0개인 경우, 1개인 경우, N개인 경우가 모두 가능합니다."),"\n",t.createElement(n.p,null,"가변 애리티를 활용하면 비교 연산자도 두개가 아니라 한꺼번에 여러 개의 인자를 받을 수 있고, 여러 값들을 비교할 수 있습니다. and 연산자도 여러 개의 인자를 취하여, 식들이 모두 참인지 확인할 수 있습니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 896px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/9d614b878899f9d702dd5dbf7d83ca06/4c42d/img7.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 44.979919678714865%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAArklEQVQoz5WRQWrFMAxEc/+LhjiJFCuypTCWU/im0G5a/JaCx4iZpdYqIqoqImb2zrDUWnPO67qq6nVdRFRrJaKc8/M8rbW/5Pd9I8Lde+8A3B2Ambl7ay0i/klWVXcfgrtPvC0i9IGZVbWUMiG3DyMWwFxhAEYxAHrvczIzp5SIaN93d4+I9k385ucdQEQspRRmPo5j27axtqoS0Zh91GFmzHye55jzvu+Ukpl9AWL5EHPBZQLmAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/9d614b878899f9d702dd5dbf7d83ca06/4c42d/img7.png"\n        srcset="/static/9d614b878899f9d702dd5dbf7d83ca06/6a5fb/img7.png 249w,\n/static/9d614b878899f9d702dd5dbf7d83ca06/79e1b/img7.png 498w,\n/static/9d614b878899f9d702dd5dbf7d83ca06/4c42d/img7.png 896w"\n        sizes="(max-width: 896px) 100vw, 896px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"그런데 마지막의 and 예는 조금 읽기가 어려워 보입니다. 인자가 많다보니 연산에 들어가는 인자가 무엇무엇인지 한눈에 들어오지 않습니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 878px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/f2d868fbefef17984fbbe5a0ed724125/94829/img8.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 25.301204819277107%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAYElEQVQY043PWw5EIQgDUPe/VRNQ5CEQ5SYzG/D8N23bGIOIAAARmdnMqureWw+au6sq/KjqOaeetaqKiL03AMw5M3OtRUTu/hR2dxFBxN67mYkIM0fEa/P/LRFl5vvsDzOdJtZAnaR1AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/f2d868fbefef17984fbbe5a0ed724125/94829/img8.png"\n        srcset="/static/f2d868fbefef17984fbbe5a0ed724125/6a5fb/img8.png 249w,\n/static/f2d868fbefef17984fbbe5a0ed724125/79e1b/img8.png 498w,\n/static/f2d868fbefef17984fbbe5a0ed724125/94829/img8.png 878w"\n        sizes="(max-width: 878px) 100vw, 878px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"인자가 많거나, 코드가 길어질 때는 인자들 사이를 개행해주면 가독성이 좋아집니다."),"\n",t.createElement(n.h3,null,"평가 우선순위"),"\n",t.createElement(n.p,null,"S-식에서는 연산자의 평가 우선순위에 대해 신경쓸 필요가 없습니다. 모든 연산이 괄호로 싸여 있고, 괄호만 보면 무엇이 어떻게 결합해서 평가될지 알 수 있으니까요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 996px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/2c7010d5512696ee7e4376da08426fe5/46e51/img9.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 36.94779116465864%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7CAAAOwgEVKEqAAAAAuUlEQVQoz5WRjQrDIAyEff83LVVbW+2fthlfIIVBN7ZASDTn5RLduq6Sc5YQgsQYZZ5nSSnJOI7ivdd76l3XyTAMWruu66M7wIAg2rZNSXjImVhKkWVZFINzxxuEPJk7z1OJaq3SWpPjOGTf99vtTAQDFrInjCok6fv+VsWoOOPjKEQZqkwp2GmaNIKlRq6EdLS90Rmg7RCCf81ZwjiogZA9oo6uNMS+fcTbpwBmbJNtDik7NbJfFb4A+FQhzp0hJcgAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/2c7010d5512696ee7e4376da08426fe5/5caea/img9.png"\n        srcset="/static/2c7010d5512696ee7e4376da08426fe5/6a5fb/img9.png 249w,\n/static/2c7010d5512696ee7e4376da08426fe5/79e1b/img9.png 498w,\n/static/2c7010d5512696ee7e4376da08426fe5/5caea/img9.png 996w,\n/static/2c7010d5512696ee7e4376da08426fe5/46e51/img9.png 1003w"\n        sizes="(max-width: 996px) 100vw, 996px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"이 예는 둘 다 윤년을 검사하는 식입니다. C 언어에서는 연산자 우선순위를 정확히 알아야 코드를 읽을 수 있죠. 하지만 클로저에서는 모든 연산이 괄호로 싸여있기 때문에, 우선순위에 대한 고민을 할 필요가 없어요."),"\n",t.createElement(n.p,null,'지금까지 S-식의 장점을 살짝 둘러봤습니다. 리스프는 쓸데없이 괄호가 많은 오래된 언어라는 놀림을 받곤 합니다. 하지만 사실은, 이러한 형태에는 그 형태가 따르는 기능이 있는 것입니다. 사실 S-식이 정말 가치있는 이유는 S-식에서 "코드가 곧 데이터이고, 데이터가 곧 코드이다"라는 것인데, 이 미친 놀라운 특징은 앞으로 클로저를 더 탐구하게 되실 여러분이 직접 맛보실 기쁨으로 남겨두겠습니다.'),"\n",t.createElement(n.h2,null,"코드를 읽는 흐름"),"\n",t.createElement(n.p,null,"이번에는 약간 다른 측면을 살펴보겠습니다. 여기 서로 다른 나라의 글들을 가져와 보았는데요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 996px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/1859954e711a7658bff562389ba43446/99661/img10.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 55.82329317269077%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACkklEQVQozx3S207aAACA4b7Uluxmi4uKoEVB5mamewGXbbqggpRCC4Ic23EoFJSgtaUHoBwLw3lAEaqCwUXnZuJxuuwtFpf8t9/dD6yaBtMObdH7uux7wyCalBW82KX+dnKdQvi4RP7cTJ5WY91y9Lq+dnT4ze01Cwl/KZ3IszGOJgHOrqGtYMqqFp3ajEPLWAYvG/RNM93IhBvpQLtItsTIrhC43F6RJLFPOxZ0GNzoPIkhRMABsCiYMPRn7GoWAUWnVrCBV03mssHvZ4InlVi3RMjZoJwNnFdCuXzumWrM7zTYrPOhwFI86geSxgEKUvLIEG1W8TZNyjJ4/Yi5PQHfYX1NwS+nHzsvY6VyoVc74Ub1Nsss8cWZjGFAwqBYN6soSEFBSsGuqeFjDx3hxxb1NbnYzAblQmRXwHZ57LwSkqr5nlGd3TwDzX/AXHCc8ADLc70UpGSRYcYKZhY1jdjkn+P0RZ3Zpl0nEimLYVkM1jlvN49XKvnnwzonoocXpjE3HAkuAUljH4cOrS4oOUQtOkf3yHf3bf6qwbR4z1mVPMyFDrJ4K4OdSkShXHyimnCheovpM+aCca8VoGFl1jlCmVUpBOTQkc3g+H2bv9lnWoK/W11ul+M7jEtK2M6q0XKl9FT5CoU+GmenAj40GccBClKkF4coSMmhahoGt8Ljd4fsXZPdWl86rqy0S7EG591I2k4lYnOjMKDT2MwzC3PvcY91hfAAa6Y+GlasmRRF33h2SVePvr09YG+brCx45Qz2fxVim3b9qpG1WrFnZNSB6GHjtN9lXibcQGL+ZWz2BQ338zY1YxkSF8GrFv3QzsoZvJ0PfZciR4VwR1r+LfP7O+W3kxqz8ZNBP+VAZnEP9A/S5oX0hfhZiAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/1859954e711a7658bff562389ba43446/5caea/img10.png"\n        srcset="/static/1859954e711a7658bff562389ba43446/6a5fb/img10.png 249w,\n/static/1859954e711a7658bff562389ba43446/79e1b/img10.png 498w,\n/static/1859954e711a7658bff562389ba43446/5caea/img10.png 996w,\n/static/1859954e711a7658bff562389ba43446/99661/img10.png 1098w"\n        sizes="(max-width: 996px) 100vw, 996px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"왼쪽은 한문으로 쓴 훈민정음, 가운데는 아랍어로 쓴 쿠란, 오른쪽은 라틴어로 인쇄한 창세기입니다. 혹시 이 글들에 공통점이 있다는 걸 눈치채셨나요?"),"\n",t.createElement(n.p,null,"한문은 위에서 아래로 읽고, 아랍어은 오른쪽에서 왼쪽으로, 라틴어는 왼쪽에서 오른쪽으로 읽습니다. 언어에 따라서 가로로든, 세로로든, 방향의 차이는 있지만, 우리 언어는 글을 선형으로 읽고 쓴다는 공통점이 있습니다."),"\n",t.createElement(n.p,null,"그런데 프로그래밍 언어는 선형으로 읽는 방식이 아닙니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 906px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/d4a54b77cc881020874b3ce5d3c54571/6029f/img11.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 46.1847389558233%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAlElEQVQoz5WQSxLEIAgFc/+zRgUMIBB1qnQxy3F63/U+V2sNEQGAiHLOiFhKISIRmb+4aq2llLQAABEZY/Texxi/5YjY4TlnVT1xvvKcc/u77fu+vHD3I9ndmRkR7/tWVWZ+nsfMjuTeOzOraq01Iv6oHRGqKiKtNTNzdzM7XH6pKgCklMoCEYnoNNnM9kO6OFy75Q9xWxJccwVT2QAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/d4a54b77cc881020874b3ce5d3c54571/6029f/img11.png"\n        srcset="/static/d4a54b77cc881020874b3ce5d3c54571/6a5fb/img11.png 249w,\n/static/d4a54b77cc881020874b3ce5d3c54571/79e1b/img11.png 498w,\n/static/d4a54b77cc881020874b3ce5d3c54571/6029f/img11.png 906w"\n        sizes="(max-width: 906px) 100vw, 906px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"첫번째 코드는 왼쪽에서 오른쪽으로 읽는 코드인데요, 아래쪽 코드처럼 안에서 밖으로 읽어야 되는 코드도 있어요. 함수 호출을 하면 안쪽에서부터 코드가 실행되니까요. 프로그램 코드에는 이런 코드들이 마구 뒤섞여 있죠."),"\n",t.createElement(n.p,null,"우리는 글을 읽을 때 한쪽 방향으로 읽는 것에 익숙하기 때문에, 이렇게 글을 읽는 흐름이 여러 방향으로 섞이면 읽기가 어렵습니다. 이런 문제는 클로저만이 아니라 함수 호출 기능이 있는 다른 프로그래밍 언어에도 똑같이 있어요."),"\n",t.createElement(n.h3,null,"스레딩 매크로"),"\n",t.createElement(n.p,null,"클로저는 이 문제를 해결하는 도구를 제공합니다. 스레딩 매크로라는 녀석이예요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 906px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/b47eee3d25d48c521164ad8fec5f9c5d/6029f/img12.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 32.1285140562249%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAg0lEQVQY042OUQoDIQwF9/6XFIqgoEGoSWyqxoKCtOyWdr7y4E2SY3yiqo+JiNwnOWcAIKJx4jjLzjnvfYzRe++cu03+kpkZEUVkt1ccY/Tef8hEtD5n5r1uz9eyqi7TGMPMIYSU0roGACsCQK31q4yI1trnZPVUlYhKKYiYc26tvcsvD39fPbYfG4sAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/b47eee3d25d48c521164ad8fec5f9c5d/6029f/img12.png"\n        srcset="/static/b47eee3d25d48c521164ad8fec5f9c5d/6a5fb/img12.png 249w,\n/static/b47eee3d25d48c521164ad8fec5f9c5d/79e1b/img12.png 498w,\n/static/b47eee3d25d48c521164ad8fec5f9c5d/6029f/img12.png 906w"\n        sizes="(max-width: 906px) 100vw, 906px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"스레딩 매크로를 이용하면 안에서 밖으로 읽는 코드를, 좌에서 우로 읽도록 작성할 수 있어요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 936px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/3eb5ee246e5c4fa80366c96bd07ebf27/6d2da/img13.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 34.53815261044177%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAhElEQVQY052Qyw4DIQhF5/8/VQ2ODwS1QhNNbJtpu5izItx7QsJBRIjonENEvcDM1lo3CSF470spOz1SSqUUImLmnLMxptaqqiKiqq21GKP3frXX8iU/Jqp6nicAjMmORQQR3699yHvqk2uj1goAKaV/8i/GGG1yR+69ry/ckZmZiL7KTyTknbOYf+TeAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/3eb5ee246e5c4fa80366c96bd07ebf27/6d2da/img13.png"\n        srcset="/static/3eb5ee246e5c4fa80366c96bd07ebf27/6a5fb/img13.png 249w,\n/static/3eb5ee246e5c4fa80366c96bd07ebf27/79e1b/img13.png 498w,\n/static/3eb5ee246e5c4fa80366c96bd07ebf27/6d2da/img13.png 936w"\n        sizes="(max-width: 936px) 100vw, 936px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"이 두 코드는 같은 연산식인데요. 왼쪽 코드는 함수를 어디서부터 읽어야 할지 약간 헷갈립니다."),"\n",t.createElement(n.p,null,"하지만 오른쪽 코드는 1000에서 시작하고, inc라는 함수로 값을 1 증가시키고, 500을더하고, 음수로 바꾸고, 문자열로 바꾼다는 순서를 바로 알 수 있습니다."),"\n",t.createElement(n.p,null,"다른 언어에서도 이 문제를 해결하기 위해 메서드 체인 같은 기법을 이용하기도 합니다. 메서드 체인은 특정 타입의 객체와 메서드로만 수행할 수 있지만, 스레딩 매크로는 어떤 데이터에 대해서든, 어떤 연산자나 함수로도 수행할 수 있어 더 일관성이 있습니다."),"\n",t.createElement(n.h2,null,"재귀 (recursion)"),"\n",t.createElement(n.p,null,"리스프는 재귀를 적극적으로 사용하는 언어입니다. 그런데 재귀 때문에 리스프를 좋아하지 않는 분도 계시지 않을까합니다. 재귀에 대해서 막연히 어렵게 느끼시는 분들이 많으시거든요. 하지만 재귀는 수학적 귀납법으로 정의한 식을 코드로 간단히 옮길 수 있게 해줘요. 그런 용도로 쓰면 쉽고 우아한 코드를 짤 수 있어요."),"\n",t.createElement(n.p,null,"재귀에 대한 자세한 내용을 다룰 수는 없고, 클로저로 연결 리스프를 만드는 예를 간단하게 살펴보겠습니다."),"\n",t.createElement(n.h3,null,"리스트 잇기 (cons)"),"\n",t.createElement(n.p,null,"리스프에서는 cons라는 함수로 연결 리스트를 만듭니다. cons는 첫번째 인자로 리스트에 추가할 요소를, 두번째 인자로 다른 연결 리스트를 입력받아요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/887ea7ade79b246b0742b6ff0918ebec/37523/img14.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 24.49799196787149%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAmElEQVQY052Puw7DMAwD+///6SHRI7HkyIIcOQWSoWjH3kCQww18mZmIXH/xaq0RUdyMMSIiM59+nue4ycwnM3PO+ZGv63L3UsqyLNu2AUDvHQBqrcyMiEQkIqUURASAiPjIc87eOyKu67rvOxG5OzOrKjOLSK1VVVtrY4x58yVHhKqKiJm11p5pZsdxuHvv3d3NLDN/Pr8B6UAi4Pl+V2wAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/887ea7ade79b246b0742b6ff0918ebec/37523/img14.png"\n        srcset="/static/887ea7ade79b246b0742b6ff0918ebec/6a5fb/img14.png 249w,\n/static/887ea7ade79b246b0742b6ff0918ebec/79e1b/img14.png 498w,\n/static/887ea7ade79b246b0742b6ff0918ebec/37523/img14.png 720w"\n        sizes="(max-width: 720px) 100vw, 720px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"리스트를 처음 만들 때는 두번째 인자에 그냥 nil을 넣습니다. 이렇게 (cons 1 nil)을 평가하면, 원소가 1만 들어있는 리스트가 되고요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/b18ff50d6487ffecd81f8e9eb231a310/37523/img15.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 18.072289156626507%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAATklEQVQI15XLMQqAMAwAwH5XN8EHKuLoK7qWhFLakJSk0snV3H6htYP5Yj6JblUak41/QowL4pbzCrCLJF8uBQEeM8f5skjtPdmkZr7/AoKN6ifQqilaAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/b18ff50d6487ffecd81f8e9eb231a310/37523/img15.png"\n        srcset="/static/b18ff50d6487ffecd81f8e9eb231a310/6a5fb/img15.png 249w,\n/static/b18ff50d6487ffecd81f8e9eb231a310/79e1b/img15.png 498w,\n/static/b18ff50d6487ffecd81f8e9eb231a310/37523/img15.png 720w"\n        sizes="(max-width: 720px) 100vw, 720px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"여기에 다른 요소를 추가하려면, cons를 한번 더 붙이면 돼요. 이렇게 2를 추가해주면, (2 1)이 되죠."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/80975c1ef9c3d4cf523cab8afedb566b/37523/img16.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 18.072289156626507%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAdklEQVQI15XOSw6CMBSF4e4Wgwkj18NWeCRuoAMjU2ACQSqxrdw+ziXoXOI/Pl9yRPW2BYWbbd1aEtWeqllfJ2eZGQz+mTj33elh8mc99MmsMrOk9+EizbhjHGGlSaomvORnGPmfhHF+8toHBTAQgBgRDw9/8QbjJuZK7xZexQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/80975c1ef9c3d4cf523cab8afedb566b/37523/img16.png"\n        srcset="/static/80975c1ef9c3d4cf523cab8afedb566b/6a5fb/img16.png 249w,\n/static/80975c1ef9c3d4cf523cab8afedb566b/79e1b/img16.png 498w,\n/static/80975c1ef9c3d4cf523cab8afedb566b/37523/img16.png 720w"\n        sizes="(max-width: 720px) 100vw, 720px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"또 한번 더 하면, (3 2 1)이 됩니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/e89f51dc4b7473c184b220fabb0c4d2f/37523/img17.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 17.269076305220885%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAZklEQVQI12PY+nlb7NPY/I95Wa/OJT193/Tl5oPHWe/fp//4lHb4eemWT6f+////9//f/9gAw/8//198fLr37ZWPny7///f/PxgTCRj+/fv35ffnp7/e/fjz4R9IK5gAo38ghE8zAJZhqLMrkqDqAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/e89f51dc4b7473c184b220fabb0c4d2f/37523/img17.png"\n        srcset="/static/e89f51dc4b7473c184b220fabb0c4d2f/6a5fb/img17.png 249w,\n/static/e89f51dc4b7473c184b220fabb0c4d2f/79e1b/img17.png 498w,\n/static/e89f51dc4b7473c184b220fabb0c4d2f/37523/img17.png 720w"\n        sizes="(max-width: 720px) 100vw, 720px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"이런식으로 cons을 계속 덧붙여서 연결 리스트를 계속 이어만들 수 있어요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 748px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/b198584cd75aa8ac08b989f0e5d0de2f/f8915/img18.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 16.867469879518072%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAkUlEQVQI143LsQrCMBAA0P66CF3yDzo6CUrBTk5duihCwUVQqFLEkuZyd7mLYI30D3z7y1QVABAxECtKCOrcwMQLt8xhZnBlAHLSI64V5kFM70zR762HlFImIl3XDXZo7aN5XgK/AFBUKq4KvyljXXpfSLzJQfw2vkvk3YnPQWXK4zgSkZJcpa2w+cR7mnzTH34WWaQHWMNhMwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/b198584cd75aa8ac08b989f0e5d0de2f/f8915/img18.png"\n        srcset="/static/b198584cd75aa8ac08b989f0e5d0de2f/6a5fb/img18.png 249w,\n/static/b198584cd75aa8ac08b989f0e5d0de2f/79e1b/img18.png 498w,\n/static/b198584cd75aa8ac08b989f0e5d0de2f/f8915/img18.png 748w"\n        sizes="(max-width: 748px) 100vw, 748px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"그러면 재귀와 cons를 이용해서, 무한한 자연수의 시퀀스를 정의해 보겠습니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 818px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/f0f95e98622b8b398980f431d5667d10/64d87/img19.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 45.78313253012048%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA50lEQVQoz32Q227EIBBD+f/fjAhLwnUYbglhKkE3irptzxOyMDZm3vvX68U5d86FEIQQWmsp5b7v3nshhLV2f8M5jzESUe+diFgf0Jt5fiq3fnOLjIhaa1JKrTUiSimVUjlnKeW2bW5gjAEA+oDNVwFgWZbZVilVSjkHrTVEFEL8ab6ua2ZqrQHAe6+UstbGGGutpZR1XRHxd/MnP354DZ6jfJtzzsYYRAQARJyZ99X/YSml2dZa672f85RBzvk4DiKKMQJAKSUM7nBWa3XOpZRCCABwnqe1NqUEAFPvvSPinMA59+z1BUYyCgdazrYOAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/f0f95e98622b8b398980f431d5667d10/64d87/img19.png"\n        srcset="/static/f0f95e98622b8b398980f431d5667d10/6a5fb/img19.png 249w,\n/static/f0f95e98622b8b398980f431d5667d10/79e1b/img19.png 498w,\n/static/f0f95e98622b8b398980f431d5667d10/64d87/img19.png 818w"\n        sizes="(max-width: 818px) 100vw, 818px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"자연수의 시퀀스는 첫번재 요소가 0이고, 그 다음 요소는 이전 요소에 1을 더한 수이다. 이렇게 재귀적으로 자연수의 시퀀스를 정의해 보았어요. 이렇게 하면 연쇄적으로 시퀀스의 모든 요소를 구할 수 있겠죠."),"\n",t.createElement(n.p,null,"이것을 연결 리스트를 만드는 cons로 옮기면 아래쪽 코드처럼 될 겁니다. cons 0 cons 1 cons 2 cons 3 ... 하면서 계속 이어지는 거죠. 물론, 리스트의 요소를 직접 다 나열할 수가 없습니다. 그래서 이를 자기 참조 구조, 즉 재귀로 정의합니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 818px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/7dc43f7d07838443c7b94a95a1a350c2/64d87/img20.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 45.78313253012048%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA40lEQVQoz4VRy24CMQzkjzmA+gv9K7TttR/QO1IFAZJsss7D60cqBK2UpaKjkSwfxqPxrNo/0J4dVreBiMacKgGwm6WI0tNzvVhViJiVEvvKkDkkspk8SkLJv9S7UjvxA0Qbi1KhWDhWmSpPlSGRRYGlMzMfDkfnnDEnP5bLJe335zDOMTBzFzWRnyUvnXPO1vqUnPev1q5jfDFma84bSJsQt2NYT/GzaROdgdxSzEy1IhOG8mFhF+u7hcHBEOsQytuYd4BflTOQJanPM/8BUkRJrPMyc1+FaJPrz/TK9rM+tvUNIzAMJHr3s7QAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/7dc43f7d07838443c7b94a95a1a350c2/64d87/img20.png"\n        srcset="/static/7dc43f7d07838443c7b94a95a1a350c2/6a5fb/img20.png 249w,\n/static/7dc43f7d07838443c7b94a95a1a350c2/79e1b/img20.png 498w,\n/static/7dc43f7d07838443c7b94a95a1a350c2/64d87/img20.png 818w"\n        sizes="(max-width: 818px) 100vw, 818px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"cons의 첫번째 원소는 n이 되고요, 그리고 cons의 두번째 원소로는 리스트를 넣어야 되는데, 무한 자연수 리스트를 만드는 함수, 그러니까 지금 정의하고 있는 함수를 호출해서 넣어줍니다. n에 1을 증가 시켜서요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 933px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/02e775ee208347a13b3b4790f3cf3d68/dc616/img21.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 40.16064257028112%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABKklEQVQY042Qu0oDURCGz4vaaaOIAREstsmlt7ISQUTTCILgA4SItUZ8AyExuztnZ+dc9jLnItlgiGLhx89088H/i6Z51/q2qu6Uutf6saqmIcSf+C5/IOp6JuUl4hjgDGCHqFfXE2ufmZ+aZlJVs8619v22Cu+jUk7KaO0H4k1ZXuX5wXK5p/WhlPtEfeZX5jfm+vslbCyCuUWUWfaplAFwxiiAC8TzPB/N54lSSZb1iuJE6xfnUmazXUowMxFJKbVWiGCtkbI1JiKOpRwQjRaLhCghOiqKXYCHtkXvyfuVQzjniAgAjDGI2F0whoioLFtrJ4inSg0AhgDDuu4THRfFtTE+BC9ijE3TpGmqlMrzHBGdc6tmwXdxIbSbxMgxus34IqzX3CL+my8rrr8hB8xtvwAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/02e775ee208347a13b3b4790f3cf3d68/dc616/img21.png"\n        srcset="/static/02e775ee208347a13b3b4790f3cf3d68/6a5fb/img21.png 249w,\n/static/02e775ee208347a13b3b4790f3cf3d68/79e1b/img21.png 498w,\n/static/02e775ee208347a13b3b4790f3cf3d68/dc616/img21.png 933w"\n        sizes="(max-width: 933px) 100vw, 933px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"그리고 이 함수에 0을 넣어서 실행하면 재귀적으로 무한한 리스트가 만들어집니다. 자연수의 무한 시퀀스를 만들었네요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 933px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/b5b15fc915873244938e97512c5db246/dc616/img22.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 14.457831325301203%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAANklEQVQI15XLwQkAIAwDQPcfNpWGBvpJBSfQ+9+SVJckACRtz5vV3REBYF+SPrLtzCRZVfPpABIqsSgKLnR/AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/b5b15fc915873244938e97512c5db246/dc616/img22.png"\n        srcset="/static/b5b15fc915873244938e97512c5db246/6a5fb/img22.png 249w,\n/static/b5b15fc915873244938e97512c5db246/79e1b/img22.png 498w,\n/static/b5b15fc915873244938e97512c5db246/dc616/img22.png 933w"\n        sizes="(max-width: 933px) 100vw, 933px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"그러면 실제로 호출을 해볼 건데요, 무한한 시퀀스를 한꺼번에 다 가져오면 스택 오버플로 에러가 날 겁니다. 그래서 시퀀스에다가 (take 10)을 적용해서 처음 열 개의 요소만 구하도록 합니다."),"\n",t.createElement(n.p,null,"하지만 실제로 실행해보면, 역시나 스택 오버플로 에러가 발생하게 됩니다. take 10을 하기 전에 무한한 시퀀스를 끝까지 만들기 때문입니다."),"\n",t.createElement(n.h3,null,"지연 시퀀스 (lazy-seq)"),"\n",t.createElement(n.p,null,"이 문제를 해결하려면, 리스트를 필요한 데까지만 계산하는 방법이 필요합니다. 그래서 클로저는 지연 시퀀스라는 도구를 제공합니다."),"\n",t.createElement(n.p,null,"지연 시퀀스는 시퀀스의 각 요소들을 계산하지 않고 미루고 있다가, 요소를 정말로 써야할 때, 딱 필요한 그 요소까지만 비로소 계산하여 구해줍니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 933px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/4437092a3625abba3766a07694cd4847/dc616/img23.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 31.72690763052209%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABAklEQVQY03WPPU7DQBCFfdoQgsAJBQ0FFTUHCEUkChoOwBFCQZkWKST2ep3s3+x4vXbwDGQRBUg8fcVrPs28zJi5KEeAs005tZBrk0uZA+RVNVVqFuOYaEXERAMR8e9kzJpZJMqfcoSoIBLMBXPH/yTDplfSLF1Y+PhkUGrvbJC1De0BICC2Wlvw3gE455JCiSTHpgm7+hXcHMKjxtr4DgCNOrTB+7ZponfYI0bvEfDvZZ0+s8e+Zy4/qJY8lMw77phKpqIlW6RJSMD0Pgxbos33luweYCTkldyu9reqGq/dzbVanwh7J16MujDydBkXk8qcSf1cP1g5Ueay78+Z377kT9+6SXI6GX53AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/4437092a3625abba3766a07694cd4847/dc616/img23.png"\n        srcset="/static/4437092a3625abba3766a07694cd4847/6a5fb/img23.png 249w,\n/static/4437092a3625abba3766a07694cd4847/79e1b/img23.png 498w,\n/static/4437092a3625abba3766a07694cd4847/dc616/img23.png 933w"\n        sizes="(max-width: 933px) 100vw, 933px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"클로저에서 지연 시퀀스를 만들려면 리스트를 lazy-seq로 감싸주면 됩니다. 이런 식으로 cons 앞에 lazy-seq 로 한번씩 감싸주는 거죠."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 933px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/4f87351eb8d4cc909ce25dc7f4711247/dc616/img24.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 31.72690763052209%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA8klEQVQY043MvUoDQRSG4b1bdVEEQRS1Eqy9AQuL3ICltShaaiEpgpidrO7Mztn5SbKZmZM5R11EsNKHr32/Atp2qXWvtVXQdWE61UoZ5ywi8l+Kdr0+Bn2g5yN967sjgH3vr5SyxgAA1HXtvXcDY0xK6Ve8QLwDuAH7bEXGJ8THhPVqFUOMMYa+XyKmmL4RZWYaNsQ/N0QcE/c9/1+hc34lEpQDyRQndj55I6yIJQXKgqlaZBCZBLHLlqnKeUYkmONXfOH9RqMOZT3WZ06Vs8XpCVSbjTt/f7DdrpVb9+GybMy27K7bkZUlmL2UdphfPuMPWDFOODJu1wcAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/4f87351eb8d4cc909ce25dc7f4711247/dc616/img24.png"\n        srcset="/static/4f87351eb8d4cc909ce25dc7f4711247/6a5fb/img24.png 249w,\n/static/4f87351eb8d4cc909ce25dc7f4711247/79e1b/img24.png 498w,\n/static/4f87351eb8d4cc909ce25dc7f4711247/dc616/img24.png 933w"\n        sizes="(max-width: 933px) 100vw, 933px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"그러면 원래 정의했던 무한 시퀀스 함수에, lazy-seq를 넣어봅니다. cons 를 lazy-seq로 감싸기만 하면 되죠."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 933px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/b90203c7e4cfc0cd58def059c8209995/dc616/img25.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 18.47389558232932%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAWUlEQVQI143LwQ0AIQgEwOu/T+MDAUGiJG70WnD+80VE77215u5EVEph5sy8D769t6oys4iYWURkJoCnDEBEiMjM1lr3XgDnnKesqhExxjAzEXH3Wuuc8yX/SVrqXmqVgKYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/b90203c7e4cfc0cd58def059c8209995/dc616/img25.png"\n        srcset="/static/b90203c7e4cfc0cd58def059c8209995/6a5fb/img25.png 249w,\n/static/b90203c7e4cfc0cd58def059c8209995/79e1b/img25.png 498w,\n/static/b90203c7e4cfc0cd58def059c8209995/dc616/img25.png 933w"\n        sizes="(max-width: 933px) 100vw, 933px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"이렇게 무한 시퀀스를 지연 시퀀스로 정의해놓으면, 필요한 데까지만 평가해서 값을 구할 수 있습니다. 이제 스택 오버플로가 발생하지 않아요."),"\n",t.createElement(n.p,null,"이렇게 클로저에서 재귀를 이용하는 방법을 알아보았습니다. 참 쉽죠?"),"\n",t.createElement(n.p,null,"흐음..."),"\n",t.createElement(n.p,null,'하지만 "이것도 어렵다! 불편하다! 리스트? 클로저? 그딴 건 역시 못해 먹을 물건이군!"이라고 생각하시는 분들도 계실 겁니다.'),"\n",t.createElement(n.h2,null,"시퀀스 추상 (sequence abstraction)"),"\n",t.createElement(n.p,null,"저는 그 불편한 느낌이 정당하다고 생각해요. 다행히도 클로저에서는 우리가 재귀를 직접 써야 하는 경우가 거의 없어요. 클로저에서는 여러가지 반복되는 패턴들을 시퀀스 라이브러리를 이용해서 추상화해두었기 때문이에요. 실제로 그린랩스의 프로덕션 코드에는 재귀를 직접 작성한 경우가 단 한 곳도 없습니다!"),"\n",t.createElement(n.p,null,"앞에서 작성했던 자연수의 무한 시퀀스는 (iterate inc 0) 이라는 시퀀스 함수를 사용해서 간단히 나타낼 수 있어요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 948px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/d3e1e2f082a7fef05c6c42964a3a5e40/ecf19/img26.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 55.02008032128515%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABV0lEQVQoz42R267cMAhF5///sZqjXCZOHGM7tvEVqHL60OlUqrpBvMDSljYPIlqXdZ7m8zRqU8ehp2m24F6vDcB+NyilrLUiwszypocIE7dGpRFid3lcmXwa0CjXgXXgoE6Diej7/k+4EiqYbdA+QsIUU3TOpny5eA4pQ3KTVPiqHDpn/oBxOAB7HHpTSmu9bduyLACg9VlyuXzw3ueCiOlKcOXznX+kAaUUMGDBWnDO+hhTSuicCyEaA2BsxhJjCiFAVCz0G+5U5/3Hphfjj+n1VHrxwZEMESEZJJWkds6FQ2Y/pH0EJizcpTTOnfPgGru5+l4oFoqV7swaITF9RH3DzHw/Y1PzPJvTPp9f6/E1TfOudnOaYz/O06zrSx/aWmuM+cuZ70+MMYjJli330Ntd9+idiFpr95ao9/7pnFLy3iNijNGn8z2Sf+uGEfEXjIi1VPlv/QSleH1j+6GlQAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/d3e1e2f082a7fef05c6c42964a3a5e40/ecf19/img26.png"\n        srcset="/static/d3e1e2f082a7fef05c6c42964a3a5e40/6a5fb/img26.png 249w,\n/static/d3e1e2f082a7fef05c6c42964a3a5e40/79e1b/img26.png 498w,\n/static/d3e1e2f082a7fef05c6c42964a3a5e40/ecf19/img26.png 948w"\n        sizes="(max-width: 948px) 100vw, 948px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"이 둘은 똑같이 무한한 자연수의 시퀀스를 만들어냅니다."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 956px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/f19e4f1118557fe8c57100af806920a7/7b1dc/img27.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 45.78313253012048%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA30lEQVQoz5XP3W6GIAwGYO7/Jo0Bv4ppRAq0qDCWQLLPbSfbc0DCT2lfRUQAsO87ADjnEPH1egGA1toYw8yttVrrx0PtWmuq1lpKyTkbY6y1Wutt26ZpGvUAMLbOOQBAxHmerbXruoYQVOtKKYhIRMuyXNfVHkarH+ugxnUpZUzuvY9dSimEQEQxRkTMOd/d81/Vvvud7dltPHgXi8hxHDFGZk4ptf9QzIyIe+e9Z2YRSSnlnKUbJ9yNgO/i+76ZmYiO4xARIhpbERnJv/KnlGqtz9jqPM/RiplL9/exPwG5Zwp852CBLQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/f19e4f1118557fe8c57100af806920a7/7b1dc/img27.png"\n        srcset="/static/f19e4f1118557fe8c57100af806920a7/6a5fb/img27.png 249w,\n/static/f19e4f1118557fe8c57100af806920a7/79e1b/img27.png 498w,\n/static/f19e4f1118557fe8c57100af806920a7/7b1dc/img27.png 956w"\n        sizes="(max-width: 956px) 100vw, 956px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"iterate는 함수와 초깃값을 인자로 받아, 초깃값에 함수를 재귀적으로 적용하는 무한 지연 시퀀스를 만들어줍니다."),"\n",t.createElement(n.p,null,"iterate 함수를 이용하면 재귀가 훨씬 더 쉽게 느껴지죠. 왜일까요? 앞에서 재귀 시퀀스를 직접 작성했을 때 어렵게 느껴졌던 이유는, 재귀 과정에서 발생하는 ‘패턴’을 프로그래머가 직접 작성해야 했기 때문이에요."),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"프로그래밍이란,\n문제와 무관한 요소들을 모두 배제할 때,\n정복하지 못한 복잡성을 피하고,\n여러 고려사항들을 매우 격렬하게 분리할 수 있는,\n가장 효율적인 사고방식 --\n그 이상도 그 이하도 아닌 바로 그것이다. - 데이크스트라"),"\n"),"\n",t.createElement(n.p,null,"데이크스트라는 GOTO 문으로 반복 패턴을 짜는 걸 비판했고, 우리는 이제 GOTO를 이용해 패턴을 직접 작성하는 대신에 while, for, 서브루틴(함수), throw-catch 등을 사용하죠. 하지만 패턴은 여전히 많습니다."),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"나는 프로그램 안에서 패턴을 발견하면\n그것을 뭔가 문제가 발생하고 있다는 신호로 받아들인다.\n프로그램의 형태는 오직 그것이 해결해야 하는 문제만 반영해야 한다.\n코드에 존재하는 그 밖의 모든 정형성은\n내가 충분히 강력하지 않은 추상을 이용하고 있다는 신호로 다가온다. - 폴 그레이엄"),"\n"),"\n",t.createElement(n.p,null,"프로그램이 다루는 건 문제 그 자체에 대한 것이어야지, 문제 외의 요소가 끼어들어서 프로그램을 복잡하게 만들어서는 안 됩니다. 코드를 짤 때 어떤 패턴이 반복적으로 나타나고, 프로그래머가 그 패턴을 직접 제어해야 한다? 그건 문제 밖의 요소입니다. 그건 원래 프로그래밍 언어가 기능으로 제공해주어야 하는 부분인데, 개발자가 패턴을 짜고 있다는 건, 언어가 할 일을 프로그래머가 대신하고 있는 걸 뜻해요."),"\n",t.createElement(n.p,null,t.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 996px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/a008506bec02bbcc92665d205f848820/84bf8/img28.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 48.192771084337345%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaUlEQVQoz42Qy0oDUQyG52VdCoqCDyKIiujChRU33YsbURAU7UJqEWyt0ta5nTmZc79GO4pt1YUfIWSRP/mT5N65nrUP3k+ztU/ORfyD2MQPkuWyXE3TVUpX3tKlvFipqmtrO0bfOJ+5556DjvVhqn7B0A0hGmO01lJKY0yyTsh6nq8VZINMdkR1RGELYCtNNym7E2fHfLDLFSIOzPmtbEmuxuMxIaQsSyFEsk9pi9WHOWmzUe4o+hjjgsHQ5AuHJxaNUgAwsz3fJ4ScZFl/OKwAIqKPwWP0syFfZYxfC2ZiACaVBEq73a7WGv9Bcm4uH911qi+fqwEieu+ttYt/ni7ph34ndIILsuFzerJJt0/5waPaew3D79bFm6dXX/mrtmlbbQGAEMIYa2xzjBaNQKecNloIoRuUUp8151wq6aVH+8v2cPRSMzp5GxVlwRgjhHDOAYBSWhRFXdd5nldVlRVZLer5b32I3wHucDYBm0kDAAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="그림"\n        title="그림"\n        src="/static/a008506bec02bbcc92665d205f848820/5caea/img28.png"\n        srcset="/static/a008506bec02bbcc92665d205f848820/6a5fb/img28.png 249w,\n/static/a008506bec02bbcc92665d205f848820/79e1b/img28.png 498w,\n/static/a008506bec02bbcc92665d205f848820/5caea/img28.png 996w,\n/static/a008506bec02bbcc92665d205f848820/84bf8/img28.png 1162w"\n        sizes="(max-width: 996px) 100vw, 996px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",t.createElement(n.p,null,"앞의 예를 다시 살펴보면, 문제의 본질은 기저값 0과 귀납 함수 inc입니다. 그리고 그 함수를 반복적으로 적용하여 시퀀스를 만든다는 것이 핵심이죠. 그런데 지연 시퀀스를 재귀적으로 만드는 게 프로그래밍에서 자주 나타내는 패턴인 거고, 그걸 함수로 추상화해놓으면 프로그래밍이 훨씬 쉬워집니다. 패턴을 제거하면 불필요한 복잡성이 없어지고, 문제의 핵심인 0과 inc만 남습니다."),"\n",t.createElement(n.p,null,"클로저에는 프로그래밍에서 자주 발견되는 여러 가지 패턴들을 시퀀스 라이브러리라는 형태로 일반화 했습니다. 프로그래밍 클로저라는 책에 실린 예제를 한번 살펴보겠습니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-text"},"public class StringUtils {\n  public static boolean isBlank(String str) {\n    int strLen;\n    if (str == null || (strLen = str.length()) == 0) {\n      return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n      if ((Character.isWhitespace(str.chatAt(i)) == false)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n")),"\n",t.createElement(n.p,null,"이 자바 코드는 아파치 커먼스 라이브러리에서 가져온 모범 코드입니다. 문자열이 비어 있거나 공백 문자만으로 되어 있는지 검사하는 함수네요. for 문 안에서 문자열을 순회하면서 공백 문자를 검사하고 있어요. 코드 전체가 클래스 안에 정의되어 있기도 합니다. 그런데 제가 보기에는 이런 코드는 불필요한 복잡성으로 느껴집니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-text"},"(defn blank? [s]\n  (every? #(Character/isWhitespace %) s))\n")),"\n",t.createElement(n.p,null,"클로저 코드에서는 두 줄이면 끝납니다. 함수의 본문은 한줄이네요. 모두 참인가? 각 문자가 공백문자인가? 라는 것으로 정의가 끝입니다. 이처럼 클로저에서는 불필요한 복잡성을 최대한 배제하고, 문제 그 자체에 따르는 필연적인 복잡성만을 다룰 수 있도록 언어에서 많은 지원을 하고 있습니다."),"\n",t.createElement(n.h2,null,"지금까지 살펴본 것"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"S-식","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"연산의 형태를 일반화한다."),"\n",t.createElement(n.li,null,"연산이 여러 개의 애리티를 가질 수 있게 한다."),"\n",t.createElement(n.li,null,"가변 애리티로 코드가 더 간결해진다."),"\n",t.createElement(n.li,null,"연산의 결합이나 우선순위에 대한 고민을 없앤다."),"\n"),"\n"),"\n",t.createElement(n.li,null,"스레딩 매크로","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"코드를 읽는 방향을 자연스럽게 만든다."),"\n"),"\n"),"\n",t.createElement(n.li,null,"재귀","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"자신을 참조하는 연산이나 데이터 구조를 쉽게 정의한다."),"\n",t.createElement(n.li,null,"무한 지연 시퀀스를 만들 수 있다."),"\n"),"\n"),"\n",t.createElement(n.li,null,"시퀀스 추상","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"프로그램에서 반복되는 패턴을 간단한 구조로 나누어 제거한다."),"\n"),"\n"),"\n"),"\n",t.createElement(n.p,null,"지금까지 클로저 코드를 읽기 쉽게 해주는 여러 기능들을 알아봤습니다. 이런 기능들은 처음에는 낯설지만, 배우고 나면 클로저 코드를 더 간단하고 쉽게 쓰고 읽을 수 있게 도와줍니다."),"\n",t.createElement(n.p,null,"쉽고 어려움을 판단하는 일에는 주관적인 성격이 있지요. 처음 배우는 동안에는 학습 비용이 든다는 측면에서는 어려울 수 있습니다. 하지만 일단 기초를 익힌 후에는, 코드를 읽고 쓰는 노력이 훨씬 덜 들고, 저는 그걸 '쉽다'고 하겠습니다."),"\n",t.createElement(n.h3,null,"함수형 언어를 배워야 하는 이유"),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,'"아동이 숙달한 언어구조는 인지의 기본 구조가 된다." - 비고츠키'),"\n"),"\n",t.createElement(n.p,null,"언어는 사고를 지배합니다. 언어가 없이도 생각을 할 수 있을 것 같지만, 언어를 사용하지 않으면 흐릿한 심상이 떠올랐다 사라질 뿐입니다. 논리적이고 체계적인 사고는 언어를 통해서만 가능하죠."),"\n",t.createElement(n.p,null,"그래서 언어는 커뮤니케이션의 수단이기만 한 것이 아닙니다. 언어를 정확하고 정교하고 효율적으로 사용하는 것은 우리의 인지, 결정, 행동, 삶에 영향을 끼치는 매우 중요한 문제입니다."),"\n",t.createElement(n.p,null,"프로그래밍 언어도 마찬가지입니다. 언어는 그냥 프로그램을 만드는 도구일 뿐이고, 아무거나 고르면 된다고 말씀하시는 분들이 많습니다. 튜링 완전성에 대한 이야기라면 맞는 말이겠지만, 문제를 어떻게 풀것인가도 중요하게 생각한다면, 언어도 잘 골라야 합니다. 프로그래밍 언어는 프로그래머의 사고방식과 문제 해결 방법에 큰 영향을 끼치기 때문입니다. 다른 패러다임의 언어를 익히면 새로운 방법으로 사고할 수 있습니다."),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,'"인간의 운명은 인간의 수중에 있다." - 사르트르'),"\n"),"\n",t.createElement(n.p,null,"우리는 한국어를 모국어로 사용하고 있죠. 그런데 이 말은 우리가 원해서 선택한 게 아닙니다. 태어나보니 한국어를 쓰는 환경이었던 거죠. 모국어가 무엇이냐는 우리에게 주어진 운명이라고 할 수 있어요."),"\n",t.createElement(n.p,null,"하지만 인간은 운명을 스스로 개척하는 생물이지 않습니까? 새로운 프로그래밍 언어를 배우는 것은 우리가 직접 선택할 수 있는 운명입니다. 새 프로그래밍 언어를 배우는 데는 수고가 들지만, 처음에 두려워 보이는 것만큼 어렵지는 않습니다. 그리고 새로운 점이 많을수록 얻는 게 더 많습니다."),"\n",t.createElement(n.p,null,t.createElement(n.strong,null,"오늘부터 운명을 바꾸는 행동을 한번 해보시는 건 어떨까요?")),"\n",t.createElement(n.p,null,"감사합니다."),"\n",t.createElement(n.h2,null,"참고 자료"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,t.createElement(n.a,{href:"https://insightbook.co.kr/book/8"},"<","프로그래밍 클로저",">"," 스튜어트 할로웨이 저, 인사이트 출판")),"\n",t.createElement(n.li,null,t.createElement(n.a,{href:"https://www.hanbit.co.kr/store/books/look.php?p_code=B6957684739"},"<","해커와 화가",">"," 폴 그레이엄 저, 한빛미디어 출판")),"\n",t.createElement(n.li,null,"<The Evolution of Lisp> Guy Steele, Richard Gabrieli 저"),"\n"))}var s=function(e){void 0===e&&(e={});var n=Object.assign({},(0,l.ah)(),e.components).wrapper;return n?t.createElement(n,e,t.createElement(i,e)):i(e)};var c=a(3710);function r(e){return t.createElement(c.Z,e,t.createElement(s,e))}c.Z}}]);
//# sourceMappingURL=component---src-templates-post-query-tsx-content-file-path-users-namenu-green-tech-blog-content-posts-is-clojure-hard-to-read-index-mdx-8c194e0b4a7a23a8869d.js.map