{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-namenu-green-tech-blog-content-posts-algebraic-data-type-index-mdx","path":"/algebraic-data-type","result":{"data":{"mdx":{"internal":{"content":null,"description":null,"ignoreType":null,"mediaType":null,"contentFilePath":"/Users/namenu/green/tech-blog/content/posts/algebraic-data-type/index.mdx"},"frontmatter":{"slug":"/algebraic-data-type","email":"woonki.moon@gmail.com","tags":["Algebraic Data Type","ReScriptReact"],"title":"대수적 데이터 타입과 리액트 상태 관리","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","date":"2021년 8월 31일","category":"engineering","author":"문운기"},"body":"\n### 대수적 데이터 타입(ADT: Algebraic Data Type)이란?\n\n대수적 데이터 타입에는 곱타입(product type)과 합타입(sum type)이 있습니다.<br /><br />\n\n#### 곱타입(Product type)\n\n<br />\n\n```reason\ntype boolAndInt = (bool, int)\n```\n\n`boolAndInt` 타입은 bool 타입과 int 타입을 가지는 튜플 타입입니다. `boolAndInt` 타입이 표현할 수 있는 데이터의 개수는 int 타입으로 표현할 수 있는 수([-2^31 .. 2^31-1]) 곱하기 2 입니다.\n\n```reason\n(true, 1)\n(false, 1)\n(true, 2)\n(false, 2)\n...\n```\n\n그래서 튜플은 <b>곱타입(product type)</b>이라고 합니다. 튜플, 레코드 등은 곱타입에 속합니다.<br /><br />\n\n#### 합타입(Sum type)\n\n<br />\n\n```reason\ntype boolOrInt = Bool(bool) | Int(int)\n```\n\n`boolOrInt` 타입은 bool 혹은 int 중 하나가 되는 배리언트입니다. `boolOrInt`로 표현할 수 있는 데이터의 개수는 int 타입으로 표현할 수 있는 수([-2^31 .. 2^31-1]) 더하기 2 입니다.\n\n```reason\ntrue,\nfalse,\n1,\n2,\n...\n```\n\n그래서 배리언트는 <b>합타입(sum type)</b>이라고 합니다. 배리언트, 태그드 유니언 등은 합타입에 속합니다.\n\n대수적 데이터 타입이란 위의 예와 같이 곱하기 혹은 더하기로 조합된 데이터 타입을 말합니다. 예를 들어 어떤 두 개의 타입 A와 B를 곱하거나 더해서 C라는 타입으로 조합하면, 이것을 대수적 데이터 타입이라고 부를 수 있습니다.\n\n숫자를 곱하거나 더하듯이, 숫자 대신 타입을 곱하거나 더하는 대상으로 사용하기 때문에 대수적(algebraic)이라고 합니다.\n\n### 대수적 데이터 타입으로 본 리액트 상태관리\n\n아래 리액트 컴포넌트는 bool과 int 타입, 두 개의 상태를 갖고 있습니다.\n\n```reason\n@react.component\nlet make = () => {\n  let (isError, setError) = React.useState(_ => false)\n  let (data, setData) = React.useState(_ => 1)\n\n  ...\n}\n```\n\n이 컴포넌트가 가질 수 있는 상태는 위에서 살펴본 곱타입과 같이 int로 표현할 수 있는 정수의 개수 곱하기 2가 됩니다. 즉, 상태가 하나씩 늘어날 때마다 컴포넌트는 곱으로 증가하는 상태를 가지게 됩니다. 상태가 늘어날수록 컴포넌트의 복잡도는 곱으로 늘어납니다.\n\n```reason\ntype status = (bool, int)\n\n@react.component\nlet make = () => {\n  let ((isError, data), setStatus) = React.useState(_ => (false, 1))\n\n  ...\n}\n```\n\n두 개의 상태 값을 하나의 튜플로 만들고 useState를 하나만 사용하더라도, 상태가 줄어들어 컴포넌트의 복잡도가 낮아지지 않았다는 것을 알 수 있습니다. 왜냐하면 튜플은 곱타입이고, 여전히 int로 표현할 수 있는 정수의 개수 곱하기 2의 상태값을 갖고 있기 때문입니다. 레코드나 오브젝트로 튜플을 대체해도 마찬가지입니다. 레코드와 오브젝트 모두 곱타입이기 때문입니다.\n\n### 합타입으로 상태를 정의하자.\n\n자바스크립트에는 배리언트나 태그드 유니언이 없기 때문에, 보통 오브젝트로 데이터를 모델링하는 경우가 많습니다. 자바스크립트 라이브러리인 [swr](https://swr.vercel.app/ko)도 데이터 요청 응답의 결과를 오브젝트로 반환합니다.\n\n```reason\n// 리스크립트의 레코드로 바인딩 한 swr의 응답 결과\nlet {data, error} = Swr.useSwr(url, fetcher, options)\n```\n\n이 경우 총 4가지의 상태가 존재할 수 있습니다.\n\n- data(X), error(X) => 로딩중\n- data(O), error(X) => 성공\n- data(X), error(O) => 에러\n- data(O), error(O) => ??\n\nerror와 data는 런타임에 동시에 존재할 수는 있지만, 양립할 수 없는 상태라고 볼 수 있습니다. 즉, error와 data를 곱타입이 아닌 합타입으로 모델링한다면, 상태를 줄이고 복잡도를 낮출 수 있습니다.\n\n자바스크립트에는 적절한 데이터 타입이 존재하지 않지만, 타입스크립트에서는 [서로소 합집합](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#discriminating-unions) 타입, 리스크립트에서는 배리언트 타입을 이용하여 합타입으로 상태를 모델링 할 수 있습니다. 그리고 모든 상태에 대해 대응하였는지 여부까지 컴파일 타임에 체크가 가능합니다.\n\n```reason\nmodule Orders = {\n  type result = Loading | Loaded(Js.Json.t) | Error(Js.Promise.error)\n\n  let use = () => {\n    let {data, error} = Swr.useSwr(url, fetcher, options)\n\n    switch error {\n    | Some(error') => Error(error')\n    | None =>\n      switch data {\n      | Some(data') => Loaded(data')\n      | None => Loading\n      }\n    }\n  }\n}\n\nlet status = Orders.use() // Loading | Loaded | Error\n```\n\n배리언트 타입의 응답 데이터를 반환하는 커스텀 훅을 만들어서 상태를 다시 정의할 수 있습니다. 합타입으로 상태를 정의하면 얻을 수 있는 이점이 있습니다.\n\n- 직교(orthogonal)하는 상태로 컴포넌트의 상태를 정의할 수 있습니다.\n- 불필요한 상태를 제거하여 컴포넌트의 복잡도를 줄일 수 있습니다.\n\n### 합타입과 패턴매칭\n\n합타입으로 조합된 타입들 각각은 동시에 존재할 수 없습니다. 리스크립트에서 패턴매칭은 모든 가능한 경우를 처리했는 지(Exhaustiveness checking)를 컴파일러가 보장해줍니다. 그래서 배리언트 타입의 상태와 함께 사용하면, 가능한 모든 상태에 대한 처리를 했는지 컴파일 타임에 체크할 수 있습니다.\n\n```reason\nswitch status {\n| Loading => <Loading />\n| Error(error) => <Error error />\n| Loaded(orders) => <Orders orders />\n}\n```\n\n### 결론\n\n일견 복잡해보이는 구조의 데이터도 결국 원시 타입의 자료형으로 이루어졌을 것입니다. 만약 어떤 데이터가 원시 타입의 값을 합과 곱으로 조합한 대수적 데이터 타입이고, 그 데이터를 더하거나 곱할 수 있는 연산을 정의한다면, 복잡해 보이는 데이터도 더하고 곱할 수 있습니다.\n역으로, 대수적 데이터 타입으로 데이터를 바라보면 합과 곱이라는 연산으로 데이터를 모델링하거나, 복잡한 구조로 보이는 데이터의 구조를 쉽게 파악할 수 있습니다.\n\n리액트 컴포넌트의 상태는 컴포넌트의 복잡도를 결정합니다. 합타입을 이용하여 직교하는 상태로 정의하면 복잡도를 낮출 수 있습니다.\n\n<br />\n<br />\n<Author\n  email=\"woonki.moon@gmail.com\"\n  name=\"문운기\"\n  description=\"프론트엔드 개발자\"\n  date=\"2021-08-31\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [Algebraic data type - Wikipedia](https://en.wikipedia.org/wiki/Algebraic_data_type)\n","id":"377d0253-0edd-5b64-b2f5-fd713111de89"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"},"id":"fc5716a7-cb14-5887-bbbc-2868900d4753"}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"모노레포 - 마이크로 아키텍처를 지향하며","date":"2023-01-16T00:00:00.000Z","author":"최경식","category":"engineering","description":"모노레포에 대해서 들어보셨나요? 프론트엔드에서 마이크로 아키텍처를 지향하려면 어떻게 해야할까요?","slug":"/monorepo-microfrontend"},"id":"7a6ee670-bba5-5f18-baa1-6fcdda49f8c7"},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"},"id":"fbb180f1-e03d-580e-b6b2-72a51db8a3ea"},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"},"id":"31b30552-417d-5cb3-a385-2ba938474bbf"},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"},"id":"ec180bef-ef40-521d-ac6b-9f30abcfef53"},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"},"id":"df129ef4-5001-5c2e-84bf-ee90e41af227"},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"},"id":"7fc5c006-6605-5432-9f94-0789645d355d"},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"},"id":"98914553-efc2-515a-b2d4-7eba07c0bfc5"},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"},"id":"6b9986fe-c5e8-5c79-b3db-31e120ddd392"},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"},"id":"748c611f-6eff-5719-abd8-7779f462e6dd"},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"},"id":"69bae138-e848-5a0c-a59d-deb23964f885"},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"},"id":"d99334fe-3434-552b-8a61-e0eb30248003"},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"},"id":"55c088b8-388b-5217-8021-fb99f880d1e1"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"},"id":"13e3bc56-c56f-514d-be53-6566467c13b4"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"},"id":"b9a9d532-8635-5bea-8287-c0c09465bf76"},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"},"id":"2952a571-bd4e-560e-a887-aa6402832b41"},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"},"id":"6d9760d4-7672-538e-b741-8a30e4c0f115"},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"},"id":"127d7aab-cdef-5e35-950d-397bb65e3ae4"},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"},"id":"0d135879-f937-5410-9f1f-8ee2ec32e3e0"},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"},"id":"8235f87d-16a5-58aa-b28d-887a3ece02f4"},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"},"id":"7a028bb2-5044-59b8-bf6b-27ffdef4bdf0"}]},"allMdx":{"edges":[{"node":{"id":"7a6ee670-bba5-5f18-baa1-6fcdda49f8c7","frontmatter":{"date":"2023-01-16T00:00:00.000Z"}}},{"node":{"id":"e552c767-7d9e-52bd-9d3e-4c6ca527e24a","frontmatter":{"date":"2023-01-02T00:00:00.000Z"}}},{"node":{"id":"288568ed-1bb5-50c9-bae2-7c544f7dd4b3","frontmatter":{"date":"2022-11-28T00:00:00.000Z"}}},{"node":{"id":"c3a9d0c7-d9c1-503a-97bb-06217c70b470","frontmatter":{"date":"2022-11-11T00:00:00.000Z"}}},{"node":{"id":"fc5716a7-cb14-5887-bbbc-2868900d4753","frontmatter":{"date":"2022-10-30T00:00:00.000Z"}}},{"node":{"id":"fbb180f1-e03d-580e-b6b2-72a51db8a3ea","frontmatter":{"date":"2022-10-26T00:00:00.000Z"}}},{"node":{"id":"e17bb8a2-8b48-5bb2-8c7d-47c8ec7e1aec","frontmatter":{"date":"2022-10-14T00:00:00.000Z"}}},{"node":{"id":"31b30552-417d-5cb3-a385-2ba938474bbf","frontmatter":{"date":"2022-08-25T00:00:00.000Z"}}},{"node":{"id":"4060e5a3-6533-50ce-b421-7a109c3c55c4","frontmatter":{"date":"2022-08-16T00:00:00.000Z"}}},{"node":{"id":"ec180bef-ef40-521d-ac6b-9f30abcfef53","frontmatter":{"date":"2022-07-27T00:00:00.000Z"}}},{"node":{"id":"df129ef4-5001-5c2e-84bf-ee90e41af227","frontmatter":{"date":"2022-07-21T00:00:00.000Z"}}},{"node":{"id":"64529c38-681b-553c-9538-f1be3fb41416","frontmatter":{"date":"2022-07-05T00:00:00.000Z"}}},{"node":{"id":"8a93582a-1654-5408-adb1-2547cb585a28","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"7fc5c006-6605-5432-9f94-0789645d355d","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"1c549fa1-f8d2-59be-98a9-7277f4e2367e","frontmatter":{"date":"2022-04-06T00:00:00.000Z"}}},{"node":{"id":"98914553-efc2-515a-b2d4-7eba07c0bfc5","frontmatter":{"date":"2022-01-11T00:00:00.000Z"}}},{"node":{"id":"26fe963e-c04c-59cd-af74-b2e510987154","frontmatter":{"date":"2021-12-29T00:00:00.000Z"}}},{"node":{"id":"6b9986fe-c5e8-5c79-b3db-31e120ddd392","frontmatter":{"date":"2021-11-22T00:00:00.000Z"}}},{"node":{"id":"748c611f-6eff-5719-abd8-7779f462e6dd","frontmatter":{"date":"2021-10-29T00:00:00.000Z"}}},{"node":{"id":"69bae138-e848-5a0c-a59d-deb23964f885","frontmatter":{"date":"2021-09-24T00:00:00.000Z"}}},{"node":{"id":"d99334fe-3434-552b-8a61-e0eb30248003","frontmatter":{"date":"2021-09-17T00:00:00.000Z"}}},{"node":{"id":"55c088b8-388b-5217-8021-fb99f880d1e1","frontmatter":{"date":"2021-09-13T00:00:00.000Z"}}},{"node":{"id":"377d0253-0edd-5b64-b2f5-fd713111de89","frontmatter":{"date":"2021-08-31T00:00:00.000Z"}}},{"node":{"id":"13e3bc56-c56f-514d-be53-6566467c13b4","frontmatter":{"date":"2021-06-01T00:00:00.000Z"}}},{"node":{"id":"b9a9d532-8635-5bea-8287-c0c09465bf76","frontmatter":{"date":"2021-05-30T00:00:00.000Z"}}},{"node":{"id":"2952a571-bd4e-560e-a887-aa6402832b41","frontmatter":{"date":"2021-04-27T00:00:00.000Z"}}},{"node":{"id":"6d9760d4-7672-538e-b741-8a30e4c0f115","frontmatter":{"date":"2021-01-29T00:00:00.000Z"}}},{"node":{"id":"127d7aab-cdef-5e35-950d-397bb65e3ae4","frontmatter":{"date":"2020-12-21T00:00:00.000Z"}}},{"node":{"id":"0d135879-f937-5410-9f1f-8ee2ec32e3e0","frontmatter":{"date":"2020-12-15T00:00:00.000Z"}}},{"node":{"id":"8235f87d-16a5-58aa-b28d-887a3ece02f4","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}},{"node":{"id":"7a028bb2-5044-59b8-bf6b-27ffdef4bdf0","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}}]}},"pageContext":{"slug":"/algebraic-data-type","title":"대수적 데이터 타입과 리액트 상태 관리","category":"engineering","email":"woonki.moon@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","author":"문운기","email":"woonki.moon@gmail.com","slug":"/algebraic-data-type","tags":["Algebraic Data Type","ReScriptReact"],"category":"engineering"}}},"staticQueryHashes":["318001574"]}