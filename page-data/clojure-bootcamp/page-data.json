{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-clojure-bootcamp-index-mdx","path":"/clojure-bootcamp","result":{"data":{"mdx":{"internal":{"content":null,"description":null,"ignoreType":null,"mediaType":null,"contentFilePath":"/Users/hyejin/Documents/tech-blog/content/posts/clojure-bootcamp/index.mdx"},"frontmatter":{"slug":"/clojure-bootcamp","email":"jungin.kwon1@gmail.com","tags":["Clojure"],"title":"그린랩스에서 클로저 시작하기","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","date":"2021년 9월 13일","category":"engineering","author":"권정인"},"body":"\nimport img from './diploma.png';\n\n안녕하세요. 저는 7월에 그린랩스에 백엔드 개발자로 입사한 권정인이라고 합니다. 저는 파이썬으로 6개월간 인턴십을 수행하고, 현업에서는 자바로 1년, 자바스크립트(및 타입스크립트)로 3년 정도 개발을 했습니다. 그러던 중, 그린랩스에서 함수형으로 개발을 한다는 소문을 듣고 입사하게 되었습니다.\n\n그린랩스의 부트캠프에 대해 궁금해하시는 분들이 많다고 들었습니다. (저도 입사 전에 너무 궁금했거든요!) 클로저 무경험인 제가 겪은 부트캠프는 어땠는지 이 글을 통해 공유해보려고 합니다.\n\n## 부트캠프 소개\n\n그린랩스에 백엔드 개발자로 입사하시면 '부트캠프'라는 온보딩 과정이 제공됩니다. 클로저 숙련도에 따라 초급자는 3주, 중급자는 1주에 걸쳐 진행됩니다.\n\n초급자 과정은 <u>Advent of Code 10문제 풀고 리팩토링하기</u>, <u>클로저로 작성한 AWS Lambda 배포해보기</u>, <u>클로저 웹서버 띄워보기</u>로 구성되어 있습니다.\n\n중급자 과정은 <u>Advent of Code 4문제 풀고 리팩토링하기</u>, <u>클로저 웹서버 띄워보기</u>로 구성되어 있습니다.\n\n## 1~2주차\n\n### 📙 클로저 시작하기\n\n문제를 풀기 전에 팀원분이 빌려주신 [{'<'}클로저 시작하기{'>'}(캐린 마이어 저, 인사이트 출판)](https://blog.insightbook.co.kr/2016/03/30/%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90%EA%B3%BC-7%EC%A3%BC-%ED%9B%88%EB%A0%A8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/)라는 책을 2장까지 읽었습니다.\n\n1장에서는 데이터 타입에 대해 공부했습니다.\n\n> 클로저의 데이터 타입은 정수, 실수, 분수, 문자열, 불린(boolean)을 포함하는 **단순값**, 리스트(list), 벡터(vector), 맵(map), 집합(set)을 포함하는 **컬렉션**이 있습니다.\n\n2장에서는 함수(defn), if, reduce, map 등에 대해 공부했습니다.\n\n부트캠프 코치님이 이 정도면 문제 풀기에 충분할 거라 하시더라고요. 문제가 어렵지 않을 거라는 예감이 들었습니다.\n\n### Advent of Code 문제풀기\n\n> 🎄 [Advent of Code(이하 AoC)](https://adventofcode.com)는 2015년부터 시작된 12월 1일부터 25일까지 크리스마스를 테마로 진행되는 문제 풀기 행사입니다.\n\n클로저 초급자인 저는 10개의 AoC 문제를 받았습니다. 동료분들이 한국어로 번역한 문제를 제공해 주어, 문제를 푸는 데만 시간을 쏟을 수 있었습니다. 한국어로 번역된 문제는 [그린랩스 GitHub](https://github.com/green-labs/bootcamp-aoc/tree/main/translations)에 공개되어 있습니다.\n\n제가 풀었던 기초적인 문제를 하나 살펴보겠습니다.\n\n**주어진 입력의 숫자를 더할 때마다 나오는 숫자 중, 처음으로 두 번 나오는 숫자를 구하시오.**\n\n문제의 입력 예로 `+3 +3 +4 -2 -4`를 들어 봅시다. `3(+3) -> 6(+3) -> 10(+4) -> 8(-2) -> 4(-4) -> 7(+3) -> 10(+3)` 와 같이 입력 순서에 따라 수를 반복하여 더합니다. 그러면 `10`이 처음으로 두 번 나오는 것을 발견할 수 있습니다. 이 입력 예의 답은 `10` 입니다.\n\n문제가 어렵지 않죠? 진짜 문제는 자바스크립트 코드밖에 떠오르지 않는 제 머릿속이었습니다...\n\n```javascript\nlet seen = new Set();\nlet sum = 0;\n\nfor (let index = 0; ; index++) {\n  sum += input[index % input.length];\n  if (seen.has(sum)) break; // 두 번 나오는 숫자가 있을 경우 break\n  seen.add(sum);\n}\n\nconsole.log(sum); // 답\n```\n\n자바스크립트 풀이와 비슷한 방법으로 클로저 코드를 작성해 보았습니다. 클로저에서는 `loop/recur`를 사용하여 코드를 반복 실행할 수 있었습니다. `#{}`은 클로저에서 집합을 만드는 표현입니다.\n\n```clojure\n(loop [input (cycle input)\n       sum 0\n       seen? #{}]\n  (let [sum (+ sum (first input))]\n    (if (seen? sum) ; 두 번 나오는 숫자가 있을 경우\n      (println sum) ; 답\n      (recur (next input) sum (conj seen? sum)))))\n```\n\n### 매일 오후 5:30 피드백의 시간\n\n문제를 풀다 보면 어느새 리뷰 시간인 오후 5시 30분이 되었고, 회의실이나 개더타운 앱에서 코드를 함께 보며 리뷰를 했습니다. 많은 피드백을 받았지만, 그중 몇 가지만 정리해 보겠습니다.\n\n1. 코드 스타일\n\n   처음에는 코드 스타일을 개선하라는 의견을 많이 받았습니다. 클로저에 익숙하지 않은 채로 작성하여 클로저에 어울리지 않는 코드를 많이 작성했습니다. 함수형 언어는 **가독성**이 높은 것이 장점이라는데, 뜻밖에도 제가 함수형 언어로 짠 코드는 다음날이 되면 저 자신도 읽지 못하는 사태가 벌어지곤 했습니다. 😂\n\n   동료 분들이 클로저 코드 스타일을 개선하는 데 도움이 되는 문서들을 공유해주셨습니다.\n\n   - [https://guide.clojure.style/](https://guide.clojure.style/)\n   - [https://bsless.github.io/code-smells/](https://bsless.github.io/code-smells/)\n\n2. 쓰레딩 매크로를 사용하기\n\n   ```clojure\n   (update (assoc {:name \"Socrates\", :age 39} :hair-color :gray) :age inc))\n\n   ;; 쓰레딩 매크로 사용\n   (-> {:name \"Socrates\", :age 39}\n       (assoc :hair-color :gray) ; 위의 식을 평가한 결과가 assoc 뒤의 첫번째 인자로 삽입된다\n       (update :age inc)) ; 위의 식을 평가한 결과가 update 뒤의 첫번째 인자로 삽입된다\n   ```\n\n   1번째 줄의 코드와 4~6번째 줄의 코드는 같은 동작을 합니다. `->` 쓰레딩 매크로를 사용하면 이전 식을 평가한 결괏값이 첫 번째 인자로 사용되기 때문이죠. 이전 식의 평가치를 마지막 인자로 사용하는 `->>` 쓰레딩 매크로도 있습니다. 쓰레딩 매크로를 사용하면 순서가 드러나기 때문에 가독성이 더 높아집니다.\n\n3. 함수 잘 나누기\n\n   ```clojure\n   ;; 줄줄 풀어서 문제를 푼 예\n   (->> input\n        (reduce (fn []\n          ; 문자열 파싱하기\n        )\n        (filter (fn []\n          ; 값이 유효한지 검사하기\n        )\n        count)\n\n   ;; 함수를 잘 나눈 예\n   (->> (parse input)\n        (filter valid?)\n        count)\n   ```\n\n   함수를 잘 나눠 추상화 수준을 높이면 어떤 로직을 처리하고자 하는지 쉽게 파악할 수 있습니다. 함수를 잘 나눈 예를 보면, 'input을 파싱하고 유효한 값을 count 하려는' 의도를 쉽게 읽을 수 있습니다.\n\n4. 문제 많이 풀기\n\n   처음부터 문제 하나를 완벽하게 풀려고 드는 것보다, 일단 단순 무식한 해법으로라도 문제를 많이 풀어보는 접근법이 더 좋았습니다. 어차피 배우면서 고쳐야 하기 때문이죠!\n\n### 끝나지 않는 리팩토링\n\n위에서 풀었던 문제를 `loop/recur` 대신 `reduce`로 리팩토링해 보기로 했습니다. `reduce`는 시퀀스를 하나의 값으로 축약하는 함수입니다. `reduce`는 출력을 예상할 수 있어, 그렇지 못한 `loop/recur`보다 간단한 코드를 만들 수 있습니다. 답을 찾으면 바로 반환하는 `loop/recur`에 비해 모든 값을 확인해야 하는 `reduce`가 더 비효율적이라고 생각했지만, 클로저의 `reduce`에는 중간에 탈출할 수 있는 `reduced`가 있어 그런 비효율도 피할 수 있습니다.\n\n```clojure\n(reduce\n  (fn [{:keys [sum seen?]} x]\n    (let [sum (+ sum x)]\n      (if (seen? sum) ; 두 번 나오는 숫자가 있을 경우\n        (reduced sum) ; 답\n        {:sum sum :seen? (conj seen? sum)})))\n  {:sum 0 :seen? #{}} (cycle input))\n```\n\n각 반복 단계마다 `sum`을 구하여 `seen?`에 추가해두고, 다음 단계에서 이전에 본 `sum`들을 `seen?`에서 확인하는 방식으로 문제를 풀 수 있었습니다. `if` 의 조건식인 `(seen? sum)` 은 `seen?` 집합에 `sum`이 있으면 그 값을 반환하므로 참으로 평가됩니다. (클로저에서는 `false`, `nil`을 제외한 모든 값이 참으로 평가(truthy)됩니다.)\n\n### 지연 시퀀스\n\n며칠 후엔 클로저의 지연 평가라는 개념을 배우게 되었습니다. 지연 평가는 실제로 필요해지는 순간까지 평가를 미루는 방법인데요. 이로 인해 클로저에서는 무한한 시퀀스를 다룰 수 있다고 합니다. `range` 함수로 무한 시퀀스를 쉽게 만들 수 있습니다.\n\n```clojure\n(range 5) ; => (0 1 2 3 4)\n(range 5 10) ; => (5 6 7 8 9)\n(range) ; => (0 1 2 3 4 5 6 7 8 9 10 ...)\n(take 10 (range)) ; => ?\n```\n\n`range`함수는 인자 없이 사용하면 위 예시의 3번째 줄처럼 무한한 시퀀스를 생성합니다. 3번째 줄을 실제로 평가하면 오류가 발생합니다.\n\n![Crash](./crash.png)\n4번째 줄을 평가하면 어떤 일이 일어날까요? `take` 함수는 시퀀스 앞에서 n개의 요소를 가져오는 함수입니다. 오류가 날 것으로 생각할 수도 있지만, 오류 없이 `(0 1 2 3 4 5 6 7 8 9)`가 반환됩니다. 무한 시퀀스를 생성한 후 10개의 값을 가져오는 게 아니라, 실제로 필요한 10개의 요소만을 생성하는 것이죠. 지연 시퀀스의 힘이 느껴지시나요?\n\n지연 시퀀스를 사용해서 다시 문제를 풀어봅시다.\n\n```clojure\n(defn first-duplicate\n  [input]\n  (reduce (fn [seen? x]\n            (if (seen? x) ; 두 번 나오는 숫자가 있을 경우\n              (reduced x) ; 답\n              (conj seen? x)))\n          #{} input))\n\n(->> (cycle input) ; (1)\n     (reductions +) ; (2)\n     first-duplicate) ; (3)\n```\n\n`reduce`를 사용하여 시퀀스의 처음 중복되는 숫자를 찾는 함수 `first-duplicate`를 작성했습니다.\n\n(1) 입력을 무한히 반복해서 넣습니다.  \n(2) 더하기(+)를 적용한 시퀀스를 생성합니다. `reductions`는 입력에 함수(여기서는 +)를 적용한 지연 시퀀스를 생성하는 코어 함수입니다.  \n(3) 첫 번째 반복되는 숫자를 찾습니다.\n\n저는 리팩토링을 통해 무엇을 얻었을까요? `reduce`를 사용한 풀이에서는 현재 값을 더하고 중복 여부를 확인하는 일을 한 함수 안에서 모두 했습니다. 개선된 풀이에서는 함수들을 작은 역할로 분리하여 가독성과 재사용성을 높일 수 있었습니다. `first-duplicate` 함수는 어떤 컬렉션에 대해서도 사용할 수 있어 재사용성이 높습니다. 또한 `reductions`와 같은 코어 함수를 잘 활용해서 코드가 간결해졌습니다.\n\n어떤 언어든지 잘 활용하기 위해서는 언어가 제공하는 라이브러리에 익숙해야 할 것입니다. 특히나 클로저에는 강력한 코어 함수가 많아서 이들을 잘 활용하면 코드 품질이 극적으로 향상되는 것 같습니다. 이 글에서 소개한 문제 외에도 여러 문제를 풀면서 `juxt`, `frequencies` 등 유용한 코어 함수들을 접할 수 있었습니다. 코드 리뷰를 받다 보면, '이럴 때 이 함수!' 하면서 다들 보따리에서 하나씩 꺼내 주시기도 합니다. 특히 문제를 풀려는 방식과 의도를 잘 전달했을 때 그런 유용한 피드백을 더 많이 받을 수 있었던 것 같습니다.\n\n## 3주차\n\n3주차에는 클로저 관련 도구에 익숙해지기 위해 <u>클로저로 작성한 AWS Lambda 배포해보기</u>와 <u>클로저 웹서버 띄워보기</u>를 실습했습니다.\n\n### 클로저로 작성한 AWS Lambda 배포해보기\n\nAWS Lambda가 지원하는 런타임의 목록에는 클로저가 명시되어 있지 않습니다. 하지만 JVM 기반 언어를 지원하기 때문에 클로저를 사용할 수 있습니다. 동료들이 작성해 둔 매뉴얼을 보며 Lambda 함수를 몇 가지 만들어보는 실습을 했습니다. 이 과정은 다른 언어와 비슷합니다. 소스 코드와 dependency를 묶은 패키지를 생성하고 AWS에 올리는 방식입니다.\n\n### 클로저 웹서버 띄워보기\n\n그린랩스에는 농사에 관한 정보를 한눈에 볼 수 있는 '팜모닝'이라는 서비스가 있습니다. 이 서비스의 백엔드는 클로저로 개발되어 있어요. 클로저 웹 프로젝트에 친숙해지기 위해, 그리고 앞으로 실제 개발에 사용하기 위해 로컬에서 웹서버를 띄워보는 실습을 했습니다.\n\n![farmmorning](./farmmorning.png)\n\n팜모닝 서비스 개발자분들의 도움을 받아 IDE를 설정하고 구조를 살펴봤습니다. 이 프로젝트는 [ring](https://github.com/ring-clojure/ring), [reitit](https://github.com/metosin/reitit), [honeysql](https://github.com/seancorfield/honeysql), [lacinia](https://github.com/walmartlabs/lacinia), [hikari-cp](https://github.com/tomekw/hikari-cp) 등의 오픈 소스로 구성되어 있는데요. 하나하나 역할을 이해하고 코드를 눈에 익히다 보니 일주일이 금방 지나갔습니다.\n\n곧 클로저 웹서버 구성 튜토리얼도 블로그를 통해 공개될 예정이라고 하니 기대해주세요!\n\n## 🎓 졸업\n\n<div style={{ width: 50 + '%', maxWidth: 354 + 'px', margin: '0 auto' }}>\n  <img src={img} />\n</div>\n\n이름이 부트캠프라 처음엔 겁나기도 했지만 되돌아보니 사실 신규입사자에 대한 그린랩스 개발팀의 열렬한 환영이었던 것 같습니다.\n\n귀여운 졸업장도 받고 부트캠프도 끝났지만, 저의 클로저 프로그래밍은 이제 시작입니다. 실무에 투입된 지 한 달 정도 되었는데, 실무에서 쓰이는 클로저는 AoC 문제처럼 복잡하고 어렵진 않지만 고민해야 할 부분이 더 많습니다. 실제 세상에는 예외가 많아서 코드가 지저분해지기 쉽기도 하고요. 그런 와중에도 아름다운 코드를 놓치지 않는 멋진 개발자가 되어야 합니다.\n\n부트캠프는 클로저뿐 아니라 동료들과도 가까워질 수 있는 시간이었습니다. 처음 프로젝트 설정에 도움을 주셨던 분들, 코드를 리뷰해주시는 분들, 같이 밥을 먹으며 문제에 대한 생각을 나누었던 분들, 부트캠프를 응원해주시는 분들, 같이 리뷰를 받으며 더 좋은 코드를 쓰기 위해 고민했던 분들 모두 감사드립니다.\n\n덕분에 부트캠프 과정을 재미있고 뜻깊게 보냈습니다. 앞으로 그린랩스에서의 여정도 즐거울 것이라는 기대가 됩니다.\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"jungin.kwon1@gmail.com\"\n  name=\"권정인\"\n  description=\"백엔드 개발자\"\n  date=\"2021-09-13\"\n/>\n","id":"537a368e-3237-58a2-8691-44450d566d52"},"userFilterAllMdx":{"nodes":[]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"},"id":"f154cb27-cd10-58b6-8b1e-d58973d0f411"},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"},"id":"5eacd25c-be7f-5bbb-b53e-8bbb8bc8bcfd"},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"},"id":"f13162a1-9c05-5a1e-bf85-655b5aace0ae"},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"},"id":"adc71c37-e00e-58e7-83dc-df70f5e6331a"},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"},"id":"9ce74193-f3f1-5daf-ac68-4d9b62712ba5"},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"},"id":"cdd0571d-71f3-509e-ad9c-e294c7567d55"},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"},"id":"503f1b09-b133-5f63-8898-ac5eba7cc0d6"},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"},"id":"b6744efa-9cd1-5ad8-9b12-0a38954ffb4b"},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"},"id":"68a29bba-1b97-586d-a0de-cb6d67c0927f"},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"},"id":"b738b947-e79e-551b-8534-787ebf6e2d9f"},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"},"id":"4a637fde-9c6e-5ace-a010-822ca614e883"},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"},"id":"7b8b38cf-4f0b-5c9d-9bc8-da7dc5b7af6c"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"},"id":"4aa716bb-c5ff-57ae-967e-ee9d2faa9456"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"},"id":"ee2a79b0-460b-57ad-ad6d-afb831aa3d05"},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"},"id":"ff29574f-ad14-52ca-9aa2-63deb07b8ebc"},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"},"id":"1242c8cd-8847-51c9-84b3-00e8ac025cc0"},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"},"id":"fcd89036-f4c3-53c8-b8b8-cf204e6e2218"},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"},"id":"d2b3e0d3-2d3c-5ddd-9190-a649bd9232d8"},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"},"id":"50b95dc8-1681-5633-a035-cabafbe1fb0a"},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"},"id":"c1f6f719-a083-5eb8-94ec-1f94632ba106"}]},"allMdx":{"edges":[{"node":{"id":"23649293-d0ae-5878-809e-e459f2a33862","frontmatter":{"date":"2022-11-28T00:00:00.000Z"}}},{"node":{"id":"a35f56fb-dec5-51dc-8f87-ce415db90df4","frontmatter":{"date":"2022-11-11T00:00:00.000Z"}}},{"node":{"id":"f154cb27-cd10-58b6-8b1e-d58973d0f411","frontmatter":{"date":"2022-10-30T00:00:00.000Z"}}},{"node":{"id":"5eacd25c-be7f-5bbb-b53e-8bbb8bc8bcfd","frontmatter":{"date":"2022-10-26T00:00:00.000Z"}}},{"node":{"id":"f3366c54-e983-5cc1-9ac0-b099ad824dd8","frontmatter":{"date":"2022-10-14T00:00:00.000Z"}}},{"node":{"id":"f13162a1-9c05-5a1e-bf85-655b5aace0ae","frontmatter":{"date":"2022-08-25T00:00:00.000Z"}}},{"node":{"id":"6824dc6c-daa7-5e2b-8b25-283f61471036","frontmatter":{"date":"2022-08-16T00:00:00.000Z"}}},{"node":{"id":"adc71c37-e00e-58e7-83dc-df70f5e6331a","frontmatter":{"date":"2022-07-27T00:00:00.000Z"}}},{"node":{"id":"9ce74193-f3f1-5daf-ac68-4d9b62712ba5","frontmatter":{"date":"2022-07-21T00:00:00.000Z"}}},{"node":{"id":"0cd79f66-41cd-5f02-ac23-99a6b4cfcb3e","frontmatter":{"date":"2022-07-05T00:00:00.000Z"}}},{"node":{"id":"7691ceb5-c5de-5d80-b603-20dc8d12c0c9","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"cdd0571d-71f3-509e-ad9c-e294c7567d55","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"89bcab3e-450c-57df-88a2-6dfedc86db73","frontmatter":{"date":"2022-04-06T00:00:00.000Z"}}},{"node":{"id":"503f1b09-b133-5f63-8898-ac5eba7cc0d6","frontmatter":{"date":"2022-01-11T00:00:00.000Z"}}},{"node":{"id":"aa5a422f-8945-52b8-8969-9531f433c561","frontmatter":{"date":"2021-12-29T00:00:00.000Z"}}},{"node":{"id":"b6744efa-9cd1-5ad8-9b12-0a38954ffb4b","frontmatter":{"date":"2021-11-22T00:00:00.000Z"}}},{"node":{"id":"68a29bba-1b97-586d-a0de-cb6d67c0927f","frontmatter":{"date":"2021-10-29T00:00:00.000Z"}}},{"node":{"id":"b738b947-e79e-551b-8534-787ebf6e2d9f","frontmatter":{"date":"2021-09-24T00:00:00.000Z"}}},{"node":{"id":"4a637fde-9c6e-5ace-a010-822ca614e883","frontmatter":{"date":"2021-09-17T00:00:00.000Z"}}},{"node":{"id":"537a368e-3237-58a2-8691-44450d566d52","frontmatter":{"date":"2021-09-13T00:00:00.000Z"}}},{"node":{"id":"7b8b38cf-4f0b-5c9d-9bc8-da7dc5b7af6c","frontmatter":{"date":"2021-08-31T00:00:00.000Z"}}},{"node":{"id":"4aa716bb-c5ff-57ae-967e-ee9d2faa9456","frontmatter":{"date":"2021-06-01T00:00:00.000Z"}}},{"node":{"id":"ee2a79b0-460b-57ad-ad6d-afb831aa3d05","frontmatter":{"date":"2021-05-30T00:00:00.000Z"}}},{"node":{"id":"ff29574f-ad14-52ca-9aa2-63deb07b8ebc","frontmatter":{"date":"2021-04-27T00:00:00.000Z"}}},{"node":{"id":"1242c8cd-8847-51c9-84b3-00e8ac025cc0","frontmatter":{"date":"2021-01-29T00:00:00.000Z"}}},{"node":{"id":"fcd89036-f4c3-53c8-b8b8-cf204e6e2218","frontmatter":{"date":"2020-12-21T00:00:00.000Z"}}},{"node":{"id":"d2b3e0d3-2d3c-5ddd-9190-a649bd9232d8","frontmatter":{"date":"2020-12-15T00:00:00.000Z"}}},{"node":{"id":"50b95dc8-1681-5633-a035-cabafbe1fb0a","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}},{"node":{"id":"c1f6f719-a083-5eb8-94ec-1f94632ba106","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}}]}},"pageContext":{"slug":"/clojure-bootcamp","title":"그린랩스에서 클로저 시작하기","category":"engineering","email":"jungin.kwon1@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","author":"권정인","email":"jungin.kwon1@gmail.com","slug":"/clojure-bootcamp","tags":["Clojure"],"category":"engineering"}}},"staticQueryHashes":["318001574"]}