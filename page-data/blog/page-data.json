{"componentChunkName":"component---src-templates-blog-query-tsx","path":"/blog","result":{"data":{"allPost":{"nodes":[{"slug":"/rescript-compiler-jsx-ppx","title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022년 10월 30일","body":"\n> 수정사항 (2022-11-17) <br /> > [JSX의 외연 확대](https://green-labs.github.io/rescript-compiler-jsx-ppx#:~:text=%EA%B0%80%20%EC%9E%88%EB%8A%94%20%EA%B2%BD%EC%9A%B0-,JSX%EC%9D%98%20%EC%99%B8%EC%97%B0%20%ED%99%95%EB%8C%80,-v3%EB%8A%94%20React)의 예로 들었던 `Remix` 대신 `Preact` 로 변경\n\n<br />\n\n리스크립트 컴파일러에 내장된 JSX v4를 개발하게 된 계기와 여정을 소개합니다. 그리고 v3 대비 어떤 점들이 개선되었는지도 소개합니다.\n\n### JSX v3 개선의 움직임 ~~(당시 나는 전혀 몰랐던)~~\n\n코어팀은 기존의 JSX v3의 개선해야할 부분에 대해 정의하고 v4 개발 계획을 수립했던 것 같습니다. 당시 저는 몰랐지만요.\n\n> https://github.com/rescript-lang/syntax/pull/235\n\n- 컴파일러와의 인터페이스를 정리하자\n- 에러를 일으킬 때, 원본 코드의 위치를 더 잘 표시하자\n- 레거시 ReasonReact를 정리하자\n- 테스트를 더 추가하자\n- 돔 요소의 어트리뷰트를 더 추가하자 (예, `aria-*`)\n\n현재 개발된 v4의 모습에 비하면 당시 계획은 v3 대비 크게 달라지는 모습을 그리지는 않았던 것 같습니다. 특히 오브젝트로 표현되는 리액트 컴포넌트 props를 레코드로 바꿔야겠다는 생각은 없었던 것 같습니다.\n\n### JSX v4 개발에 걸려듬(?)\n\n컴파일러 내부를 들여다보고 코드를 읽다보니, 이렇게 해서는 제대로 이해할 수 없겠다는 생각이 들었습니다. 직접 코드를 수정하고 만들어봐야 익힐 수 있겠다는 마음을 먹고 무엇을 만들까 고민했습니다. 그래서 머리속에 떠올랐던 기능이 Spread props였습니다. 자바스크립트나 타입스크립트에서는 자주 쓰는 표현인데, 리스크립트에서는 지원되지 않았습니다.\n\n`{...p}` Spread props 표현을 파싱하고, `p`라는 이름의 레코드를 모듈에서 찾아 각 필드의 값을 prop으로 전달하는 기능을 파서와 JSX PPX에 구현한 PR을 하였습니다.\n\n> https://github.com/rescript-lang/syntax/pull/517\n\nPR에 대해 메인테이너는 몇 가지 한계점을 지적하였습니다.\n\n- 같은 이름의 레코드를 찾아서 필드들을 prop으로 전달하는 방식: alias 된 이름은 찾을 수가 없다.\n\n  ```rescript\n  // A.res\n  type p = {a: int, b: int}\n  let p = {a: 1, b: 2}\n\n  // B.res\n  let q = A.p\n\n  <Comp {...q} />\n  // q는 찾을 수 있지만, 바인딩된 A.p는 문자 정보일 뿐 레코드라는 타입 정보는 없음.\n  ```\n\n- 다른 모듈의 레코드는 참조할 수가 없다.\n\nPPX는 파서가 파싱 결과로 만든 Parsetree를 조작하는 프로그램이기 때문에, 컴파일러가 타입 정보를 추가해준 Typedtree는 PPX가 모르기 때문입니다. PPX가 가진 정보라고는 `q`는 타입 선언이고, `A.p`라는 문자와 바인딩되어 있구나 정도밖에 없습니다. 만약 `A.p`라는 레코드 타입이 다른 모듈에 선언되어있다면, 더더욱 알 길이 없죠. 그 한계를 알고는 있었습니다. 하지만 어떻게 해결할 수 있을 지는 몰랐습니다.\n\n내가 구현하고자 하는 기능이 컴파일러 안에서 작동하게 만들었다는 점에 '그래, 난 성장했어!'라고 만족했거든요.\n\n그런데 메인테이너가 예고없이 v3 개선 논의들과 v4의 청사진을 만들어서 공유해주기 시작합니다. (당황, 나한테 왜 그러는거지..) 그리고 이 한계를 개선할 수 있는 방법은 언어 자체를 활용해야한다는 걸 알려주었습니다. (그게 무슨 말이야..)\n\n### JSX v3의 문제점과 개선 방향\n\nv3를 개선해보자 했던 초기 계획보다 훨씬 큰 계획을 메인테이너가 공유해주었습니다. 저는 '음...이게 다 무슨 말이야?'라고 생각을 했습니다.\n\n> https://github.com/rescript-lang/syntax/issues/521\n\n- `@react.component` 어트리뷰트 없이 함수만으로 리액트 컴포넌트를 표현할 수 있도록 하자.\n- 내부 표현에서 `makeProps` 같은 요술을 제거하자.\n- `makeProps`에서 사용하는 `@obj` 대신 레코드의 표현력을 개선해보자.\n- React v17에 소개된 새로운 JSX transform API를 도입하자.\n- v3와의 하위호환: 가능한 점진적 마이그레이션이 가능한 방법을 찾자.\n\n그리고 제가 이해할 수 있는 팁도 줍니다. `\"레코드를 업데이트하는 문법이 있으니 레코드를 이용하면 Spread props을 구현할 수 있을거야.\"`\n\n```rescript\nlet q = {...p, a: 1} // 오!!\n```\n\n> https://github.com/rescript-lang/syntax/pull/517<br />https://github.com/rescript-lang/syntax/pull/547\n\n첫번째 PR에서는 총 246개의 댓글을 통해 구현에 대해 논의하였고, PR의 제목도 JSX v4 WIP로 변경하였습니다. 본격적인 개발을 위해 새로운 PR을 만들고 메인테이너와 논의하면서 개발을 이어갔습니다.\n\n본격적인 v4 개발이 시작되었습니다.\n\n### JSX v4 개발\n\n#### `makeProps`는 왜 필요한 것일까?\n\n`@obj external makeProps: ...`은 리액트 컴포넌트 props에 해당하는 오브젝트를 생성하고 각 prop의 타입을 체크해주는 역할을 합니다. 오브젝트 대신 레코드를 사용하려면 `makeProps`없이 props를 표현할 수 있어야 합니다.\n\n컴파일러는 리액트 컴포넌트를 정의(Definition)한 원본 코드를 이렇게 변환합니다.\n\n```rescript\n// 원본 코드\nmodule C = {\n  @react.component\n  let make = (~x, ~y) => React.string(x ++ y)\n}\n\n// v3로 변환한 결과\nmodule C = {\n  @obj\n  external makeProps: (\n    ~x: 'x,\n    ~y: 'y,\n    ~key: string=?, // key 타입 체크를 위한 인자 추가\n    unit,\n  ) => {\"x\": 'x, \"y\": 'y} = \"\" // 생성된 오브젝트\n\n  @react.component let make = (~x, ~y) => React.string(x ++ y)\n  let make = {\n    let \\\"C\" = (\\\"Props\": {\"x\": 'x, \"y\": 'y}) =>\n      make(~y=\\\"Props\"[\"y\"], ~x=\\\"Props\"[\"x\"])\n    \\\"C\"\n  }\n}\n\n```\n\n리액트 컴포넌트를 사용(application)하는 곳에서 `makeProps` 함수를 호출해서 `x`와 `y`의 타입을 체크하고, `{\"x\": \"x\", \"y\": \"y\"}` 오브젝트를 생성합니다.\n\n```rescript\n// 원본 코드\n<C x=\"x\" y=\"y\" />\n\n// v3가 변환한 결과\nReact.createElement(C.make, C.makeProps(~x=\"x\", ~y=\"y\", ()))\n    // 타입 체크 & 오브젝트 생성 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\n애초에 props 타입을 레코드 대신 `makeProps`가 생성하는 오브젝트로 대신하는 이유가 있습니다. 왜냐하면, 리액트 컴포넌트의 prop들은 일부만 사용할 수 있기 때문에, 레코드로 표현하면 필드의 타입이 option 타입을 사용해야하기 때문입니다. option 타입을 사용하면 `<C z=Some(\"z\")>`라고 표현할 수 밖에 없으니까요. 그래서 v3는 레코드 대신 `makeProps` 함수가 생성하는 오브젝트를 사용하여 구현할 수 밖에 없었을 것입니다.\n\n<br />\n\n#### 오브젝트 대신 레코드\n\n`makeProps` 함수를 대신하려면 레코드는 표현력이 더 좋아져야만 했습니다.\n\n컴포넌트의 props을 레코드로 표현했을 때, 각 필드는 하나의 prop 입니다. `x`와 `y`는 필수 prop이고, `z`는 선택 prop입니다.\n\n```rescript\ntype props = {\n  x: string,\n  y: string,\n  z: option<string>,\n}\n```\n\n1. props를 사용하지 않은 경우: `let props = {}`\n2. props 중 일부만 사용하는 경우: `let props = {x: \"x\", y: \"y\"}`\n3. props 전부를 사용하는 경우: `let props = {x: \"x\", y: \"y\", z: Some(\"z\")}`\n4. 선택 필드 z를 Some 없이 사용하는 경우: `let props = {x: \"x\", y: \"y\", z: \"z\"}`\n\n이 중 컴파일러 v9에서 레코드로 가능한 표현은 3번 뿐 입니다. 하지만 4번의 경우 리액트 컴포넌트를 표현할 때 꼭 필요합니다.\n\n```rescript\n// 선택 prop에 Some?? 이건 좀 별론데..\n<Profile name=\"정식\" nickname=Some(\"리스크립트 고수\")>\n```\n\n표현력의 한계를 해결하기 위한 방법이 필요했고, 이미 레코드의 구조를 타입 체크할 수 있는 [RFC](https://forum.rescript-lang.org/t/rfc-more-general-type-checking-for-structural-typings/1485)가 있었습니다. 이 RFC는 레코드의 필드 중 일부만 작성해도 안전하게 타입 체크를 해주는 기능입니다. 2번의 경우죠.\n\nJSX v4를 위해 이 RFC를 개선해나갑니다. 1번과 4번을 해결해야 했습니다. 특히 4번 표현은 리액트 컴포넌트를 표현할 때 꼭 필요했기 때문에 RFC를 바탕으로 메인테이너와 기능 설계를 해서 이런 문법을 추가 합니다.\n\n> https://github.com/rescript-lang/rescript-compiler/pull/5423\n\n개선의 결과로 레코드는 1 ~ 4번 모두에 해당하는 표현력을 갖게 됩니다.\n\n```rescript\ntype t = {\n  name: string,\n  nickname?: string, // ?를 붙이면 선택 필드\n}\n\nlet woonki = {name: \"운기\"}\nlet jeongsik = {\n  name: \"정식\",\n  nickname: \"리스크립트 고수\" // Some(\"...\") 하지 않아도 됩니다.\n}\n```\n\n`@optional` 대신 `?` 표현이 추가되고, 옵션 생성자를 사용하지 않고 표현할 수 있도록 개선되어 갑니다.\n그래서 리액트 컴포넌트를 이렇게 표현할 수 있게 됐습니다.\n\n```rescript\n<C name=\"운기\" />\n<C name=\"정식\" nickname=\"리스크립트 고수\" />\n```\n\n명목적 타입(Nominal type)을 사용하고 안전한(Sound) 타입 시스템에서 레코드가 이런 표현력을 갖게 되는 것은 놀라운 일입니다.\n\n<br />\n\n#### React의 새로운 jsx runtime API 도입\n\n리액트 17버젼에서 소개된 [API](https://ko.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) 입니다. 앞서 보여드렸던 내부 표현을 보면서 짐작하셨겠지만, 리스크립트는 JSX를 변환하기 위해 Babel이 필요하지 않습니다. 컴파일러가 변환하기 때문이죠. 그래서 새로운 jsx runtime API를 사용하려면 JSX v4에 구현을 해야했습니다.\n\n`rescript-react` 바인딩 모듈에 PR을 하고, 추가한 API를 v4가 호출했습니다.\n\n> https://github.com/rescript-lang/rescript-react/pull/49<br />https://github.com/rescript-lang/syntax/pull/614\n\n```rescript\n// 원본 코드\n<C x=\"x\" y=\"y\" />\n<C key=\"c\" x=\"x\" y=\"y\" />\n\n// 내부 표현\nReact.jsx(C.make, {x: \"x\", y: \"y\"})\nReact.jsxKeyed(C.make, {x: \"x\", y: \"y\"}, \"c\") // key가 있는 경우\n```\n\n<br />\n\n#### JSX의 외연 확대\n\nv3는 React ppx의 역할이었습니다. `rescript-react`에 바인딩된 리액트 API를 호출해서 내부 표현을 만듭니다. v4 작업 중 코어팀과 논의하는 과정에서 JSX는 리액트만의 표현이 아니기 때문에, Solid.js, ~~Remix~~Preact 와 같은 라이브러리나 프레임워크에도 대응할 수 있게 하자는 의견이 나왔습니다.\n\n그래서 컴파일러 내부에 `Jsx`, `JsxDOM` 등의 모듈을 추가하고, `Jsx.element`, `Jsx.component` 등의 타입을 `rescript-react`에 정의된 타입에 바인딩 하였습니다. 앞으로 `rescript-solid`, ~~`rescript-remix`~~`rescript-preact` 바인딩이 나온다면, `Jsx` 모듈을 바인딩할 수 있습니다. 그럼, JSX 표현을 공유할 수 있게 됩니다. 예를 들어, 리액트 프로젝트에서 만든 모듈을 Solid.js 프로젝트에서 사용할 수 있습니다.\n\n```rescript\n// React.res\ntype element = Jsx.element // Jsx.element는 컴파일러 내부에 정의된 타입입니다.\n```\n\n> https://github.com/rescript-lang/rescript-compiler/pull/5484<br />https://github.com/rescript-lang/rescript-react/pull/49\n\n<br />\n\n#### 점진적 마이그레이션: v3와의 하위 호환\n\nJSX v4의 구현보다 더 어려운 작업이었습니다. 왜냐하면 작업해야하는 레포지토리가 3개 입니다. 컴파일러, syntax, rescript-react에 걸쳐 의존성이 있는 작업이었습니다.\n\n우선, `bsconfig.json`에 v3와 v4를 설정할 수 있는 설정값을 추가하고, 컴파일러에서 그 설정값을 읽고 JSX ppx를 작동시키는 로직을 추가했습니다. 설정에 따라 v3 혹은 v4를 활성화 시킵니다. 기존의 `\"reason\".\"react-jsx\"`와 같은 속성은 제거하고, 새로운 `\"jsx\"` 속성을 추가했습니다.\n\n또, v3와 v4는 서로 다른 내부 표현을 생성하기 때문에, `rescript-react`의 리액트 바인딩도 `ReactV3` 모듈을 추가해서 v3를 계속 사용하는 프로젝트에서 사용이 가능하도록 하였습니다. 최신 버젼의 컴파일러와 `rescript-react`를 설치한 프로젝트에서 v3와 v4를 모두 사용할 수 있습니다.\n\n> https://github.com/rescript-lang/rescript-compiler/pull/5484\n\n<br />\n\n`bsconfig.json` 설정\n\n- V3\n\n```json\n{\n  \"jsx\": {\n    \"version\": 3,\n    \"v3-dependencies\": [\n      \"rescript-relay\" // v3를 사용할 의존 모듈을 추가해줍니다.\n    ]\n  },\n  \"bsc-flags\": [\"-open ReactV3\"]\n}\n```\n\n- V4\n\n```json\n{\n  \"jsx\": {\n    \"version\": 4,\n    \"mode\": \"classic\", // \"automatic\" 는 jsx runtime API 사용\n    \"module\": \"react\" // 생략 가능. 향후 \"solidjs\", \"preact\" 등 가능할지도..\n  }\n}\n```\n\n이 무렵 컴파일러, syntax에 걸쳐있는 작업들을 효율적으로 하기 위해 리스크립트 GitHub 조직에 초대를 받았습니다. ✌️\n\n![](rescript-github-org-member.png)\n\n### JSX v4의 개선점\n\n새로운 JSX v4는 v3와 비교했을 때 어떤 점이 개선되고 어떤 장점이 있는 지 살펴보겠습니다.\n\n> 스펙 문서<br />https://github.com/rescript-lang/syntax/blob/master/cli/JSXV4.md\n\n<br />\n\n#### `@react.component` 없이 표현할 수 있습니다\n\n<br />\n\n```rescript\nmodule C = {\n  type props = {x: string, y: string}\n  let make = {x, y} => React.string(x ++ y)\n}\n```\n\n타입스크립트 코드와 비슷하게 표현하지만, 강력한 타입 시스템이 타입을 추론해주고 체크해줍니다. v3 대비 표현력이 좋아지고, 코드가 간결해졌습니다.\n\n특히 `Context` API를 사용할 때, `@react.component`를 사용하지 않고 표현하면 훨씬 간결해집니다.\n\n```rescript\n// v3\nmodule Context = {\n  let context = React.createContext(() => ())\n\n  module Provider = {\n    let provider = React.Context.provider(context)\n\n    @react.component\n    let make = (~value, ~children) => {\n      React.createElement(provider,\n        {\"value\": value, \"children\": children} // Error\n      )\n    }\n  }\n}\n\n// v4\nmodule Context = {\n  let context = React.createContext(() => ())\n\n  module Provider = {\n    let make = React.Context.provider(context)\n  }\n}\n```\n\n다만, `@react.component`가 하는 일 중 하나가 함수의 이름을 대문자로 만들어주는 것인데요. 리스크립트에서 대문자 이름은 모듈이나 배리언트 생성자에게 허용되어 있고, `let` 바인딩 값에는 허용되지 않기 때문입니다. 리액트 컴포넌트 이름은 대문자로 시작하지 않으면 React Fast Refresh가 작동하지 않는다는 이슈가 보고되어서, 이 부분은 메인테이너와 함께 더 살펴볼 예정 입니다. 그래서 React Fast Refresh 이슈가 있는 경우에는 `@react.component`를 사용하시는 편이 좋을 것 같습니다.\n\n<br />\n\n#### Spread props을 사용할 수 있습니다.\n\n특히, DOM 요소의 어트리뷰트에 해당하는 props를 전달할 때 유용하게 사용할 수 있을 것 같습니다.\n\n<br />\n\n```rescript\n// 사용자 정의 컴포넌트\n<Comp {...props} x=\"x\" />\n\n// DOM 요소 컴포넌트\nlet props: Jsx.domProps = {id: \"id\", name: \"그린랩스\"}\n<div {...props} />\n```\n\n<br />\n\n#### 새로운 jsx runtime API를 활용할 수 있습니다.\n\n리액트를 import 하지 않아도 리액트 컴포넌트를 생성할 수 있는 API를 활용해서 번들 사이즈를 조금 더 줄일 수 있습니다. 리액트 팀 감사합니다. 😉\n\n<br />\n\n#### 컴포넌트들 간 props 타입을 공유할 수 있습니다.\n\n<br />\n\n```rescript\ntype sharedProps = {\n  x: string,\n  y: string,\n}\n\nmodule A = {\n  @react.component(:sharedProps)\n  let make = (~x, ~y) => React.string(x ++ y)\n}\n\nmodule B = {\n  @react.component(:sharedProps)\n  let make = (~x, ~y) => React.string(x ++ y)\n}\n```\n\n리스크립트는 명목적 타입(Nominal type)을 사용하고 있습니다. A 모듈의 `props`와 B 모듈의 `props`는 다른 타입이죠. 예를 들어, React Native Navigation의 Screen 컴포넌트에 `component` prop에 A, B 컴포넌트를 전달하는 경우 타입 에러가 발생합니다.\n\n```rescript\ntype screenProps = { navigation: navigation, route: route }\n\nmodule Screen: {\n  @react.component\n  let make: (\n    ~name: string,\n    ~component: React.component<screenProps>,\n    ...\n  ) => React.element\n}\n\n// 타입 에러\n// component: React.component<screenProps>\n// A.make: React.component<A.props>\n<Screen name=\"A\" component={A.make} />\n<Screen name=\"B\" component={B.make} />\n```\n\n이런 경우 shared props 기능을 사용할 수 있습니다.\n\n```rescript\nmodule A = {\n  @react.component(:screenProps)\n  let make = (\n    ~navigation: navigation,\n    ~route: route\n  ) => ...\n}\n\nmodule B = {\n  @react.component(:screenProps)\n  let make = (\n    ~navigation: navigation,\n    ~route: route\n  ) => ...\n}\n```\n\n<br />\n\n### 기여를 하며 배운 점\n\n돌이켜보면 어쩌다 여기까지 오게 됐는지 잘 알 수 없지만, 필요한 건 직접 PR을 만들어서 제안해보면 좋겠다는 시도에서 시작된 것 같습니다. 그 시작은 보잘 것 없어서 머지가 되지 못할 Spread props 문법의 구현이었지만, 운좋게도 코어팀의 필요와 맞물려서 컨트리뷰터가 될 수 있었습니다.\n\n컴파일러 8개, syntax 22개, rescript-react 9개, 총 39개의 PR을 만들면서 배운점과 느낀점을 정리해보았습니다.\n\n![](jsx-ppx-v4-congrats.jpg)\n\n> 1차 마무리 후 메인테이너의 감사 코멘트. ~~덕분에 제가 많이 배웠습니다, 근데 이제 시작이었다..~~\n\n<br />\n\n#### RFC -> 기술 스펙 -> 구현 -> 테스트, TDD\n\n오픈 소스에 기여한 적이 처음은 아니지만, 긴 기간(약 4개월) 동안 꾸준히 개발하고 같이 협업을 한 적은 처음이었습니다. RFC를 만들어서 공개하고, 커뮤니티에 의견을 묻고, 코어팀 뿐만 아니라 커뮤니티 개발자들과 함께 기능과 구현을 논의하는 과정을 경험해볼 수 있었습니다. 기술 스펙 문서를 작성하고, 구현하고, 테스트 후 알파, RC 버젼을 배포해서 다시 테스트하고 테스트를 커뮤니티에 요청하는 하나의 개발 싸이클 속에 있어 본 좋은 기회였습니다.\n\n그리고 TDD라고 거창하게 말할 수준은 아니지만, 구현하거나 수정해야할 테스트 샘플을 추가한 뒤 원본 코드가 파싱된 AST(Parsetree), Typedtree, Lambda 표현, 그리고 자바스크립트 결과물을 prettier printer로 출력하면서 원하는 구현을 해나가는 방식은 인상적이었습니다.\n\n<br />\n\n#### 영어가 한계가 될 수 있지만, 코드가 좋은 소통 수단\n\n구현의 방향을 논의하고 리뷰를 주고 받는 과정은 모두 영어로 해야했습니다. 영어 글쓰기가 편할리만은 없었고, 내 생각과 맥락을 충분히 표현하기는 쉽지 않았습니다. 오히려 구현하는데 드는 시간보다 설명하는데 시간이 더 필요한 경우도 종종 있었습니다. 하지만 코드가 훌륭한 소통 수단이어서, 오픈 소스에 기여하기 위해서 물론 영어 공부를 하는 것도 중요하지만, 코드를 더 잘 짜고 기여를 많이 하는 편이 더 나을 수 있겠다는 생각을 했습니다.\n\n<br />\n\n#### 리스크립트 컴파일러 내부를 더 잘 이해하는 계기\n\n리스크립트 컴파일러 내부와 소스 코드를 이해하고 싶어서 기웃 기웃 레포를 뒤지고 코드를 읽어보긴 했지만, 직접 개발에 참여하는 것만큼 이해하는데 좋은 계기는 없는 것 같습니다. 컴파일러의 설정 값을 파싱하여 사용하는 모듈, syntax 모듈의 인터페이스와 호출되는 방식, 내장 PPX들의 구현, 테스트 방법, 타입 체커, 람다 표현, 자바스크립트 코드 생성이 어떤 모듈에서 어떻게 작동하는지 더 많이 알게 된 좋은 기회였습니다.\n\n<br />\n\n#### 리스크립트, 오캐믈에 대한 믿음\n\n컴파일러 코드는 대부분 오캐믈로 작성되어있습니다. 코드를 더 잘 읽고, 구현을 하는데 있어서 오캐믈의 타입 시스템이 큰 도움이 되었습니다. 그리고 배리언트로 표현된 AST인 Parsetree, Typedtree, Lambda, 그리고 모듈 시스템은 이해하기 쉽고 안전한 코드를 작성하는데 든든한 길잡이었습니다.\n\n그만큼 오캐믈과 동일한 타입시스템을 갖고 있는 리스크립트에 대한 믿음과 기대도 더 커졌습니다.\n\n### 마치며\n\nJSX v4 개발에 기여하면서 느낀 점 중 하나가 리스크립트는 자바스크립트, 타입스크립트 개발자들에게 더 친숙한 문법과 표현력을 가지는 방향으로 개발되어가고 있다는 점 입니다. 현재 진행 중인 `Uncurried as default`도 같은 목표 아래에서 개발되고 있는 기능이구요. 더 많은 자바스크립트, 타입스크립트 개발자들에게 더 친숙하게 접근할 수 있는 언어가 되어서, 훌륭하고 안전한 타입 시스템의 혜택을 더 많은 분들이 즐길 수 있게 되면 좋겠습니다.\n\n<br />\n\n> [그린랩스 Dev Dive 2022, 발표 영상](https://youtu.be/Ql-YAnVneGA)\n\n<iframe\n  width=\"560\"\n  height=\"315\"\n  src=\"https://www.youtube.com/embed/Ql-YAnVneGA\"\n  title=\"YouTube video player\"\n  frameborder=\"0\"\n  allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n  allowfullscreen\n></iframe>\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"woonki.moon@gmail.com\"\n  name=\"문운기\"\n  description=\"프론트엔드 개발자\"\n  date=\"2022-10-30\"\n/>\n","excerpt":"수정사항 (2022-11-17)  > JSX의 외연 확대의 예로 들었던 Remix 대신 Preact 로 변경 리스크립트 컴파일러에 내장된 JSX v4를 개발하게 된 계기와 여정을 소개합니다. 그리고 v3 대비 어떤 점들이 개선되었는지도 소개합니다…","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","tags":[{"name":"ReScript","slug":"re-script"},{"name":"JSX","slug":"jsx"},{"name":"PPX","slug":"ppx"},{"name":"compiler","slug":"compiler"},{"name":"React","slug":"react"}]},{"slug":"/feature-flags-1","title":"Feature flags 적용 (1)","date":"2022년 10월 26일","body":"\n<Author\n  email=\"kjw0323@gmail.com\"\n  name=\"김정우, 양정윤, 이낙원\"\n  description=\"재밌게 개발하자🍅\"\n  date=\"2022-10-26\"\n/>\n\n## 목차\n\n- [들어가며](#intro)\n- [소개](#what-is-feature-flags)\n  - [분류](#category-of-feature-flags)\n    - [출시 토글(Release Toggles)](#release-toggles)\n    - [실험 토글(Experiment Toggles)](#experiment-toggles)\n    - [운영 토글(Ops Toggles)](#ops-toggles)\n    - [승인 토글(Permission Toggles)](#permission-toggles)\n- [적용](#v1-release-toggles)\n- [설계](#design)\n- [구현](#impl)\n  - [프론트엔드](#impl-fe)\n  - [백엔드](#impl-be)\n- [효과](#impact)\n- [참조](#ref)\n\n## <a name=\"intro\"/>들어가며\n\n최근 수십명 규모로 빠르게 늘어난 팜모닝 조직에서는 개발 생산성에 문제가 생기고 있었습니다.\n\n- 여러가지 기능이 동시에 개발되면서 의존성이 생겼습니다. 이로 인해 브랜치 사이에서 의존성이 증가하고 코드 충돌이 길어졌습니다.\n- 큰 기능을 개발하면서 수명이 긴 브랜치들이 생기기 시작했습니다. 이는 코드 리뷰의 어려움을 가져왔고 코드 병합시 알 수 없는 두려움을 가지게 했습니다.\n\n추가로 아래와 운영적 문제점도 있었습니다.\n\n- 신규 기능을 출시할 때 코드 배포와 출시가 동시에 진행되다보니 업무 내 시간에 배포하고 업무 외 시간에 출시를 하는게 힘들었습니다.\n- 신규 기능 출시에 문제가 있을 때 이를 되돌리려면 재배포를 해야해서 약 10분정도의 시간이 소요되었습니다.\n\n개발자의 생산성 문제를 해결하기 위해서 최근에 [Trunk Based Developement](tbd)(이하 TBD)를 도입하였습니다. TBD는 트렁크(메인) 브랜치를 단일 소스로 하여 완벽하지 않은 기능을 부담없이 지속적으로 병합을 가능하게 합니다. 다만, 이 완벽하지 않은 기능을 비활성화하기 위해서 `Feature flags`(기능 플래그)의 필요합니다. 그래서 팜모닝팀에서는 이를 연구하고 적용하기로 했습니다.\n\n## <a name=\"what-is-feature-flags\"/>소개\n\n기능 플래그(혹은 기능 토글)는 코드의 변경 없이 설정만으로 시스템을 바꿀 수 있는 강력한 도구입니다. 아주 다양한 사용방법이 있고 이는 팀이 풀고자 하는 문제에 맞게 다양하게 분류할 수 있고 구현할 수 있습니다.\n\n예시를 들어보겠습니다.\n\n- 팀에서 신규 기능A를 개발하고 출시를 했습니다.\n- 이를 출시 했는데 레이턴시가 너무 높고 치명적인 버그가 발견되었습니다.\n- 이 때, 서버를 롤백하는 것이 아닌 플래그(출시 토글)를 이용해서 기능A를 바로 비활성화 시킬 수 있습니다.\n\n또 다른 예시입니다.\n\n- 팀에서 신규 기능B를 베타 서비스로 출시를 하려고 하는데, 실험적으로 베타 유저에게만 노출하고 싶습니다.\n- 이 때도 플래그(승인 토글)를 이용하면 베타 유저에게만 먼저 베타 기능B를 노출시킬 수 있습니다.\n\n어떤가요? 현재의 팜모닝팀에 알맞은 필요성이라 생각을 했습니다. 그럼 기능 플래그에 대하여 조금 더 자세히 알아보겠습니다.\n\n### <a name=\"category-of-feature-flags\"/>분류\n\n대략 기능 플래그가 무엇인지는 알겠습니다. 여러 시나리오에 맞게 다양한 방식으로 플래그들을 구현할 수 있는데요. [마틴 파울러의 블로그](feature_flags)에서는 피처 플래그를 4가지로 분류하였습니다. 그의 분류법에 따라서 각각에 대하여 간단히 살펴보겠습니다.\n\n#### <a name=\"release-toggles\"/>출시 토글(Release Toggles)\n\nContinuous Delivery를 실행하고자 하는 팀을 위해 TBD를 가능하게 해주는 기능 플래그입니다. main 브랜치에 작업 중인 피처를 가질 수 있도록 해주고 언제든지 운영 환경에 배포할 수 있도록 도와줍니다. 출시 토글은 완전하지 않고, 테스트되지 않은 코드를 켜지지 않은 상태로 프로덕션 코드에 가지고 있을 수 있게 해줍니다.\n\n#### <a name=\"experiment-toggles\"/>실험 토글(Experiment Toggles)\n\n실험 토글은 여러가지 변수 혹은 `A/B testing` 등에 활용될 수 있습니다. 시스템(응용 프로그램)의 사용자는 어떠한 집단에 위치되고, toggle router는 해당 유저가 속한 특정 코드에 속하게 됩니다. 각기 다르게 적용된 코드에 따른 유저 행동을 추적하여 팀에게 `데이터에 기반한 의사결정`을 할 수 있도록 합니다.\n\n#### <a name=\"ops-toggles\"/>운영 토글(Ops Toggles)\n\n운영 토글은 시스템 동작의 운영적 측면을 제어하는데 사용됩니다. 시스템 운영자가 필요에 따라 해당 기능을 비활성화하고 싶을 때 사용할 수 있고 새로운 기능을 출시할 때에도 사용하 할 수 있습니다. 대부분의 운영 토글은 수명이 짧고, 운영에 확신이 생기면 플래그는 폐기되는게 좋습니다.\n\n#### <a name=\"permission-toggles\"/>승인 토글(Permission Toggles)\n\n특정 사용자가 받는 기능이나 제품 경험을 변경하는데 사용되는 플래그입니다. 예를 들어 승인 토글을 이용하여 프리미엄 고객에게만 제공되는 프리미엄 기능 혹은 알파 기능, 베타 기능에 대하여 내부 유저나 베타 유저에게만 노출되도록 할 수 있습니다. 이는 몇가지 측면에서 [Canary Release](canary)와 비슷하지만, 카나리 배포는 무작위 유저에게 노출되는 반면에 승인 토글은 특정 유저에게 노출이 됩니다.\n\n## <a name=\"v1-release-toggles\"/>적용\n\n그린랩스의 팜모닝팀에서 당장 필요성이 있는 출시 토글부터 먼저 적용해보고자 했습니다. 이를 통해 배포와 출시를 분리하고 운영에 도움을 주고자 합니다.\n\n## <a name=\"design\"/>설계\n\n클라이언트에서 서버로 기능 플래그의 상태를 요청하고 활성화 상태에 따라해당 서비스를 노출할지 결정합니다. 그린랩스에서는 [GraphQL](graphql)을 사용하며 아래와 같이 스키마를 구성합니다.\n\n```graphql\ndirective @feature(type: FeatureType!) on FIELD_DEFINITION\n\nenum FeatureType {\n  CHATTING\n  ...\n}\n\ntype Feature {\n  type: FeatureType!\n  description: String!\n  active: Boolean!\n}\n\ntype Query {\n  features: [Feature!]!\n}\n```\n\n설정값은 데이터베이스에 key-value 값으로 저장할 수 있으며 JSON 형식으로 아래처럼 값을 저장하고 GraphQL `features` 요청이 들어왔을 때 이를 그대로 응답합니다.\n\n```json\n[\n   {\n      \"type\": \"CHATTING\",\n      \"active\": false,\n      \"description\": \"채팅\"\n   },\n   ...\n]\n```\n\n## <a name=\"impl\"/>구현\n\n### <a name=\"impl-fe\"/>프론트엔드\n\n```graphql\nquery Features {\n  features {\n    type\n    description\n    active\n  }\n}\n```\n\n프론트엔드에서는 `Provider` 를 작성하여 query 한 `features` field를 context에 담아주고, hook을 사용하여 원하는 기능 플래그의 Boolean값을 호출할 수 있도록 구현합니다.\n\n```rescript\nuseFeatureFlag : RelaySchemaAssets_graphql.enum_FeatureType ⇒ bool\n```\n\n<details>\n<summary>Provider 구현 예시</summary>\n<div markdown=\"1\">\n\n```rescript\ntype features = FeatureHelper_Query_graphql.Types.response_features\n\ntype t = {features: array<features>}\n\nmodule Query = %relay(`\n query FeatureHelper_Query {\n   features {\n     featureType: type\n     active\n     description\n   }\n }\n`)\n\nlet context = React.createContext(None)\nlet useContext = () => React.useContext(context)->Option.getExn\n\nmodule Provider = {\n  let provider = React.Context.provider(context)\n\n  module CreateElement = {\n    @react.component\n    let make = (~children, ~queryRef) => {\n      let {features} = Query.usePreloaded(~queryRef, ())\n\n      let contextValue = React.useMemo0(() => {\n        features: features,\n      })\n\n      React.createElement(provider, {\"value\": Some(contextValue), \"children\": children})\n    }\n  }\n\n  @react.component\n  let make = (~children) => {\n    let (queryRef, loadQuery, _) = Query.useLoader()\n\n    React.useEffect0(() => {\n      loadQuery(~variables=(), ())\n      None\n    })\n\n    {\n      queryRef->Option.mapWithDefault(React.null, queryRef' =>\n        <CreateElement queryRef=queryRef'> {children} </CreateElement>\n      )\n    }\n  }\n}\n\nlet useFeatureFlag = flagType => {\n  let commonContext = useContext()\n  commonContext.features\n  ->Array.getBy(feature => feature.featureType == flagType)\n  ->Option.mapWithDefault(false, feature' => feature'.active)\n}\n\n```\n\n</div>\n</details>\n\n기능 플래그가 달려 있는 기능의 경우, hook을 호출한 후 분기 처리를 통해 해당 기능이 노출될지 말지를 결정할 수 있습니다.\n\n```rescript\n@react.component\nlet make = () => {\n  let chatFeatureFlag = FeatureHelper.useFeatureFlag(#CHATTING)\n\n  chatFeatureFlag\n    ? <Container/>\n    : React.null\n}\n```\n\n### <a name=\"impl-be\"/>백엔드\n\n프론트엔드에서 화면을 노출하는 것과 별개로 악의적 공격이나 타이밍 이슈에 의한 API 호출에 대비하여 플래그가 비활성화 상태일 때 잘못된 요청임을 알려줘야합니다. 어플리케이션 레벨에서 선언적으로 필터링 로직을 추가하기 위해 GraphQL의 커스텀 [directives](graphql_directives)를 이용하여 이를 정의하고자 했고 위의 스키마는 아래처럼 디렉티브를 달아주었습니다.\n\n```graphql\ntype Query {\n  \"@feature type이 active인 경우에만 정상 동작하고 아닌 경우 에러 응답\"\n  chatChannels(postId: ID!, first: Int, after: String): ChatChannelConnection @feature(type: FeatureType.CHATTING)\n  ...\n}\n```\n\nGraphQL 필드에 `@feature` 디렉티브가 있으면 서버에서 플래그 상태를 검사하고 에러를 반환하도록 하였습니다.\n\n```json\n{\n  \"data\": null,\n  \"errors\": [\n    {\n      \"message\": \"The FeatureType.CHATTING flag was inasctivated\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ],\n      \"path\": [\"chatChannels\"]\n    }\n  ]\n}\n```\n\n## <a name=\"impact\"/>효과\n\n팜모닝팀에서는 빠르게 기능 플래그를 도입하였고 세가지의 효과를 가졌습니다.\n\n1. 배포와 출시를 분리하였습니다. 코드 배포는 되었지만 출시는 원하는 날짜와 시간에 할 수 있게 되었습니다.\n2. 버그 대응이 빨라졌습니다. 플래그가 달린 기능에 대하여 버그가 있을 때 1초 이내에 해당 기능을 비활성화 시킬 수 있게 되었습니다.\n3. 버전 관리가 더 간편해졌습니다. 기존에는 큰 기능을 개발할 때 git에서 수명이 긴 브랜치가 생길 때도 있었는데, 현재는 빠르게 병합할 수 있는 환경이 되었습니다.\n\n팜모닝의 사용자수는 점점 늘어나고 있어 유저 유형의 세분화가 필요해지고 있습니다. 그에 따라 사용자의 행동 패턴에 따른 맞춤 서비스를 제공할 예정입니다. 그래서 팜모닝팀의 다음 계획은 승인 토글을 도입하는 것입니다. 이를 위한 방법 중 하나로 알파, 베타, 혹은 프리미엄 서비스들을 선택적으로 특정 집단에만 제공하고 선택적으로 운영이 가능하게 하려고 합니다. 이에 대한 내용은 Feature flags 2부에서 뵙겠습니다 :)\n\n## <a name=\"ref\"/>참조\n\n- [마틴파울러의 기능 플래그 설명](feature_flags)\n- [아틀라시안의 기능 플래그 설명](https://www.atlassian.com/continuous-delivery/principles/feature-flags)\n\n[feature_flags]: https://martinfowler.com/articles/feature-toggles.html\n[graphql]: https://graphql.org/\n[graphql_directives]: https://www.apollographql.com/docs/apollo-server/schema/directives/\n[tbd]: https://trunkbaseddevelopment.com/\n[canary]: https://martinfowler.com/bliki/CanaryRelease.html\n","excerpt":"목차 들어가며소개\n분류\n출시 토글(Release Toggles)실험 토글(Experiment Toggles)운영 토글(Ops Toggles)승인 토글(Permission Toggles)\n적용설계구현\n프론트엔드백엔드\n효과…","description":"Release Toggles 적용","tags":[{"name":"Greenlabs","slug":"greenlabs"},{"name":"feature-flags","slug":"feature-flags"}]},{"slug":"/pair-programming","title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022년 8월 25일","body":"\n<Author\n  email=\"hyojeongcho1019@gmail.com\"\n  name=\"조효정\"\n  description=\"팜모닝 프론트엔드 개발자\"\n  date=\"2022-08-25\"\n/>\n\n안녕하세요. 그린랩스 팜모닝 프론트엔드 개발자 조효정입니다.\n\n그린랩스 프론트엔드 개발자로, 페어 프로그래밍을 하며 어떤 것들을 경험하고 느낄 수 있는지 자랑해보겠습니다😎\n\n> 프론트엔드 길드 : 그린랩스에서 소속된 서비스/사업 상관없이 '프론트엔드 직군 전체'를 칭하는 단어입니다.\n\n## 페어 프로그래밍이란?\n\n---\n\n페어 프로그래밍이란 애자일 소프트웨어 개발 중 하나로 하나의 컴퓨터에서 두 명의 개발자 (진행자 driver, 관찰자 navigator) 가 작업하는 방법을 말합니다.\n\n**진행자** 역할의 개발자는 코드를 작성하고, **관찰자** 역할의 개발자는 실시간 코드 리뷰를 하며 구현 방식과 구조에 대해 고민합니다. 두 개발자는 수시로 역할을 바꿉니다.\n\n<br />\n\n#### 페어 프로그래밍을 하는 이유🤔\n\n1. 버그가 적어집니다.\n\n   배경지식이 다른 두 명의 개발자가 다양한 각도에서 문제를 살펴볼 수 있어 최적의 방법을 찾아낼 가능성이 높습니다.\n\n   멀리서 보아야 비로소 보이는 버그 (작고 귀여운 오타에서 구조 문제까지👻)를 실시간 리뷰를 통해 발견하고 빠르게 수정할 수 있습니다.\n\n2. 팀워크가 향상됩니다.\n\n   같은 팀이지만 당장 필요한 질문들 외에 이야기를 나눌 기회가 많지 않고, 재택근무가 활성화되다 보니 더더욱 네트워킹이 쉽지 않습니다.\n\n   페어 프로그래밍을 통해 팀원들과 대화를 나누며 서로 신뢰가 쌓이고 팀워크가 좋아집니다.\n\n<center>\n  <img src=\"https://tenor.com/view/tag-gif-23064747.gif\" />\n</center>\n\n## 그린랩스에서 페어 프로그래밍 하는 법 👨‍🌾 🖥 🧑‍🌾\n\n---\n\n그린랩스 프론트엔드 길드는 소스 코드를 기반으로 문제를 해결하는 비정기 페어 프로그래밍과,\n알고리즘 문제를 함께 해결해보는 정기 페어 프로그래밍의 두 가지 방식으로 페어 프로그래밍을 진행합니다.\n\n비정기적 페어 프로그래밍은 주로 같은 맥락을 공유하고 있는 같은 팀 개발자와 진행하기 때문에, 그린랩스의 다양한 개발자분들을 만나지 못한다는 아쉬움이 있었습니다.\n\n다양한 분들과 페어 프로그래밍을 진행해보고 싶어 알고리즘 문제를 해결하는 정기 페어 프로그래밍을 기획하게 되었고\n이를 통해 **소속된 서비스와 관계없이** 다양한 개발자분들과 **네트워킹**할 수 있었습니다.\n\n<br />\n\n#### Step 1. 📣 페어 파트너 구합니다\n\n페어 프로그래밍을 희망하는 개발자는 페어 파트너를 구해야 합니다. 이때 페어 프로그래밍 종류에 따라 페어 파트너를 구하는 방법이 다릅니다.\n\n- 비정기 페어 프로그래밍\n\n  공개적으로 상황을 공유하고 페어 프로그래밍을 요청합니다.\n  관련 경험이 있는 개발자 또는 페어 주제에 관심있는 개발자가 자발적으로 지원해 요청자의 코드를 살펴봅니다.\n\n  > 더 좋은 코드가 있을 것 같은데 생각이 막혀버린 저...😰\n  >\n  > 슬랙 채널에 상황과 코드를 공유합니다.(HELP...!)\n  >\n  > 00님이 댓글로 관심을 보이는군요? **바로** 페어 프로그래밍을 신청합니다.\n\n  <br />\n\n- 정기 페어 프로그래밍\n\n  매주 화요일, 그린랩스 프론트엔드 개발자가 모두 모이는 기술공유세션에서 이번 주 알고리즘 문제를 공유합니다.\n\n  돌려돌려 돌림판을 돌려 **행운의 페어 파트너**를 선정합니다. 이번주는 어떤분과 함께하게 될까요?\n\n  이번주 행운의 페어 파트너로 선정된 개발자와 일정 조율 후 페어 프로그래밍을 진행합니다.\n\n  ![행운의 돌림판](img1.png)\n\n<br />\n\n#### Step 2. 오늘 페어 프로그래밍 목표는 이것입니다 🧐\n\n진행자 역할의 개발자가 구현해야 할 로직을 설명하고 목표를 정하는 것으로 페어 프로그래밍이 시작됩니다.\n\n원격 근무중이라면 LiveShare와 온라인 화상 회의로, 함께 있는 경우 한 사람의 컴퓨터 화면을 보며 페어 프로그래밍을 진행합니다.\n\n> [Live Share](https://visualstudio.microsoft.com/ko/services/live-share/)란, 실시간 공동 개발을 할 수 있게 도와주는 vscode의 확장 프로그램입니다.\n\n![live share](https://visualstudio.microsoft.com/wp-content/uploads/2018/11/v2-Edit-Comp_FINAL-optimized840.gif)\n\n<br />\n\n#### Step 3. 번갈아가며 코드를 작성합니다 👯\n\n주로 경험이 더 많은 개발자가 관찰자의 역할을 맡는 것으로 시작됩니다.\n\n- 관찰자 역할의 개발자는 문제 해결을 위한 큰 그림을 그리고 진행자에세 방향을 제시합니다.\n\n- 진행자 역할의 개발자는 관찰자의 가이드에 따라 구체적인 코드를 아름답게 표현합니다.\n\n<br />\n\n#### Step 4. **페어로그**를 작성합니다 ✍🏻\n\n페어 프로그래밍을 마치고 나서는 페어로그를 작성합니다.\n\n**페어로그를 쓰는 이유**\n\n- 파트너 개발자의 노하우와 문제 해결 방식을 기록하고 전파할 수 있습니다.\n- 우리는 가끔 비슷한 문제로 힘들어합니다. 미래에 있는 동료가 문제를 해결할 때 도움이 될 수 있습니다.\n  > 프로필 섹션 구현을 위해 고민하던 중 컴포넌트 재사용성 향상을 주제로 한 페어로그를 보았고\n  > 그 내용을 참고해 재사용하기 좋은 프로필 컴포넌트를 작성할 수 있었습니다. 고마워요 페어로그!\n- 페어 로그를 통해 쉽고 빠르게 정보를 찾을 수 있습니다.\n\n페어로그가 지식 전파, 문제 해결 속도를 향상하는 기록의 역할을 하기 때문에 페어 프로그래밍의 과정을 최대한 상세히 기록합니다.\n\n페어 로그에는 다음과 같은 내용을 기록합니다.\n\n- 참여자, 진행 일시, 진행 방법 : 참여자, 날짜와 시간, 그리고 오프라인, 온라인 등의 진행 방식\n- 함께한 작업 : 페어 프로그래밍 주제가 된 알고리즘 문제 또는 기능\n- 이슈 : 페어를 진행하면서 나왔던 질문, 답변\n- 소감 : 각자의 소감\n- 다음 할 일: 액션 아이템 혹은 읽어보면 좋을 참고자료 링크 등\n  ![페어 로그](img2.png)\n\n## 내가 페어 프로그래밍을 통해 얻은 것들\n\n---\n\n🌱 신입시절 적응도 향상\n\n부트캠프 이후 작은 단위의 업무를 페어로 진행하면서 언어와 아키텍쳐에 대한 이해도를 높일 수 있었습니다.\n그 과정에서 프론트엔드 길드의 개발 환경, 개발 스타일 지식을 공유할 수 있었고 빠르게 적응할 수 있었습니다.\n\n<br />\n📒 지식 교환과 성장\n\n길드 내 다양한 개발자분들의 문제 해결 노하우와 통찰을 얻을 수 있었고 실시간으로 피드백을 주고 받으며 선배 개발자의 생각의 흐름을 따라가는 값진 경험을 할 수 있었습니다.\n\n> 주니어의 실력을 향상시킬 수 있는 최고의 기회! 이 부분을 이렇게 해결할 수 있군요! 아이디어가 떠오릅니다!\n\n<br />\n❤️ 팀원과 신뢰 관계 구축\n\n좋은 코드를 만들기 위해 동료 개발자와 많은 대화를 나누었습니다. 자연스럽게 친밀감과 동료에 대한 신뢰가 높아졌습니다.\n이 신뢰를 바탕으로 업무 중에 모르는 부분이 생기면 편하게 질문하고 새로운 방법에 도전할 수 있었습니다.\n\n## 마치며\n\n---\n\n어려움이 있거나 나누고 싶은 코드가 있으면 편하게 외쳐봅니다!\n\n> 페어 어떠세요!\n\n<center>\n  <img src=\"https://tenor.com/view/sponge-bob-im-ready-gif-25548017.gif\" />\n</center>\n","excerpt":"안녕하세요. 그린랩스 팜모닝 프론트엔드 개발자 조효정입니다. 그린랩스 프론트엔드 개발자로, 페어 프로그래밍을 하며 어떤 것들을 경험하고 느낄 수 있는지 자랑해보겠습니다😎\n\n프론트엔드 길드 : 그린랩스에서 소속된 서비스/사업 상관없이 '프론트엔드…","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","tags":[{"name":"Greenlabs","slug":"greenlabs"},{"name":"Pairprogramming","slug":"pairprogramming"},{"name":"experience","slug":"experience"}]},{"slug":"/lazy-sequence-from-scratch","title":"함수만으로 지연성까지","date":"2022년 7월 27일","body":"\n## 소개\n\n제가 함수형 프로그래밍으로 개발한다고 말하면, 때때로 저에게 함수만으로 무엇을 할 수 있는지 물어보는 분들이 있습니다.\n저는 그분들에게 무엇이든 할 수 있다고 답합니다. 하지만 이 말로는 부족할 때가 많습니다.\n오늘은 그 질문에 대한 저만의 답변이 될 만한 이야기들을 간단하게 적어보려고 합니다.\n\n## 자연수 만들기\n\n함수만으로 우리는 자연수를 표현할 수 있습니다.\n저는 처치 인코딩(Church numerals)을 이용하려고 합니다. 자세한 설명은 다음 링크를 참고해주시기 바랍니다. [[1]](#ref-1)[[5]](#ref-5)\n개발자는 코드로 말하므로 이론적인 설명은 치우고 곧바로 코드를 만들도록 하겠습니다.\n\n숫자 0, 1, 2, 3 만들어 보겠습니다. 숫자의 크기는 함수`f`가 얼마나 감싸고 있느냐로 표현합니다.\n언어는 자바스크립트를 사용합니다.[[4]](#ref-4)\n\n```js\nvar zero = (f) => (x) => x;\nvar one = (f) => (x) => f(x);\nvar two = (f) => (x) => f(f(x));\nvar three = (f) => (x) => f(f(f(x)));\n```\n\n다음 수, 더하기, 곱하기 함수를 만들어보겠습니다. (빼기, 나누기, 지수 등 추가적으로 관심이 있으시다면 [[5]](#ref-5)를 참고해주세요)\n\n```js\n// f를 1개 추가합니다.\nvar SUCC = (n) => (f) => (x) => f(n(f)(x));\n// f를 n개 추가합니다.\nvar PLUS = (m) => (n) => m(SUCC)(n);\nvar MULT = (m) => (n) => m(PLUS(n))(zero);\n```\n\n하지만 람다표현식이 정말로 제대로 동작하는지 확인하기는 쉽지 않습니다. 모두 함수로 감싸져있기 때문입니다.\n임의로 출력하는 함수는 만들어보았습니다. 함수로 문자를 표현하는 것은 생각하겠습니다.\n\n```js\nvar printNumber = (f) => f((n) => n + '+1')('0');\n```\n\n실제로 출력을 해보겠습니다.\n\n```js\nconsole.log(printNumber(zero)); // 0\nconsole.log(printNumber(one)); // 0+1\nconsole.log(printNumber(two)); // 0+1+1\nconsole.log(printNumber(three)); // 0+1+1+1\n```\n\n계승, 더하기, 곱하기는 잘 작동하는지 보겠습니다.\n\n```js\nconsole.log(printNumber(SUCC(three))); // 0+1+1+1+1\nconsole.log(printNumber(MULT(two(one)))); // 0+1+1\nconsole.log(printNumber(MULT(two)(three))); // 0+1+1+1+1+1+1\n```\n\n## 함수로 만드는 자료구조\n\n우리는 자료구조 중에 두 개의 요소를 저장할 수 있는 `pair`를 만들어 볼 것입니다.\n이제부터 숫자는 자바스크립트 타입을 그대로 사용하겠습니다.\n\n```js\nvar pair = (a) => (b) => (f) => f(a)(b);\nvar first = (a) => (b) => a;\nvar second = (a) => (b) => b;\n\npair(1)(2)(first); // 1\npair(1)(2)(second); // 2\n```\n\n이렇게 구현한 pair를 이용하여 우리는 N개의 요소를 나열하는 자료구조를 만들 수 있습니다.\n\n```js\npair(1)(pair(2)(3))(first); // 1\npair(1)(pair(2)(3))(second)(first); // 2\n```\n\n## 함수로 만드는 조건절\n\n조건절을 만드려면 참과 거짓이 있어야합니다.\n\n```js\nvar TRUE = (a) => (b) => a;\nvar FALSE = (a) => (b) => b;\n```\n\n이 함수가 참과 거짓을 잘 나타내는지 확인해보기위해 `AND`, `OR` 를 만들어보겠습니다.\n\n```js\nvar AND = (a) => (b) => a(b)(FALSE);\nvar OR = (a) => (b) => a(TRUE)(b);\n```\n\n진리표에 부합하는 값이 나오는지 테스트해보겠습니다.\n\n```js\nAND(TRUE)(TRUE); // [Function: TRUE]\nAND(TRUE)(FALSE); // [Function: FALSE]\nAND(FALSE)(TRUE); // [Function: FALSE]\nAND(FALSE)(FALSE); // [Function: FALSE]\n\nOR(TRUE)(TRUE); // [Function: TRUE]\nOR(TRUE)(FALSE); // [Function: TRUE]\nOR(FALSE)(TRUE); // [Function: TRUE]\nOR(FALSE)(FALSE); // [Function: FALSE]\n```\n\n조건절은 아래처럼 만들 수 있습니다.\n\n```js\nvar COND = (p) => (a) => (b) => p(a)(b);\n```\n\n`TRUE`, `FALSE` 가 잘 작동하는지 보겠습니다.\n\n```js\nCOND(TRUE)(1)(2); // 1\nCOND(FALSE)(1)(2); // 2\n```\n\n실제로 사용을 하려면 `TRUE`, `FALSE` 람다를 리턴하는 함수가 필요합니다.\n위에서 생성한 숫자를 테스트하는 `ISZERO` 를 만들어 보겠습니다.\n\n```js\nvar ISZERO = (f) => f((a) => FALSE)(TRUE);\nISZERO(zero); // [Function: TRUE]\nISZERO(one); // [Function: FALSE]\n```\n\n`COND` 에 대입하면 작동하는 것을 볼 수 있습니다.\n\n```js\nCOND(ISZERO(zero))(10)(20); // 10\nCOND(ISZERO(one))(10)(20); // 20\n```\n\n## 함수로 만드는 반복문\n\n함수로 반복문을 만들 때는 재귀를 이용합니다.\n하지만 만약 이름이 없는 익명함수(람다)인 경우는 어떻게 할 수 있을까요?\n\n오로지 익명함수만으로 재귀를 호출할 수 있는 '와이콤비네이터'라는 것이 있습니다.\n이것은 일전에 제가 블로그로 소개하는 것이 있으니 그것을 참고해주시면 감사하겠습니다. [[2]](#ref-2)\n\n## 함수로 만드는 지연성\n\n대부분의 프로그래밍 언어는 함수가 실행되기 전에 인자를 먼저 평가합니다. [[3]](#ref-3)\n아래 코드에서 우리는 `1 + 1` 표현식의 평가를 지연시켜야 합니다.\n\n```js\nsomeFunction(1 + 1);\n```\n\n그러기 위해서 우리는 함수로 감싸서 평가를 지연시킬 것입니다.\n\n```js\nvar delayedTwo = () => 1 + 1;\n```\n\n다시 실행하려면 인자가 없이 함수를 실행시키면 됩니다.\n\n```js\ndelayedTwo();\n2;\n```\n\n이제 우리는 아주 쉽게 평가가 지연된 배열을 만들 수 있습니다.\n\n```js\n// 가독성을 위해 인자 2개를 한번에 받도록 하였습니다.\nvar l = pair(1)(() => 2);\nl(second)();\n```\n\n하지만 중간중간마다 `()` 을 이용하여 지연(delay)된 값을 강제로 평가해서 가져와야 합니다.\n우리는 이것을 `force`라는 함수로 대신하도록 할 것입니다.\n\n```js\nvar force = (a) => a();\n```\n\n이제 `second`의 경우 수행될 때마다 한번은 강제로 평가를 수행하는 `force`를 추가로 수행해야 합니다.\n\n```js\nvar force = (a) => a();\nvar secondForce = (a) => (b) => b(force);\n```\n\n이제 다음처럼 호출할 수 있습니다.\n\n```js\nl(secondForce);\n2;\n```\n\n우리는 이제 특정 범위의 숫자를 지연된 리스트로 만들어낼 수 있습니다.\n\n```js\nvar range = (start) => (end) => {\n  if (start > end) {\n    return null;\n  } else {\n    return pair(start)(() => range(start + 1)(end));\n  }\n};\n```\n\n테스트를 해보겠습니다.\n\n```js\nvar a = range(1)(3);\na(first); // 1\na(secondForce)(first); // 2\na(secondForce)(secondForce)(first); // 3\n```\n\n테스트하기 위해 좀 지연된 리스트를 모두 리턴하는 함수를 만들어 보겠습니다.\n\n```js\nvar printAll = (list) => {\n  while (list != null) {\n    console.log(list(first));\n    list = list(secondForce);\n  }\n};\n\nprintAll(range(1)(10));\n```\n\n무한으로 반복하는 `repeat`이라는 함수도 만들 수 있습니다.\n\n```js\nvar repeat = (n) => pair(n)(() => repeat(n));\n\nvar ones = repeat(1);\nones(first); // 1\nones(secondForce)(first); // 1\nones(secondForce)(secondForce)(first); // 1\n// printAll() // 브라우저가 멈출 수 있습니다.\n```\n\n우린 방금 무한으로 만들어지는 자료구조를 생성하였습니다.\n이제 `take`라는 함수를 이용해서 무한 자료구조에서 N개만을 가져올 수 있도록 해볼 것입니다.\n\n```js\nvar take = (n) => (list) => {\n  if (n <= 0) return null;\n  return pair(list(first))(() => take(n - 1)(list(secondForce)));\n};\n\nprintAll(take(100)(repeat(1))); // 1이 100번 출력됩니다.\nprintAll(take(1)(range(1)(10000000000000000000000000000000000))); // 1\n```\n\n아래는 지금까지 소개한 코드를 모두 모아놓은 것입니다.\n\n```js\nvar zero = (f) => (x) => x;\nvar one = (f) => (x) => f(x);\nvar two = (f) => (x) => f(f(x));\nvar three = (f) => (x) => f(f(f(x)));\n\nvar SUCC = (n) => (f) => (x) => f(n(f)(x));\nvar PLUS = (m) => (n) => m(SUCC)(n);\nvar MULT = (m) => (n) => m(PLUS(n))(zero);\n\nvar printNumber = (f) => f((n) => n + '+1')('0');\n\nvar pair = (a) => (b) => (f) => f(a)(b);\nvar first = (a) => (b) => a;\nvar second = (a) => (b) => b;\n\nvar TRUE = (a) => (b) => a;\nvar FALSE = (a) => (b) => b;\n\nvar AND = (a) => (b) => a(b)(FALSE);\nvar OR = (a) => (b) => a(TRUE)(b);\n\nvar COND = (p) => (a) => (b) => p(a)(b);\n\nvar ISZERO = (f) => f((a) => FALSE)(TRUE);\n\nvar force = (a) => a();\nvar secondForce = (a) => (b) => b(force);\n\nvar range = (start) => (end) => {\n  if (start > end) {\n    return null;\n  } else {\n    return pair(start)(() => range(start + 1)(end));\n  }\n};\n\nvar repeat = (n) => pair(n)(() => repeat(n));\n\nvar take = (n) => (list) => {\n  if (n <= 0) return null;\n  return pair(list(first))(() => take(n - 1)(list(secondForce)));\n};\n\nvar printAll = (list) => {\n  while (list != null) {\n    console.log(list(first));\n    list = list(secondForce);\n  }\n};\n```\n\n## Clojure Macro로 Javascript의 한계를 넘어보기\n\n이번장은 람다표현식에 대한 장이 아닙니다. 함수를 넘어서 매크로를 설명하는 번외편입니다.\n\n우리는 지금까지 자바스크립트를 사용하여 함수의 강력함을 알아보았습니다.\n자바스크립트의 함수는 가능한 모든 것을 만들기에 충분합니다.\n하지만 저에게는 한 가지 아쉬운 점이 남아있습니다.\n\n바로 지연하기 위한 코드를 함수로 만들 수 없다는 점입니다.\n\n```js\nvar delay = (a) => () => a;\n```\n\n이 코드는 지연이 되는 것 같지만 우리가 원하는 대로 수행되지 않습니다.\n\n```js\ndelay(console.log('지연되지 않는다'));\n```\n\n왜냐하면 `delay` 가 수행되기 전에 인자가 먼저 평가되기 때문입니다. [[3]](#ref-3)\n우리는 아래처럼 직접 익명함수로 감싸줘야합니다.\n\n```js\n// 이렇게 말이지요\n() => console.log('지연되었습니다.');\n```\n\n하지만 지연성이 필요할 때마다 `() =>` 를 직접 넣고 싶지는 않습니다.\n저는 코드가 좀 더 가독성 있고 자연스러웠으면 좋겠습니다.\n저는 이름을 붙이고 싶습니다.\n\n우리는 자바스크립트로 이것을 해결하기 위해 `eval`, `new Function`을 이용한다면 코드를 문자열로 변경해야 할 것입니다.\n혹은 바벨이나 직접 트랜스파일링을 할 수도 있겠죠. 그렇다면 일이 엄청나게 커질 것입니다.\n\n하지만 이번에는 그린랩스에서 사용하는 Clojure코드를 이용하여 `delay`가 얼마나 쉽게 생성되는지 소개하겠습니다.\n우리는 `delay`라는 매크로를 사용하여 아래 코드를 지연시킬 것입니다.\n\n```clojure\n(delay (println \"지연이 되어야 합니다.\"))\n```\n\n생성된 코드는 다음과 같습니다.\n\n```clojure\n(defmacro delay [expr]\n  `(fn [] ~expr))\n\n(def delayed-print (delay (println \"지연되어야 합니다.\"))) ;; 이곳에서는 아무것도 출력되지 않습니다.\n(delayed-print)  ;; \"지연되어야 합니다.\" 가 출력됩니다.\n```\n\nClojure의 매크로는 아주 자연스럽게 언어를 확장합니다. 원래 그랬던 것처럼요.\n\n감사합니다.\n\n## 참고문헌\n\n1. lambda calculus에 대한 개요\n\n- [1] : [Lambda Calculus에 대해 알아보자](https://helloworld.kurly.com/blog/lambda-calculus-1/) <a name=\"ref-1\"/>\n\n2. Y-Combinator\n\n- [2] : [https://helloworld.kurly.com/blog/y-combinator/](https://helloworld.kurly.com/blog/y-combinator/) <a name=\"ref-2\" />\n\n3. applicative order eveluation\n\n- [3] : [언어의 평가 순서](https://en.wikipedia.org/wiki/Evaluation_strategy) <a name=\"ref-3\"/>\n\n4. 설명하는 언어로 자바스크립트를 사용한 이유\n\n- [4] : [https://www.crockford.com/javascript/javascript.html](https://www.crockford.com/javascript/javascript.html) <a name=\"ref-4\"/>\n\n5. 처치 인코딩\n\n- [5] : [https://en.wikipedia.org/wiki/Church_encoding](https://en.wikipedia.org/wiki/Church_encoding) <a name=\"ref-5\"/>\n","excerpt":"소개 제가 함수형 프로그래밍으로 개발한다고 말하면, 때때로 저에게 함수만으로 무엇을 할 수 있는지 물어보는 분들이 있습니다. 저는 그분들에게 무엇이든 할 수 있다고 답합니다. 하지만 이 말로는 부족할 때가 많습니다. 오늘은 그 질문에 대한 저만의…","description":"그만 알아보자","tags":[{"name":"Javascript","slug":"javascript"},{"name":"Laziness","slug":"laziness"},{"name":"Lambda Calculus","slug":"lambda-calculus"},{"name":"clojure","slug":"clojure"}]},{"slug":"/with-greenlabs-for-1yr","title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022년 7월 21일","body":"\n<Author\n  email=\"mccha0407@gmail.com\"\n  name=\"차민철\"\n  description=\"신선하이 백엔드 개발자\"\n  date=\"2022-07-21\"\n/>\n\n안녕하세요. 신선하이 백엔드 개발자 차민철입니다. 그린랩스에 입사한지 이제 막 1년이 지나 그간의 경험을 공유해보려고 합니다.\n\n## 입사 전\n\n입사 전부터 함수형 프로그래밍에 관심이 많았었는데요. 이 글을 읽고 계실 여러분처럼 실제로 현업에서 함수형 언어를 어떻게 사용하고 있는지도 궁금했고, 또 한 번 쯤은 함수형 언어로 개발해보고 싶은 마음에 지원했습니다. 지난 3년간 자바스크립트를 사용하여 웹 어플리케이션 개발을 했었고, 그린랩스에 합류하면서 클로저란 언어를 처음 접하고 사용하게 되었습니다.\n\n국내에서 클로저라는 언어를 사용하는 기업은 그린랩스가 거의 유일하다고 볼 수 있어 커리어에 대한 걱정도 조금 있었습니다. 하지만 회사에서 사용하는 언어를 클로저로 선택하는 것은 분명 쉽지 않았을 테고, 사용하기로 결정했다면, 이 언어만의 확실한 장점이 있으리라 생각했습니다. 그리고 이런 결정을 할 수 있는 회사라면 실무자들의 의사결정을 존중하는 문화를 가졌을 거라는 믿음이 있었습니다.\n\n> 능서불택필 - 글씨를 잘 쓰는 이는 붓을 가리지 않는다. 즉 일에 능한 사람은 도구를 탓하지 않는다\n\n**개발자의 성장에는 어떤 언어를 쓰느냐보다 누구와 함께 일하는지가 더 중요하다고 생각합니다.** 그린랩스에 이미 합류하신, 그리고 앞으로 합류하실 분들 모두 변화를 두려워하지 않고 도전하는 멋진 분들이라고 확신할 수 있었습니다. 한편으로는, 도구를 가리지 않는 장인들의 모임일 수도 있겠다고 생각했습니다. 1년이 지난 지금 돌이켜보면, 제 인생에서 잘한 선택 중 하나라고 생각합니다.😀\n\n## ((클로저))의 첫 인상\n\n클로저(Clojure) 뿐 아니라 리습(Lisp) 계열의 언어를 처음 접해보는 터라 걱정이 많았습니다.\n\n![그림](image1.png)\n\n처음에는 괄호가 너무 많아서 (특히, 맨 끝의 괄호모음... `))))`) 당황하기도 했고 코드를 읽는게 어렵게 느껴졌습니다. 이런 문법 에러를 만나기도 하구요.\n\n```\nUnmatched delimiter: )\n```\n\n하지만, 퍼레딧(paredit)과 퍼린퍼(parinfer) 같은 리습용 편집 도구를 사용하면 이런 괄호를 쉽게 다룰 수 있습니다. 괄호가 익숙해지면서는 오히려 평가 순서가 명확하게 보이고 필요한 부분만 한 눈에 볼 수 있어 가독성이 훨씬 좋아진 것을 느꼈습니다.\n\n클로저를 사용하는 유저들의 경력이 많아서인지 입문자를 위한 문서화, 튜토리얼 등이 다른 언어에 비해 부족하다고 느껴지기도 했고, 종종 라이브러리 코드를 직접 살펴봐야 하는 경우도 있었습니다. 하지만 지금 돌이켜보면 이런 부분 덕분에 다양한 것들을 학습할 수 있었습니다.\n\n그린랩스에 입사하면 3주간 클로저를 학습하는 부트캠프 과정을 진행합니다. 부트캠프의 커리큘럼이 잘 짜여있고 좋은 리뷰어와 함께하는 과정이라 **클로저의 사고방식(The Clojure Way)**으로 전환하는데 크게 어렵지 않았습니다.\n부트캠프 과정과 후기가 궁금하시다면 [\"그린랩스에서 클로저 시작하기\"](https://green-labs.github.io/clojure-bootcamp)라는 글을 추천합니다.\n\n## 그린랩스에서 만난 동료들 🤟\n\n👋 그린랩스에서 함께 일하는 멋진 동료들 소개합니다.\n\n**1) 개발 생산성을 높이기 위해 도구를 만들어 쓰는 동료**\n![그림](image3.png)\n[하수라(Hasura)](https://hasura.io/)에 영감을 받은 개발자들이 그래프QL API를 만들 때 반복적으로 작성해야하는 부분들을 자동화 해주는 도구 [고수라(Gosura)](https://github.com/green-labs/gosura)를 직접 만들어서 사용하고, 공개도 하고 있습니다.\n\n![그림](image4.png)\n\n프론트엔드에서 사용하는 리스크립트도 비슷한데요. 라이브러리의 부족한 부분을 보완해서 사용하고, 여기서 그치지 않고 외부의 다른 개발자들도 도움을 받을 수 있도록 공개하고 있습니다.\n\n클로저와 리스크립트 생태계에 기여하는 동료들을 보고 2022년이 다 가기 전에 저도 클로저 생태계에 한 가지라도 기여해야겠다는 목표를 세울 수 있었습니다.\n두 오픈소스에 대한 내용들은 컨트리뷰터들이 기술 블로그나 밋업에서 더 자세히 설명해주실 날이 있을 것 같습니다.🙂\n\n**2) 꼼꼼한 배포 계획으로 인해 침대에 누운 것처럼 편안한 배포를 가능케 한 동료**\n\n배포 시나리오를 미리 작성하고 배포 전에 함께 스쿼드 구성원들이 함께 리뷰한 내용의 일부입니다.\n![그림](image12.png)\n\n온라인에 다 같이 모여서 배포를 진행한 모습입니다.\n![그림](image6.png)\n\n캡쳐를 통해 어떤 히스토리로 배포 되었는지도 스레드에 남깁니다.\n![그림](image10.png)\n\n운영 배포는 경험이 많아도 떨리는 작업 중 하나 입니다. 🤯 \n하지만 이렇게 시나리오를 꼼꼼하게 작성해두고 작업을 하니 실수 없이 안정적인 배포를 할 수 있었습니다.\n배포 과정에 이슈가 생겼을 때도 당황하지 않고 대응을 할 수 있었고 이슈 추적을 할 때도 배포 기록이 꼼꼼하게 남아있어 도움이 많이 되었습니다.\n\n그린랩스 제품개발본부가 이렇게 일할 수 있는 것은 형식에 매몰되지 않고 ‘진짜 필요한 것이 무엇인지' 고민해 주는 리더와\n개발자가 지속적으로 성장하고 성취할 수 있게 지지해 주는 동료, 그리고 제품 품질과 일정을 모두 지키려는 열정으로 꾸준히 공부하고 성장하는 동료들이 주변에 많기 때문입니다.\n\n## 마무리\n\n그린랩스는 저를 한층 더 성장할 수 있게 만들어준 소중한 곳입니다. 훌륭한 동료들과 함께 일하며 많은 것을 배우고 있고, 다른 곳에서 쉽게 할 수 없는 클로저로만으로 개발하는 경험을 하고 있습니다.\n그리고, 클로저를 사용하면서 REPL, 불변, 데이터 중심적 사고, 순수 함수, 고차 함수의 소중함 뿐만 아니라 개발의 즐거움까지 느끼고 있습니다.\n\n_Thanks to Rich Hickey~ and Greenlabs_\n\n![그림](https://c.tenor.com/Ls5-aOfqpnEAAAAC/thank-you-thanks.gif)\n\n클로저의 우아함을 맛보고 그린랩스의 훌륭한 동료분들과 일할 기회를 놓치지 마세요!\n","excerpt":"안녕하세요. 신선하이 백엔드 개발자 차민철입니다. 그린랩스에 입사한지 이제 막 1년이 지나 그간의 경험을 공유해보려고 합니다. 입사 전\n\n입사 전부터 함수형 프로그래밍에 관심이 많았었는데요. 이 글을 읽고 계실 여러분처럼 실제로 현업에서 함수형 언어를…","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","tags":[{"name":"Greenlabs","slug":"greenlabs"},{"name":"Clojure","slug":"clojure"},{"name":"experience","slug":"experience"}]},{"slug":"/is-clojure-hard-to-read","title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022년 6월 17일","body":"\n<Author\n  email=\"bakyeono@gmail.com\"\n  name=\"박연오\"\n  description=\"프로그래머/개구리 애호가\"\n  date=\"2022-06-17\"\n/>\n\n> 이 글은 2022 송파 클로저 밋업 행사의 발표입니다. 유튜브에서 비디오를 볼 수 있습니다.\n\n- [{'<'}발표 보기{'>'}](https://www.youtube.com/watch?v=2bIpCf53x6w)\n\n<iframe\n  width=\"560\"\n  height=\"315\"\n  src=\"https://www.youtube.com/embed/2bIpCf53x6w\"\n  title=\"YouTube video player\"\n  frameborder=\"0\"\n  allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n  allowfullscreen\n></iframe>\n\n여러분 안녕하세요? 소중한 금요일 저녁 시간에 클로저 밋업에 참석해주셔서 감사합니다. “클로저 코드는 정말 읽기 어려운가?”라는 주제로 발표를 맡았습니다. 발표 주제의 이름을 잘못 지은 것 같기도 합니다. \"클로저 코드는 왜 이렇게 읽기 쉬울까?\"라고 했으면 더 좋았을 것 같네요. 클로저가 어렵다는 편견이 있는 편인데, 그렇지 않다는 걸 말씀드리려고 합니다.\n\n## 리스프(LISP)\n\n클로저는 리스프라는 프로그래밍 언어의 한 방언입니다. 리스프는 1958년에 처음 나온, 무려 64년이나 된 옛날 언어입니다. 리스프는 항상 새로운 아이디어로 가득한 혁신적인 언어였습니다. 하지만 리스프의 방언들은 인기가 높지는 않습니다. 그 이유가 뭘까요?\n\n리스프가 배우기 어렵고 코드를 읽기 어렵기 때문이라는 주장을 종종 들어요. 이런 주장에는 두 가지 가정이 있는데요, 하나는 언어의 인기가 언어의 내재적인 특성에 근거한다는 가정입니다. 두번째 가정은 리스프가 어렵다는 것입니다.\n\n저는 이런 가정에 동의하지 않습니다. 먼저, 언어의 인기에는 언어의 특성보다는 외부적인이 더 영향이 커요. 예를 들어, 에스페란토보다는 영어가 훨씬 널리 쓰입니다. 그건 영어가 에스페란토보다 더 쉽기 때문이 아닙니다. 최근에 외국인들 사이에서 한국어의 인기가 높아졌고, 1980년대에 나온 파이썬이 최근에야 널리 사랑받게 되었죠. 이 또한 한국어나 파이썬이 갑자기 전보다 쉬워졌기 때문이 아닙니다. 언어를 둘러싼 사회적 배경이 더 중요하죠.\n\n## Write-only Language?\n\n리스프를 놀리는 말 중에 '쓰기 전용'이라는 말이 있어요. 코드 작성자도 코드를 못 읽는다는 거죠.\n\n![그림](img2.png)\n\n“유지보수하기 어렵게 코딩하는 방법”이라는 책이 있는데요 나쁜 코딩 스타일을 반어법으로 소개하는 재미있는 책입니다. 이 책은 반쯤은 유머로 이루어져 있는데요. 리스프로 환상적으로 읽기 어려운 코드를 작성할 수 있다고 소개하는 내용이 있습니다.\n\n![그림](img3.png)\n\n그런데 이 코드는 읽기가 매우 어려운 게 사실입니다. 이건 일부러 읽기 어렵게 짠 코드이니까요. 하지만 일부러 읽기 어렵게 만든다면, 다른 프로그래밍 언어로도 읽기 어려운 코드를 만들 수 있습니다.\n\n```text\n(function(_0x26ea4d,_0x1a7432){var _0x32fcab=_0x4ac1,_0x459153=_0x26ea4d();while(!![]){try{var _0x3aa247=-parseInt(_0x32fcab(0x188))/0x1+parseInt(_0x32fcab(0x187))/0x2*(parseInt(_0x32fcab(0x18d))/0x3)+parseInt(_0x32fcab(0x18b))/0x4*(-parseInt(_0x32fcab(0x18c))/0x5)+-parseInt(_0x32fcab(0x18a))/0x6*(parseInt(_0x32fcab(0x186))/0x7)+-parseInt(_0x32fcab(0x189))/0x8+parseInt(_0x32fcab(0x18f))/0x9+parseInt(_0x32fcab(0x18e))/0xa;if(_0x3aa247===_0x1a7432)break;else _0x459153['push'](_0x459153['shift']());}catch(_0x4b5609){_0x459153['push'](_0x459153['shift']());}}}(_0x1a2d,0xb965f));function hi(){var _0x3abc24=_0x4ac1;console[_0x3abc24(0x190)]('Hello\\\\x20World!');}function _0x4ac1(_0x4ed394,_0x61ef96){var _0x1a2de4=_0x1a2d();return _0x4ac1=function(_0x4ac138,_0x495466){_0x4ac138=_0x4ac138-0x186;var _0x2f2dbd=_0x1a2de4[_0x4ac138];return _0x2f2dbd;},_0x4ac1(_0x4ed394,_0x61ef96);}hi();function _0x1a2d(){var _0x8ac2fc=['24304ySzTVX','286370zkQpmn','9621232DxRZqZ','1050888RPzHkL','930156jIVjDv','15ICQjgj','183oGpdZN','13070690XlMPPp','11231883UJewfa','log','14jghHbE'];_0x1a2d=function(){return _0x8ac2fc;};return _0x1a2d();}\n```\n\n코드를 읽기 어렵게 만들어주는 “난독화”프로그램도 있죠. 이 코드는 자바스크립트 코드를 난독화한 것인데, 자바스크립트 전문가가 읽기에도 난해할 겁니다. 리스프는 이런 놀림의 대상이 될 때가 종종 있어요. 저도 이런 유머를 좋아해요. 하지만 유머는 유머일뿐인 것이지, 그게 꼭 사실은 아닐 수도 있어요.\n\n```text\n(-> 1000\n    inc\n    (+ 500)\n    -\n    str)\n```\n\n그런데 클로저를 처음 접하는 분들이 보기에는 이 코드처럼 정상적인 클로저 코드도 난독화된 코드와 비슷하게 어렵게 보일 수도 있습니다. 그건 우리 뇌가 낯선 것과 어려운 것을 혼동하기 때문입니다. 리스프를 배울 때는 코드의 모양도 다르고 새로운 개념도 많습니다. 이전에 배운 언어와 다른 점이 많습니다. 하지만 리스프와 클로저를 배울수록, 그 낯선 것들이 오히려 코드를 더 쓰고 읽기 쉽게 해준다는 걸 알게 됩니다.\n\n## 애리티(arity)\n\n애리티라는 개념이 있습니다. 어떤 연산자나 함수가 취할 수 있는 인자의 개수를 뜻합니다.\n\n| 애리티                | 예                  |\n| --------------------- | ------------------- |\n| 단항 연산자 (unary)   | `! x`               |\n| 이항 연산자 (binary)  | `x + y`             |\n| 삼항 연산자 (ternary) | `condition ? x : y` |\n| 무항 연산자 (nullary) | _?_                 |\n| N항 연산자 (N-ary)    | _?_                 |\n\nC 언어의 연산자 중 몇 가지를 애리티에 따라 분류해 보았는데요. 단항 연산자로는 부정 연산자, 증가 연산자 등이 있습니다. 이항 연산자는 and, or, 더하기, 나누기 등이 있습니다. 그리고 조건부 식 연산자는 삼항 연산자죠.\n\n그렇다면, 인자가 아예 없거나, 인자가 여러개인 N항 연산자도 생각해볼 수 있지 않을까요? 이런 연산들은 어떻게 표기해야 할까요?\n\n### 연산자의 모양\n\n> \"형태는 기능을 따른다.\" - 루이스 설리반\n\n![그림](img4.png)\n\n수학 연산자들은 일찍부터 형태가 정해졌습니다. 이러한 기존 형태에서는 넣을 수 있는 인자의 수가 제한적이어서, 가변적인 N항 연산자를 표현할 수가 없습니다.\n\n![그림](img5.png)\n\n프로그래밍 언어들은 연산자로 표현할 수 없는 N항의 연산을 위해 함수를 사용하고 있습니다. 함수의 형태에서는 취할 수 있는 인자의 개수가 제한되지 않습니다. 0개부터 N개까지 가변적인 애리티를 가질 수 있어요. 형태만 본다면, 함수는 연산자의 일반적인 표기법이라고 할 수 있습니다.\n\n## S-식(S-expression)\n\n리스프에서는 이 함수의 형태을 응용한 S-식이라는 형식으로 연산자를 표기합니다.\n\n```\n(연산자 인자1 인자2 인자3 ... 인자N)\n```\n\n괄호를 열고, 연산자를 가장 앞에 적고, 인자들은 그 뒤에 나열합니다.\n\n| 연산자      | C                   | 클로저               |\n| ----------- | ------------------- | -------------------- |\n| 단항 연산자 | `! x`               | `(not x)`            |\n| 이항 연산자 | `x + y`             | `(+ x y)`            |\n| 삼항 연산자 | `condition ? x : y` | `(if condition x y)` |\n\nS-식에서는 단항 연산자, 이항 연산자, 삼항 연산자의 표기법이 모두 동일합니다. 연산자 자리에 함수를 대신 넣어도 돼요, 사실 리스프에서는 연산자와 함수가 같은 것입니다.\n\nS-식은 흔히 알려진 것처럼 그렇게 생소한 것이 아닙니다. 사실, 다른 언어의 함수 호출과 거의 똑같은 형태입니다.\n\n| 파이썬              | 클로저                  |\n| ------------------- | ----------------------- |\n| `abs(x)`            | `(abs x)`               |\n| `map(f, sequence)`  | `(map f sequence)`      |\n| `f4(f3(f2(f1(x))))` | `(f4 (f3 (f2 (f1 x))))` |\n\n이 표는 파이썬과 클로저를 비교한 것인데요, 보다시피 여는 괄호의 위치만 다를 뿐 표기법이 거의 똑같죠.\n\n리스프에서는 함수와 연산자가 같습니다. 모양도 같고, 실행하는 방식도 같습니다. 이처럼 규칙에 일관성이 있으면 더 쉽습니다.\n\n### 가변 애리티\n\nS-식에는 몇가지 장점이 더 있습니다. S-식에서는 하나의 연산자가 가변적인 애리티를 가질 수 있습니다.\n\n![그림](img6.png)\n\n이 예는 클로저의 + 함수인데요. 원래는 + 연산자는 이항 연산자로서 애리티가 2로 고정되어 있습니다. 하지만 클로저에서는 보다시피 인자가 0개인 경우, 1개인 경우, N개인 경우가 모두 가능합니다.\n\n가변 애리티를 활용하면 비교 연산자도 두개가 아니라 한꺼번에 여러 개의 인자를 받을 수 있고, 여러 값들을 비교할 수 있습니다. and 연산자도 여러 개의 인자를 취하여, 식들이 모두 참인지 확인할 수 있습니다.\n\n![그림](img7.png)\n\n그런데 마지막의 and 예는 조금 읽기가 어려워 보입니다. 인자가 많다보니 연산에 들어가는 인자가 무엇무엇인지 한눈에 들어오지 않습니다.\n\n![그림](img8.png)\n\n인자가 많거나, 코드가 길어질 때는 인자들 사이를 개행해주면 가독성이 좋아집니다.\n\n### 평가 우선순위\n\nS-식에서는 연산자의 평가 우선순위에 대해 신경쓸 필요가 없습니다. 모든 연산이 괄호로 싸여 있고, 괄호만 보면 무엇이 어떻게 결합해서 평가될지 알 수 있으니까요.\n\n![그림](img9.png)\n\n이 예는 둘 다 윤년을 검사하는 식입니다. C 언어에서는 연산자 우선순위를 정확히 알아야 코드를 읽을 수 있죠. 하지만 클로저에서는 모든 연산이 괄호로 싸여있기 때문에, 우선순위에 대한 고민을 할 필요가 없어요.\n\n지금까지 S-식의 장점을 살짝 둘러봤습니다. 리스프는 쓸데없이 괄호가 많은 오래된 언어라는 놀림을 받곤 합니다. 하지만 사실은, 이러한 형태에는 그 형태가 따르는 기능이 있는 것입니다. 사실 S-식이 정말 가치있는 이유는 S-식에서 \"코드가 곧 데이터이고, 데이터가 곧 코드이다\"라는 것인데, 이 미친 놀라운 특징은 앞으로 클로저를 더 탐구하게 되실 여러분이 직접 맛보실 기쁨으로 남겨두겠습니다.\n\n## 코드를 읽는 흐름\n\n이번에는 약간 다른 측면을 살펴보겠습니다. 여기 서로 다른 나라의 글들을 가져와 보았는데요.\n\n![그림](img10.png)\n\n왼쪽은 한문으로 쓴 훈민정음, 가운데는 아랍어로 쓴 쿠란, 오른쪽은 라틴어로 인쇄한 창세기입니다. 혹시 이 글들에 공통점이 있다는 걸 눈치채셨나요?\n\n한문은 위에서 아래로 읽고, 아랍어은 오른쪽에서 왼쪽으로, 라틴어는 왼쪽에서 오른쪽으로 읽습니다. 언어에 따라서 가로로든, 세로로든, 방향의 차이는 있지만, 우리 언어는 글을 선형으로 읽고 쓴다는 공통점이 있습니다.\n\n그런데 프로그래밍 언어는 선형으로 읽는 방식이 아닙니다.\n\n![그림](img11.png)\n\n첫번째 코드는 왼쪽에서 오른쪽으로 읽는 코드인데요, 아래쪽 코드처럼 안에서 밖으로 읽어야 되는 코드도 있어요. 함수 호출을 하면 안쪽에서부터 코드가 실행되니까요. 프로그램 코드에는 이런 코드들이 마구 뒤섞여 있죠.\n\n우리는 글을 읽을 때 한쪽 방향으로 읽는 것에 익숙하기 때문에, 이렇게 글을 읽는 흐름이 여러 방향으로 섞이면 읽기가 어렵습니다. 이런 문제는 클로저만이 아니라 함수 호출 기능이 있는 다른 프로그래밍 언어에도 똑같이 있어요.\n\n### 스레딩 매크로\n\n클로저는 이 문제를 해결하는 도구를 제공합니다. 스레딩 매크로라는 녀석이예요.\n\n![그림](img12.png)\n\n스레딩 매크로를 이용하면 안에서 밖으로 읽는 코드를, 좌에서 우로 읽도록 작성할 수 있어요.\n\n![그림](img13.png)\n\n이 두 코드는 같은 연산식인데요. 왼쪽 코드는 함수를 어디서부터 읽어야 할지 약간 헷갈립니다.\n\n하지만 오른쪽 코드는 1000에서 시작하고, inc라는 함수로 값을 1 증가시키고, 500을더하고, 음수로 바꾸고, 문자열로 바꾼다는 순서를 바로 알 수 있습니다.\n\n다른 언어에서도 이 문제를 해결하기 위해 메서드 체인 같은 기법을 이용하기도 합니다. 메서드 체인은 특정 타입의 객체와 메서드로만 수행할 수 있지만, 스레딩 매크로는 어떤 데이터에 대해서든, 어떤 연산자나 함수로도 수행할 수 있어 더 일관성이 있습니다.\n\n## 재귀 (recursion)\n\n리스프는 재귀를 적극적으로 사용하는 언어입니다. 그런데 재귀 때문에 리스프를 좋아하지 않는 분도 계시지 않을까합니다. 재귀에 대해서 막연히 어렵게 느끼시는 분들이 많으시거든요. 하지만 재귀는 수학적 귀납법으로 정의한 식을 코드로 간단히 옮길 수 있게 해줘요. 그런 용도로 쓰면 쉽고 우아한 코드를 짤 수 있어요.\n\n재귀에 대한 자세한 내용을 다룰 수는 없고, 클로저로 연결 리스프를 만드는 예를 간단하게 살펴보겠습니다.\n\n### 리스트 잇기 (cons)\n\n리스프에서는 cons라는 함수로 연결 리스트를 만듭니다. cons는 첫번째 인자로 리스트에 추가할 요소를, 두번째 인자로 다른 연결 리스트를 입력받아요.\n\n![그림](img14.png)\n\n리스트를 처음 만들 때는 두번째 인자에 그냥 nil을 넣습니다. 이렇게 (cons 1 nil)을 평가하면, 원소가 1만 들어있는 리스트가 되고요.\n\n![그림](img15.png)\n\n여기에 다른 요소를 추가하려면, cons를 한번 더 붙이면 돼요. 이렇게 2를 추가해주면, (2 1)이 되죠.\n\n![그림](img16.png)\n\n또 한번 더 하면, (3 2 1)이 됩니다.\n\n![그림](img17.png)\n\n이런식으로 cons을 계속 덧붙여서 연결 리스트를 계속 이어만들 수 있어요.\n\n![그림](img18.png)\n\n그러면 재귀와 cons를 이용해서, 무한한 자연수의 시퀀스를 정의해 보겠습니다.\n\n![그림](img19.png)\n\n자연수의 시퀀스는 첫번재 요소가 0이고, 그 다음 요소는 이전 요소에 1을 더한 수이다. 이렇게 재귀적으로 자연수의 시퀀스를 정의해 보았어요. 이렇게 하면 연쇄적으로 시퀀스의 모든 요소를 구할 수 있겠죠.\n\n이것을 연결 리스트를 만드는 cons로 옮기면 아래쪽 코드처럼 될 겁니다. cons 0 cons 1 cons 2 cons 3 ... 하면서 계속 이어지는 거죠. 물론, 리스트의 요소를 직접 다 나열할 수가 없습니다. 그래서 이를 자기 참조 구조, 즉 재귀로 정의합니다.\n\n![그림](img20.png)\n\ncons의 첫번째 원소는 n이 되고요, 그리고 cons의 두번째 원소로는 리스트를 넣어야 되는데, 무한 자연수 리스트를 만드는 함수, 그러니까 지금 정의하고 있는 함수를 호출해서 넣어줍니다. n에 1을 증가 시켜서요.\n\n![그림](img21.png)\n\n그리고 이 함수에 0을 넣어서 실행하면 재귀적으로 무한한 리스트가 만들어집니다. 자연수의 무한 시퀀스를 만들었네요.\n\n![그림](img22.png)\n\n그러면 실제로 호출을 해볼 건데요, 무한한 시퀀스를 한꺼번에 다 가져오면 스택 오버플로 에러가 날 겁니다. 그래서 시퀀스에다가 (take 10)을 적용해서 처음 열 개의 요소만 구하도록 합니다.\n\n하지만 실제로 실행해보면, 역시나 스택 오버플로 에러가 발생하게 됩니다. take 10을 하기 전에 무한한 시퀀스를 끝까지 만들기 때문입니다.\n\n### 지연 시퀀스 (lazy-seq)\n\n이 문제를 해결하려면, 리스트를 필요한 데까지만 계산하는 방법이 필요합니다. 그래서 클로저는 지연 시퀀스라는 도구를 제공합니다.\n\n지연 시퀀스는 시퀀스의 각 요소들을 계산하지 않고 미루고 있다가, 요소를 정말로 써야할 때, 딱 필요한 그 요소까지만 비로소 계산하여 구해줍니다.\n\n![그림](img23.png)\n\n클로저에서 지연 시퀀스를 만들려면 리스트를 lazy-seq로 감싸주면 됩니다. 이런 식으로 cons 앞에 lazy-seq 로 한번씩 감싸주는 거죠.\n\n![그림](img24.png)\n\n그러면 원래 정의했던 무한 시퀀스 함수에, lazy-seq를 넣어봅니다. cons 를 lazy-seq로 감싸기만 하면 되죠.\n\n![그림](img25.png)\n\n이렇게 무한 시퀀스를 지연 시퀀스로 정의해놓으면, 필요한 데까지만 평가해서 값을 구할 수 있습니다. 이제 스택 오버플로가 발생하지 않아요.\n\n이렇게 클로저에서 재귀를 이용하는 방법을 알아보았습니다. 참 쉽죠?\n\n흐음...\n\n하지만 \"이것도 어렵다! 불편하다! 리스트? 클로저? 그딴 건 역시 못해 먹을 물건이군!\"이라고 생각하시는 분들도 계실 겁니다.\n\n## 시퀀스 추상 (sequence abstraction)\n\n저는 그 불편한 느낌이 정당하다고 생각해요. 다행히도 클로저에서는 우리가 재귀를 직접 써야 하는 경우가 거의 없어요. 클로저에서는 여러가지 반복되는 패턴들을 시퀀스 라이브러리를 이용해서 추상화해두었기 때문이에요. 실제로 그린랩스의 프로덕션 코드에는 재귀를 직접 작성한 경우가 단 한 곳도 없습니다!\n\n앞에서 작성했던 자연수의 무한 시퀀스는 (iterate inc 0) 이라는 시퀀스 함수를 사용해서 간단히 나타낼 수 있어요.\n\n![그림](img26.png)\n\n이 둘은 똑같이 무한한 자연수의 시퀀스를 만들어냅니다.\n\n![그림](img27.png)\n\niterate는 함수와 초깃값을 인자로 받아, 초깃값에 함수를 재귀적으로 적용하는 무한 지연 시퀀스를 만들어줍니다.\n\niterate 함수를 이용하면 재귀가 훨씬 더 쉽게 느껴지죠. 왜일까요? 앞에서 재귀 시퀀스를 직접 작성했을 때 어렵게 느껴졌던 이유는, 재귀 과정에서 발생하는 ‘패턴’을 프로그래머가 직접 작성해야 했기 때문이에요.\n\n> 프로그래밍이란,\n> 문제와 무관한 요소들을 모두 배제할 때,\n> 정복하지 못한 복잡성을 피하고,\n> 여러 고려사항들을 매우 격렬하게 분리할 수 있는,\n> 가장 효율적인 사고방식 --\n> 그 이상도 그 이하도 아닌 바로 그것이다. - 데이크스트라\n\n데이크스트라는 GOTO 문으로 반복 패턴을 짜는 걸 비판했고, 우리는 이제 GOTO를 이용해 패턴을 직접 작성하는 대신에 while, for, 서브루틴(함수), throw-catch 등을 사용하죠. 하지만 패턴은 여전히 많습니다.\n\n> 나는 프로그램 안에서 패턴을 발견하면\n> 그것을 뭔가 문제가 발생하고 있다는 신호로 받아들인다.\n> 프로그램의 형태는 오직 그것이 해결해야 하는 문제만 반영해야 한다.\n> 코드에 존재하는 그 밖의 모든 정형성은\n> 내가 충분히 강력하지 않은 추상을 이용하고 있다는 신호로 다가온다. - 폴 그레이엄\n\n프로그램이 다루는 건 문제 그 자체에 대한 것이어야지, 문제 외의 요소가 끼어들어서 프로그램을 복잡하게 만들어서는 안 됩니다. 코드를 짤 때 어떤 패턴이 반복적으로 나타나고, 프로그래머가 그 패턴을 직접 제어해야 한다? 그건 문제 밖의 요소입니다. 그건 원래 프로그래밍 언어가 기능으로 제공해주어야 하는 부분인데, 개발자가 패턴을 짜고 있다는 건, 언어가 할 일을 프로그래머가 대신하고 있는 걸 뜻해요.\n\n![그림](img28.png)\n\n앞의 예를 다시 살펴보면, 문제의 본질은 기저값 0과 귀납 함수 inc입니다. 그리고 그 함수를 반복적으로 적용하여 시퀀스를 만든다는 것이 핵심이죠. 그런데 지연 시퀀스를 재귀적으로 만드는 게 프로그래밍에서 자주 나타내는 패턴인 거고, 그걸 함수로 추상화해놓으면 프로그래밍이 훨씬 쉬워집니다. 패턴을 제거하면 불필요한 복잡성이 없어지고, 문제의 핵심인 0과 inc만 남습니다.\n\n클로저에는 프로그래밍에서 자주 발견되는 여러 가지 패턴들을 시퀀스 라이브러리라는 형태로 일반화 했습니다. 프로그래밍 클로저라는 책에 실린 예제를 한번 살펴보겠습니다.\n\n```text\npublic class StringUtils {\n  public static boolean isBlank(String str) {\n    int strLen;\n    if (str == null || (strLen = str.length()) == 0) {\n      return true;\n    }\n    for (int i = 0; i < strLen; i++) {\n      if ((Character.isWhitespace(str.chatAt(i)) == false)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n```\n\n이 자바 코드는 아파치 커먼스 라이브러리에서 가져온 모범 코드입니다. 문자열이 비어 있거나 공백 문자만으로 되어 있는지 검사하는 함수네요. for 문 안에서 문자열을 순회하면서 공백 문자를 검사하고 있어요. 코드 전체가 클래스 안에 정의되어 있기도 합니다. 그런데 제가 보기에는 이런 코드는 불필요한 복잡성으로 느껴집니다.\n\n```text\n(defn blank? [s]\n  (every? #(Character/isWhitespace %) s))\n```\n\n클로저 코드에서는 두 줄이면 끝납니다. 함수의 본문은 한줄이네요. 모두 참인가? 각 문자가 공백문자인가? 라는 것으로 정의가 끝입니다. 이처럼 클로저에서는 불필요한 복잡성을 최대한 배제하고, 문제 그 자체에 따르는 필연적인 복잡성만을 다룰 수 있도록 언어에서 많은 지원을 하고 있습니다.\n\n## 지금까지 살펴본 것\n\n- S-식\n  - 연산의 형태를 일반화한다.\n  - 연산이 여러 개의 애리티를 가질 수 있게 한다.\n  - 가변 애리티로 코드가 더 간결해진다.\n  - 연산의 결합이나 우선순위에 대한 고민을 없앤다.\n- 스레딩 매크로\n  - 코드를 읽는 방향을 자연스럽게 만든다.\n- 재귀\n  - 자신을 참조하는 연산이나 데이터 구조를 쉽게 정의한다.\n  - 무한 지연 시퀀스를 만들 수 있다.\n- 시퀀스 추상\n  - 프로그램에서 반복되는 패턴을 간단한 구조로 나누어 제거한다.\n\n지금까지 클로저 코드를 읽기 쉽게 해주는 여러 기능들을 알아봤습니다. 이런 기능들은 처음에는 낯설지만, 배우고 나면 클로저 코드를 더 간단하고 쉽게 쓰고 읽을 수 있게 도와줍니다.\n\n쉽고 어려움을 판단하는 일에는 주관적인 성격이 있지요. 처음 배우는 동안에는 학습 비용이 든다는 측면에서는 어려울 수 있습니다. 하지만 일단 기초를 익힌 후에는, 코드를 읽고 쓰는 노력이 훨씬 덜 들고, 저는 그걸 '쉽다'고 하겠습니다.\n\n### 함수형 언어를 배워야 하는 이유\n\n> \"아동이 숙달한 언어구조는 인지의 기본 구조가 된다.\" - 비고츠키\n\n언어는 사고를 지배합니다. 언어가 없이도 생각을 할 수 있을 것 같지만, 언어를 사용하지 않으면 흐릿한 심상이 떠올랐다 사라질 뿐입니다. 논리적이고 체계적인 사고는 언어를 통해서만 가능하죠.\n\n그래서 언어는 커뮤니케이션의 수단이기만 한 것이 아닙니다. 언어를 정확하고 정교하고 효율적으로 사용하는 것은 우리의 인지, 결정, 행동, 삶에 영향을 끼치는 매우 중요한 문제입니다.\n\n프로그래밍 언어도 마찬가지입니다. 언어는 그냥 프로그램을 만드는 도구일 뿐이고, 아무거나 고르면 된다고 말씀하시는 분들이 많습니다. 튜링 완전성에 대한 이야기라면 맞는 말이겠지만, 문제를 어떻게 풀것인가도 중요하게 생각한다면, 언어도 잘 골라야 합니다. 프로그래밍 언어는 프로그래머의 사고방식과 문제 해결 방법에 큰 영향을 끼치기 때문입니다. 다른 패러다임의 언어를 익히면 새로운 방법으로 사고할 수 있습니다.\n\n> \"인간의 운명은 인간의 수중에 있다.\" - 사르트르\n\n우리는 한국어를 모국어로 사용하고 있죠. 그런데 이 말은 우리가 원해서 선택한 게 아닙니다. 태어나보니 한국어를 쓰는 환경이었던 거죠. 모국어가 무엇이냐는 우리에게 주어진 운명이라고 할 수 있어요.\n\n하지만 인간은 운명을 스스로 개척하는 생물이지 않습니까? 새로운 프로그래밍 언어를 배우는 것은 우리가 직접 선택할 수 있는 운명입니다. 새 프로그래밍 언어를 배우는 데는 수고가 들지만, 처음에 두려워 보이는 것만큼 어렵지는 않습니다. 그리고 새로운 점이 많을수록 얻는 게 더 많습니다.\n\n**오늘부터 운명을 바꾸는 행동을 한번 해보시는 건 어떨까요?**\n\n감사합니다.\n\n## 참고 자료\n\n- [{'<'}프로그래밍 클로저{'>'} 스튜어트 할로웨이 저, 인사이트 출판](https://insightbook.co.kr/book/8)\n- [{'<'}해커와 화가{'>'} 폴 그레이엄 저, 한빛미디어 출판](https://www.hanbit.co.kr/store/books/look.php?p_code=B6957684739)\n- &lt;The Evolution of Lisp&gt; Guy Steele, Richard Gabrieli 저\n","excerpt":"이 글은 2022 송파 클로저 밋업 행사의 발표입니다. 유튜브에서 비디오를 볼 수 있습니다. 발표 보기\n\n여러분 안녕하세요? 소중한 금요일 저녁 시간에 클로저 밋업에 참석해주셔서 감사합니다. “클로저 코드는 정말 읽기 어려운가?”라는 주제로…","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","tags":[{"name":"Clojure","slug":"clojure"},{"name":"LISP","slug":"lisp"},{"name":"S-expression","slug":"s-expression"},{"name":"threading macro","slug":"threading-macro"},{"name":"recursion","slug":"recursion"},{"name":"lazy sequence","slug":"lazy-sequence"},{"name":"cons","slug":"cons"}]},{"slug":"/greenlabs-clojurians-2022","title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022년 1월 11일","body":"\n2022년 새해를 맞아 그린랩스의 클로저(Clojure) 사용자들을 대상으로 가벼운 설문조사를 진행했습니다.\n응답자는 총 17명이고, 팜모닝 혹은 신선마켓의 백엔드를 개발하시는 분들께서 주로 응답을 주셨습니다.\n\n### Q. 클로저를 사용하기 이전에는 어떤 언어를 주력으로 사용하셨나요?\n\n<br />\n\n![](q1.png)\n업계에서 많이 쓰이는 JavaScript, Java, Python 순으로 결과가 집계됐습니다.\n이어지는 항목에서도 알 수 있듯 기존에 함수형 언어를 사용하다 오신 분은 많지 않았습니다.\n\n<br />\n\n### Q. 직업적으로 개발을 몇 년간 해오셨나요?\n\n<br />\n\n![](q2.png)\n\n약 40%가 5년 이내의 경력을 가지고 있었습니다.\n전체 개발자의 약 1/4은 10년 이상 개발을 해오신 분들로 구성되어 있었습니다.\n\n클로저는 처음이지만 이미 개발 경력이 20년이 넘으시는 분도 있으셨습니다. 기존의 습관을 버리는 것이 쉽지 않겠지만 그래도 도전해보고 싶었다고 하시네요.\n\n<br />\n\n### Q. 그린랩스 이전에 함수형 프로그래밍 경험은 얼마나 있으셨나요?\n\n<br />\n\n![](q3.png)\n\n경험이 **전혀** 없었다고 답한 분이 무려 절반 이상이었으며, 2년 이상 경험한 분들은 1/5 미만이었습니다.\n하지만 아래 질문에서 짐작할 수 있듯, 평소에 개인적인 흥미를 가지고 공부를 해오셨던 분들도 꽤 있으셨습니다.\n\n<br />\n\n### Q. 어떤 계기로 클로저에 관심을 갖게 되셨나요?\n\n<br />\n\n![](q4.png)\n\n그린랩스의 회사 소개 혹은 지인을 통해 관심을 갖게 되셨다는 분들이 가장 많았습니다.\n특히 하루개발 [그린랩스 편](https://www.youtube.com/watch?v=_CtZ8wegTJM)을 많이 꼽았습니다.\n\n크게 놀랍지 않은 사실일지 모르지만, 리습(Lisp)에 관심을 갖고 계시던 분들이 많았습니다.\n경로는 주로 폴 그레이엄의 [해커와 화가](https://en.wikipedia.org/wiki/Hackers_%26_Painters)라는 에세이와\n[SICP(컴퓨터 프로그램의 구조와 해석)](https://mitpress.mit.edu/sites/default/files/sicp/index.html) 였습니다.\n\n<br />\n\n### Q. 클로저 개발에 있어 다음 항목들이 얼마나 중요하다고 생각하시나요?\n\n![](q5.png)\n\n압도적으로 많은 지지를 받은 기능은 \"불변성\", \"함수형 프로그래밍\", \"REPL\" 이었습니다.\n아마 클로저만의 독특한 REPL의 편리함을 기본으로, 불변성과 함수형 프로그래밍이 강력함을 더하기 때문이 아닐까 추측해봅니다.\n\n클로저 REPL이 어떻게 특별한지 궁금하시다면, 함수형 컨퍼런스 liftIO 발표자료 [REPL, 클로저의 수퍼 파워](https://liftio.org/2021/files/sanghyun-kim-ppt.pdf)도 살펴보세요.\n\n클로저는 동시성과 관련한 매우 훌륭한 기능들을 제공하고 있음에도 불구하고, 웹 개발이 주류인 그린랩스에서는 별로 주목받지 못했습니다.\n\n<br />\n\n### Q. 어떤 개발 환경을 이용하시나요?\n\n![](q6.png)\n\nIntelliJ + Cursive 조합이 가장 많은 인기가 있었습니다. 아마 온보딩 과정이 IntelliJ 기반으로 설명되어있기 때문에 주류를 차지한 것으로 보입니다.\n\n손가락의 건강을 포기한 Emacs 사용자가 10%가 넘는 것도 주목할만 합니다. 최근 그린랩스에 합류하신 [기계인간](https://johngrib.github.io/)님을 주축으로 앞으로는 Vim당의 약진도 기대해봅니다.\n\n<br />\n\n### Q. 구조적 편집을 사용하시나요?\n\n<br />\n\n![](q7.png)\n\n클로저는 [S-표현식](https://ko.wikipedia.org/wiki/S-%ED%91%9C%ED%98%84%EC%8B%9D) 언어이기 때문에 괄호 단위로 코드를 편집하게 됩니다.\n이를 구조적 편집(Structural Editing)이라 합니다.\n\n일반적으로 리습 사용자들은 [Paredit](http://danmidwood.com/content/2014/11/21/animated-paredit.html)을 사용하지만,\n단축키를 외우지 않고도 손쉽게 사용할 수 있는 [Parinfer](https://shaunlebron.github.io/parinfer/)도 많이 사용되고 있음을 확인할 수 있었습니다.\n\"사용 안함\"으로 응답하신 분은, 아마도 심각하게 튜닝된 Vim 혹은 Emacs를 사용하고 계시지 않을까 추측해봅니다.\n\n<br />\n\n### Q. 클로저 관련 도움은 주로 어디에서 얻으시나요?\n\n<br />\n\n![](q8.png)\n\n클로저 공식 커뮤니티는 자료도 풍부하고 답변도 빠르지만, 아무래도 영어로 되어있다보니 궁금한 것은 동료에 묻는 경우가 더 많다고 합니다.\n팀 동료와는 질문의 맥락이 공유되고 있는 경우도 많기 때문에, 똑같은 질문을 외부에 하는 것보다 편리하다는 점도 있겠습니다.\n\n<br />\n\n### 클로저와 관련한 자유로운 소감을 들려주세요!\n\n<br />\n\n> 프로그래밍에 대한 생각을 한차원 업그레이드 시켜주는 언어입니다. 무엇보다 재밌어요!\n\n> 재밌고 표현이 좋다. 동적 타입 언어라 빠르게 개발할 수 있다. 커뮤니티나 자료가 적고 불친절한 것은 아쉽다. 레거시 코드를 볼 때 타입이 없어서 힘들다.\n\n> REPL를 이용한 속도감 있는 개발을 즐겁게 하고 있어요!\n\n> 무엇보다 저에게는 가장 재미있는 언어입니다.\n\n> 불변성, 데이터 중심적인 개발, REPL 중독....에서 벗어나기 힘들어요\n\n> 데이터 위주로 사고하는 것이 정말 좋으며, 데이터의 표현도 간결해서 마음에 듭니다!\n\n> 재밌고 신선합니다.\n\n> 생산성은 좋다. 자료가 많이 없어서 아쉽다.\n\n> 알고나면 심플한 언어인데 생각보다 초기 러닝 커브가 가파릅니다. 기존의 대다수 개발자 분들이 자바나 C계열 언어에 익숙해져 있어 패러다임 전환이 쉽지 않구요.\n\n> 클로저는 저에게 포스트잇 같습니다. 필요할 때에는 견고하게 붙으면서 필요하지 않을 때 떼어내면 자국 없이 말끔하게 떼어집니다. 다른 언어를 사용할 때에는 사이드 이펙트에 유의하면서 개발했었는데요. 그런 구린 느낌이 없이 말끔했습니다. 그래서 포스트잇 같았습니다.\n\n<br />\n\n공통적으로 \"재밌다\" 라는 표현이 많이 보였습니다.\n저에게도 클로저는 프로그래밍의 즐거움을 되찾게 해준 언어였기에 공감이 되었습니다.\n\n혹시 이 글을 보고 클로저에 관심이 생기셨다면, 새해에는 REPL과 함께 해보는 것은 어떨까요? 😃\n\n<br />\n\n#### 참고자료\n\n- [클로저, 지금 바로 시작합시다!](/start-your-clojure-project-now-1)\n- [그린랩스에서 클로저 시작하기](clojure-bootcamp)\n- [클로저 소개 강의](https://www.slideshare.net/SangKyuPark1/ss-18350615)\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"hw.nam@greenlabs.co.kr\"\n  name=\"남현우\"\n  description=\"소프트웨어 엔지니어\"\n  date=\"2022-01-11\"\n/>\n","excerpt":"2022년 새해를 맞아 그린랩스의 클로저(Clojure) 사용자들을 대상으로 가벼운 설문조사를 진행했습니다. 응답자는 총 17명이고, 팜모닝 혹은 신선마켓의 백엔드를 개발하시는 분들께서 주로 응답을 주셨습니다. Q. 클로저를 사용하기 이전에는 어떤…","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","tags":[{"name":"Clojure","slug":"clojure"},{"name":"survey","slug":"survey"}]},{"slug":"/the-macro","title":"클로저 매크로에 대해 알아보자","date":"2021년 11월 22일","body":"\n## 매크로에 대한 기억\n\n어린 시절 즐기던 게임에서는 레벨 업을 위해 지루한 반복 사냥을 해야 할 때가 많았습니다. 제 친구 중 몇 명은 매크로 프로그램을 이용해 반복 사냥을 컴퓨터가 대신하게 했습니다. 매크로를 이용하면 캐릭터가 어떤 방향으로 공격을 하게 하거나, 몇 분에 한 번씩 아이템을 사용하도록 하는 등 일련의 작업을 자동으로 실행할 수 있었습니다. 이처럼, '매크로'란 미리 정해놓은 명령을 자동으로 실행하여 단순 반복 작업을 줄이는 기능입니다. 그런데 프로그래밍에서도 따분한 반복 작업을 해야 하는 경우가 있습니다. 프로그래밍 언어에는 일정한 문법과 규칙이 있기 때문입니다. 예를 들어, 자바에서 새 객체를 만들려면 다음과 같은 절차를 반드시 따라야 합니다.\n\n1. `class` 키워드로 클래스를 정의한다.\n2. `new` 키워드로 객체를 생성한다.\n\n이 두 문장은 뒤바뀔 수 없습니다. 둘 중 하나의 행위만으로는 객체를 만들 수 없죠. 프로그래밍 언어의 문법의 틀을 당연시한다면 생각은 그와 유사한 방식으로만 상상할 수밖에 없다고 생각합니다. 클로저(Clojure)의 매크로는 주어진 규칙을 허무는 데 도움을 줄 것입니다.\n\n## 프로그래밍 언어의 매크로\n\n### C 언어의 매크로\n\n클로저의 매크로에 관해 알아보기 전에, 더 많은 분들이 알고 계실 C 언어의 매크로를 잠시 살펴봅시다.\n\n```c\n#include <stdio.h>\n\n#define CUBE_MACRO(n) n*n*n\n\nint main()\n{\n  printf(\"%d\", CUBE_MACRO(1+2));  // 1+2*1+2*1+2 -> 7\n  return 0;\n}\n```\n\n위 코드에서는 `#define` 전처리 명령으로 n을 세제곱하는 `CUBE_MACRO`라는 매크로 함수를 정의했습니다. `CUBE_MACRO` 매크로는 일반 함수를 호출하는 것처럼 사용할 수 있습니다. 한편, 아래의 코드에서는 `CUBE_MACRO` 매크로의 `n*n*n`과 동일한 식을 일반 함수 `cube_func()`로 정의했습니다.\n\n```c\n#include <stdio.h>\n\nint cube_func(int n)\n{\n  return n*n*n;\n}\n\nint main()\n{\n  printf(\"%d\", cube_func(1+2));  // 3*3*3 -> 27\n  return 0;\n}\n```\n\n이 두 코드는 동일한 일을 하는 것 같지만, 결과 값이 다릅니다.[[2]](#ref-2)[[3]](#ref-3) `CUBE_MACRO`는 `7`이 출력되며, `cube_func`는 `27`이 출력되었습니다. C언어 매크로는 기호(여기서는 `1+2`)를 다른 기호로 치환한 뒤, 코드를 컴파일하고 실행합니다. 함수는 이미 코드가 컴파일 된 상태에서, 기호를 값으로 평가한 후에(`2+1 -> 3`) 실행합니다. 컴파일 전에는 `1+2`라는 코드가 `3`이라는 값으로 평가되지 않으므로, `n*n*n`은 `3*3*3`이 아니라 `1+2*1+2*1+2`로 치환됩니다. 따라서 매크로 함수와 일반 함수의 실행 결과에 차이가 생기는 것입니다. C 언어의 매크로는 이처럼 코드 자체를 변경하며, 이를 이용하면 제한적으로나마 기존 언어에서 정한 규칙의 선을 넘을 수 있습니다.\n\n## 클로저 매크로\n\n클로저 매크로도 C언어 매크로와 비슷하지만, 단순히 문자열 치환이 아닙니다. 코드를 프로그래밍하는 것에 가깝습니다. 코드를 치환한다는 점에서 클로저의 매크로는 C언어 매크로와 비슷하지만, 리스프 계열 언어의 특징인 동형성으로 특별해집니다. [[4]](#ref-4)[[5]](#ref-5)[[6]](#ref-6)\n\n### 동형성\n\n클로저는 리스프 계열 언어입니다. 리스프(LISP)라는 이름은 \"리스트 처리(LISt Processing)\"에서 딴 것입니다. 그 이름에서도 짐작할 수 있듯이, 연결 리스트(linked list)가 리스프의 핵심 자료구조입니다. 심지어 코드 자체도 리스트로 구성할 정도이죠. 그래서 클로저에서는 코드가 리스트 자료구조와 같은 방식으로 표현·저장됩니다. 코드를 변경하는 것이 리스트를 변경하는 것과 똑같은 일입니다. 클로저에서는 소괄호 안에 요소들을 나열하는 방식으로 리스트를 표기합니다. 다음 두 코드는 각각 자바와 클로저로 리스트를 표현한 것입니다.\n\n```java\nList.of(1,2,3,4)\n```\n\n```clojure\n(list 1 2 3 4)  ;; (1 2 3 4)\n```\n\n클로저에서는 식을 계산하거나 함수를 호출할 때 코드를 리스트로 작성합니다.\n\n```clojure\n(+ 1 2)\n(* 2 3)\n(/ 3 4)\n\n(println \"Hello, Clojure\")\n```\n\n함수 정의도 마찬가지입니다.\n\n```clojure\n(defn hello-world [name]\n  (println (str \"Hello, \" name)))\n\n(defn add1 [number]\n  (+ 1 number))\n```\n\n코드가 리스트 자료구조로 구성되어 있으므로, 코드를 다른 리스트를 조작할 때와 똑같이 조작할 수 있습니다.\n\n```clojure\n(count (list * 3 3 3)) ;; 4\n(first (list * 3 3 3)) ;; *\n(rest (list * 3 3 3))  ;; (3 3 3)\n(concat (list * 3 3 3) '(5)) ;; (3 3 3 5)\n```\n\n클로저 코드는 소괄호를 적극적으로 활용하여 문법을 최소화하였습니다. 일반적으로 리스트의 첫 번째 요소를 연산자(함수)로, 나머지 요소들을 피연산자(인자)로 취급합니다. 동형성은 매크로를 사용할 때 아주 강력한 힘이 됩니다. 우리는 '코드를 생산하는 코드'를 만들 능력을 얻은 것입니다.\n\n## 클로저 매크로로 문법을 뛰어넘기\n\n> 비아웹(Viaweb) 편집기의 전체 소스 코드 중 약 20%에서 25% 정도가 매크로였다. (중략) 그 프로그램에 포함된 모든 매크로는 꼭 필요해서 넣은 것이다. 이는 이 프로그램 중 최소 20%에서 25%가량의 코드는 다른 언어로는 하기 어려운 일을 하고 있음을 의미한다.\n>\n> - 평균을 넘어서기, 폴 그레이엄(Paul Graham)\n\n다른 언어에서는 구현하기가 몹시 까다로운 문제들을, 클로저의 매크로를 이용하면 평상시의 코딩과 다름없이 간단히 처리할 수 있는 경우가 많습니다. 몇 가지 사례를 소개해 드리겠습니다. 자세한 문법 설명은 생략하겠습니다. 그저 이런 것이 가능하다는 것만 즐겨주시면 좋겠습니다.\n\n### 매크로 맛보기\n\nC언어 매크로 소개 예시와 비슷한 일을 하는 코드를 소개합니다.\n\n```clojure\n;; 매크로 정의\n(defmacro cube-macro [n]\n  (list '* n n n))\n\n(cube-macro 3) ;; 27\n\n;; 함수 정의\n(defn cube-fn [n]\n  (* n n n))\n\n(cube-fn 3) ;; 27\n```\n\nC언어 매크로와는 다르게 함수 정의와 이질감이 없습니다. 그리고 결괏값이 함수 호출과 동일하게 나오는 것도 다릅니다.\n\n### 예제 1 - anaphoric macro\n\nanaphoric은 '앞서 나온 어구'를 지칭할 때 사용합니다. 대명사라고 이해하면 쉬울 것 같습니다. [[9]](#ref-9) if문에서 검사한 값을 그대로 사용하고 싶지는 않으신가요? 자바를 예로 들면 `null`을 관리하기 위해 종종 아래와 같은 코드를 만들 것입니다.\n\n```java\nSomeObject someObject = someMethod(arg1, arg2);\nif (someObject != null) {\n  doSomeThing(someObject);\n}\n// 또는\nOptional<SomeObject> someObjectOption = Optional.ofNullable(someMethod(arg1, arg2));\nif (!someObjectOption.isEmpty()) {\n  doSomething(someObjectOption.get());\n}\n// 또는\nOptional<SomeObject> someObjectOption = Optional.ofNullable(someMethod(arg1, arg2));\nsomeObjectOption.ifPresent(someObject -> {\n  doSomething(someObject);\n}\n```\n\n그렇다면 혹시 이런 것은 가능할까요? `someMethod(arg1, arg2)` 의 결괏값이 `null`이 아니라면 `someMethod(arg1, arg2)`의 리턴문을 `it`이라는 키워드로 직접 사용할 수는 없을까요? 가능한지는 차치하고 새로운 문법을 상상해봅시다. `ifexists`는 값이 `null`이거나 `false`가 아니라면 중괄호 안의 statement를 수행한다고 상상해보죠.\n\n```java\nifexists (someMethod(arg1, arg2)) {\n  doSomething(it);  // it을 someMethod의 리턴값에 바인딩이 가능할까?\n}\n```\n\n이런 코드를 자바에서 만들 수 있을까요? 아뇨, 우리는 이런 코드를 만들 수 없습니다. 예약어들은 정해져있습니다. 우리가 마음대로 추가할 수 없지요. `it`처럼 정의되지도 않은 이름을 바로 쓸 수도 없습니다. 누군가는 '당연히 정의부터 해야지. 순서라는 것이 있잖아.' 라고 생각할지도 모르죠. 하지만 클로저에서는 가능합니다. `aif`, `aand` 라는 매크로를 만들어 보겠습니다.(코드를 이해하실 필요는 없습니다. 가능하다는 것만 느껴주시면 좋겠습니다.)\n\n```clojure\n(defmacro aif [test then else]\n  `(let [~'it ~test]\n     (if `'it ~then ~else)))\n\n(defmacro aand [& body]\n  (cond (nil? body) true\n        (nil? (next body)) (first body)\n        :else `(aif ~(first body)\n                     (aand ~@(rest body))\n                     false)))\n\n(aif 1\n  (inc it)\n  \"Nope\")\n;; 2\n\n(aand 1\n  (inc it)\n  (* 100 it)\n  (= 200 it))\n;; true\n\n(aand 1\n  (inc it)\n  (* 2 it)\n  (= 5 it))\n;; false\n```\n\n`aif`는 첫번째 인자가 `false`, `nil`(자바의 `null`과 비슷)이 아닌경우 `it`에 바인딩되어 사용할 수 있습니다. `aand`는 더 나아가서 함수들을 체이닝해서 수행할 수 있지요. `it`은 이전 함수의 리턴값으로 체이닝됩니다.\n\n### 예제 2 - for-loop문 만들기\n\nClojure에는 for-loop가 없습니다. 하지만 사용하고 싶다면 만들면 됩니다.[[10]](#ref-10)\n\n```clojure\n(defmacro for-loop [[sym init check change :as params] & steps]\n `(loop [~sym ~init value# nil]\n    (if ~check\n      (let [new-value# (do ~@steps)]\n        (recur ~change new-value#))\n      value#)))\n\n(for-loop [i 0 (< i 10) (inc i)]\n  (println i))\n```\n\n마치 새로운 문법이 추가된 것처럼 보이네요!\n\n- 리스트의 첫번째 요소 이름을 두번째 요소의 값으로 정의\n- 리스트의 3번째 요소의 함수가 true 일때까지 재귀를 돈다.\n- 리스트의 4번째 요소는 첫번째 요소에 적용한 값으로 재귀호출한다.\n\n이런 규칙을 단 6줄로 만들 수 있습니다.\n\n### 예제 3 - 간단한 패턴매칭 만들기\n\n위 예제는 매크로가 할 수 있는 일을 보여드리긴 했지만, 너무 작은 변화이기에 쓸모를 못 느낄 수도 있으신 분들을 위한 소개입니다. 클로저는 기본적으로 패턴매칭기능이 없습니다. 하지만 패턴매칭도 필요하면 만들 수 있습니다. 아래의 코드는 다음에 우리가 만들어볼 `my-match`를 사용하는 예시입니다.[[11]](#ref-11)[[12]](#ref-12)[[14]](#ref-14)\n\n```clojure\n(doseq [n (range 1 101)]\n  (println\n   (my-match [(mod n 3) (mod n 5)]\n             [0 0] (str \"FizzBuzz\")\n             [0 _] (str \"Fizz\")\n             [_ 0] (str \"Buzz\")\n             :else n)))\n;; 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ,,,\n```\n\n위 코드는 간단한 FizzBuzz 문제를 우리가 만들 `my-match`를 사용하여 푼 모습입니다. 3의 배수이면 Fizz를 5의 배수이면 Buzz를 3의 배수이며 5의 배수는 FizzBuzz를 출력합니다. 그리고 아무런 배수가 아니면 해당 숫자를 출력합니다. 여기서 특이한 점은 `_` 입니다. 이 값은 하스켈 패턴매칭의 와일드카드처럼 어떤 값이 와도 상관없도록 만듭니다.[[13]](#ref-13) 그리고 심볼 바인딩도 가능하도록 할 것입니다. 아래 예제를 소개합니다.\n\n```clojure\n(doseq [n (range 1 101)]\n  (println\n   (my-match [(mod n 3) (mod n 5)]\n             [0 0] (str \"FizzBuzz with n=\" n)\n             [0 a] (str \"Fizz with a=\" a \", n=\" n)\n             [b 0] (str \"Buzz with b=\" b \", n=\" n)\n             :else n)))\n;; 1\n;; 2\n;; Fizz with a=3, n=3\n;; 4\n;; Buzz with b=2, n=5\n;; Fizz with a=1, n=6 ...\n```\n\n같은 FizzBuzz 문제이지만 이번에는 와일드카드 대신 심볼을 바인딩하였습니다. 각 심볼에 해당하는 값이 바인딩 됩니다. `n`이 3의 배수일 때, 5의 mod 값을 `a`에 바인딩하여 사용할 수 있게 됩니다.\n\n이를 구현한 코드는 아래와 같습니다. (굳이 이해하실 필요는 없습니다. 몇 개의 함수와 매크로로 매턴매칭이 가능하다는 것을 느끼시면 좋겠습니다.)\n\n```clojure\n;; https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8\n(ns pattern-match.diy)\n\n(defn process-vars\n  [vars]\n  (letfn [(process-var [var]\n            (if-not (symbol? var)\n              (gensym \"ocr-\")\n              var))]\n    (vec (map process-var vars))))\n\n(defn make-default-match [vars cs]\n  (let [cs (partition 2 cs)\n        [p a] (last cs) ;; 심볼의 경우 p를 a에 바인딩하는 기능 추가 필요.\n        last-match (vec (repeat (count vars) '_))]\n    (if (= p :else)\n        (conj (vec (butlast cs)) [last-match a])\n        (throw (RuntimeException. \"last match must be :else\")))))\n\n(defn make-pattern-let-binding\n  \"let 바인딩을 위한 자료구조 생성\"\n  [vs vars]\n  (interleave vs vars))\n\n(defn make-cond\n  \"cond predicate을 만들기 위한 비교문\"\n  [vs cls]\n  (map (fn [v c]\n         `(= ~v ~c)) vs cls))\n\n(def backtrack-exception (Exception. \"BackTrack!\"))\n\n(defn catch-error\n  \"예외를 잡는 자료구조 추가\"\n  [& body]\n  `(catch Exception e#\n     (if (identical? e# ~'backtrack-exception)\n       (do\n         ~@body)\n       (throw e#))))\n\n(defn compile-rec\n  \"재귀적으로 try문 안에 있는 비교문을 생성.\"\n  [cnds return]\n  (let [cnd (first cnds)\n        [v c] (vec (rest cnd))] ;; c가 심볼인 경우 v를 바인딩하도록 해야함.\n    (if (seq cnd)\n      (cond\n        (symbol? c)\n        `(let [~c ~v] (do ~(compile-rec (rest cnds) return)))\n\n        (= '_ c)\n        `(do ~(compile-rec (rest cnds) return))\n\n        :else\n        `(do (cond ~cnd ~(compile-rec (rest cnds) return)\n                   :else ~'(throw backtrack-exception))))\n      return)))\n\n(defn match-compile\n  [conds+return]\n  (let [[cnds return] (first conds+return)\n        cnd (first cnds)\n        [v c] (vec (rest cnd))] ;; c가 심볼인 경우 v를 바인딩하도록 해야함.\n    (if (seq cnd)\n      (cond\n        (symbol? c)\n        `(let [~c ~v]\n           (try ~(compile-rec (rest cnds) return)\n             ~(catch-error (match-compile (rest conds+return)))))\n\n        (= '_ c)\n        `(try ~(compile-rec (rest cnds) return)\n           ~(catch-error (match-compile (rest conds+return))))\n\n        :else\n        `(try (cond ~cnd ~(compile-rec (rest cnds) return)\n                    :else ~'(throw backtrack-exception))\n           ~(catch-error (match-compile (rest conds+return)))))\n      return)))\n\n(defmacro my-match\n  [vars & clauses]\n  (let [vs (process-vars vars)\n        cs (make-default-match vars clauses)\n        pattern-let-binding (vec (make-pattern-let-binding vs vars))\n        conds (map (fn [c] [(make-cond vs (first c)) (second c)]) cs)]\n    `(let ~pattern-let-binding\n       ~(match-compile conds))))\n```\n\n기존 함수 정의 및 호출과 동일한 형태의 코드임을 알 수 있습니다. 생성하는 결괏값이 소스 코드인 것만 다릅니다.\n\n만약에 여러분이 사용하는 언어에서 패턴매칭이 없을 때, 여러분은 임의로 이 기능을 추가할 수 있으신가요 아니면 새로운 버전이 나오기를 기다리실 수밖에 없으신가요? 리스프의 매크로라면 여러분이 원하는 것을 무엇이든 손쉽게 만들 수 있습니다. 여러분은 문법에 구애받지 않고 작성할 힘을 갖게 됩니다. [[7]](#ref-7)[[8]](#ref-8)\n\n언어가 여러분을 제약하지 않도록 하세요. 여러분이 언어를 제약하세요.\n\n## 참고문헌\n\n1. 언어는 어떻게 생각하는 방식을 형성하는가\n   - [1] : [how language shapes the way we think](https://www.ted.com/talks/lera_boroditsky_how_language_shapes_the_way_we_think) <a name=\"ref-1\"/>\n2. C 언어 매크로\n   - [2] : [https://www.geeksforgeeks.org/macros-vs-functions/](https://www.geeksforgeeks.org/macros-vs-functions/) <a name=\"ref-2\" />\n   - [3] : [https://stackoverflow.com/questions/9104568/macro-vs-function-in-c](https://stackoverflow.com/questions/9104568/macro-vs-function-in-c) <a name=\"ref-3\" />\n3. 리스프의 이상한 문법\n   - [4] : [http://www.paulgraham.com/weird.html](http://www.paulgraham.com/weird.html) <a name=\"ref-4\" />\n   - [5] : [https://www.defmacro.org/ramblings/lisp.html](https://www.defmacro.org/ramblings/lisp.html) <a name=\"ref-5\" />\n   - [6] : [https://helloworld.kurly.com/blog/y-combinator/](https://helloworld.kurly.com/blog/y-combinator/) <a name=\"ref-6\" />\n4. 리스프 매크로에 대한 논의\n   - [7] : [http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html](http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html) <a name=\"ref-7\" />\n   - [8] : [https://arxiv.org/pdf/1608.02621.pdf](https://arxiv.org/pdf/1608.02621.pdf) <a name=\"ref-8\" />\n5. anaphoric macro\n   - [9] : [onlisp p.189](http://www.paulgraham.com/onlisptext.html) <a name=\"ref-9\" />\n6. for-loop\n   - [https://stackoverflow.com/questions/9981943/how-to-implement-a-for-loop-in-clojure](https://stackoverflow.com/questions/9981943/how-to-implement-a-for-loop-in-clojure) <a name=\"ref-10\" />\n7. 패턴매칭\n   - 패턴매칭 알고리즘 소개 : [https://www.ccs.neu.edu/~types/resources/a-fpca-1985.pdf](https://www.ccs.neu.edu/~types/resources/a-fpca-1985.pdf) <a name=\"ref-11\" />\n   - clojure core.match 라이브러리 : [https://github.com/clojure/core.match](https://github.com/clojure/core.match) <a name=\"ref-12\" />\n   - 하스켈 wildcard 설명 : [https://www.haskell.org/tutorial/patterns.html](https://www.haskell.org/tutorial/patterns.html) <a name=\"ref-13\" />\n   - 직접 구현한 패턴매칭 소스코드 링크 : [https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8](https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8) <a name=\"ref-14\" />\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"ssisksl77@gmail.com\"\n  name=\"남영환\"\n  description=\"백엔드 개발자\"\n  date=\"2021-11-22\"\n/>\n","excerpt":"매크로에 대한 기억 어린 시절 즐기던 게임에서는 레벨 업을 위해 지루한 반복 사냥을 해야 할 때가 많았습니다. 제 친구 중 몇 명은 매크로 프로그램을 이용해 반복 사냥을 컴퓨터가 대신하게 했습니다. 매크로를 이용하면 캐릭터가 어떤 방향으로 공격을 하게…","description":"그만 알아보자","tags":[{"name":"Clojure","slug":"clojure"},{"name":"Macro","slug":"macro"},{"name":"Lisp","slug":"lisp"}]},{"slug":"/rescript-bootcamp","title":"그린랩스에서 리스크립트 시작하기","date":"2021년 10월 29일","body":"\n안녕하세요. 그린랩스 웹 개발팀에서 프론트엔드 엔지니어로 근무하고 있는 김효은입니다.\n\n입사 전에는 타입스크립트 환경에서 서비스를 개발했습니다. 개발자로서 성장 자극을 찾던 중에 '함수형 프로그래밍' 패러다임을 소개하는 온라인 강의를 듣게 되었어요. 순수 함수의 유연함과 간결함에 감탄하며 그동안 당연시했던 고정 관념들을 깨뜨리는 낯선 관점에 빠르게 매료되었습니다.\n\n하지만 기초 이론을 익혔음에도 프로덕션 환경에 적용하기는 쉽지 않았어요. 때마침 풀스택 함수형 프로그래밍으로 실제 서비스를 개발하고 있는 회사- 그린랩스를 알게 되었어요. 함수형 프로그래밍을 위해 비주류 언어로 서비스를 개발하고 있는 것을 보고, 이 회사는 함수형 프로그래밍에 진심이라고 생각했어요. 저의 갈망을 충족시켜 줄 것을 확신하며 입사를 결정했습니다.\n\n그린랩스 프론트엔드 팀에서는 리스크립트(ReScript)와 리스크립트 리액트(ReScript React)를 사용하고 있습니다. 리스크립트는 타입스크립트보다 더 강력한 타입 시스템을 제공하는 함수형 언어이며, 타입스크립트와 마찬가지로 자바스크립트 코드로 트랜스파일할 수 있습니다. 리스크립트 리액트는 리액트를 리스크립트에서 사용할 수 있도록 바인딩한 라이브러리입니다.\n\n이 포스팅에서 간략한 프론트엔드 부트캠프 소개와 리스크립트를 사용하면서 개인적으로 좋았던 점을 공유합니다.\n\n## 부트캠프\n\n그린랩스에 프론트엔드 개발자로 입사하시면 3주 동안의 온보딩 과정- 부트캠프에 참여하실 수 있어요. 부트캠프는 리스크립트 공식 문서를 읽고, \\*Advent of Code 문제들을 풀고, 페어 프로그래밍도 해보고, 코치에게서 리뷰를 받고, 더 멋진 코드로 리팩터링 해보는 과정이예요.\n\n한 주당 문제 세 개씩을 푸는데, 문제를 푸는 과정에서 하루에 한 시간씩 리뷰도 받을 수 있어요. 리뷰 시간에는 부트캠프 코치와 함께 문제 풀이를 살펴보며 더 개선할 방향을 찾을 수 있습니다. 풀이를 슬랙에 공유하면 코치 외의 동료들도 적극적으로 리뷰를 해줍니다.\n\n\\*[Advent of Code](https://adventofcode.com/2020/about): 2015년부터 시작된 12월 1일부터 25일까지 크리스마스를 테마로 진행되는 문제 풀이 행사\n\n## 리스크립트를 사용하면서 좋았던 점\n\n### 패턴 매치로 빈틈 없애기\n\n리스크립트에는 '패턴 매치(pattern match)'라는 기능이 있습니다. 패턴 매치는 데이터의 형태에 따라 적절한 로직을 선택하여 실행하도록 합니다. 이프(if)나 스위치(switch) 같은 선택문과 유사해 보이지만, 데이터가 취할 수 있는 모든 형태를 엄격하게 정의해야 한다는 점이 구별됩니다. 규칙이 컴파일 타임에 강제되므로, 모든 경우를 정의하지 않으면 컴파일 에러가 발생하여 아예 빌드가 되지 않습니다.\n\n프론트엔드 환경은 온갖 비동기 요청과 사용자의 입력이 난무하는 수라도이죠. 우리는 이런 혼란 속에서 의도치 않게 수많은 빈틈을 만들어내곤 합니다. 패턴 매치의 엄격한 점검을 받으면 조그만 구멍조차도 빠트리지 않고 점검할 수 있습니다.\n\n다음은 패턴 매치의 예입니다. ① `state`라는 타입에 '로딩', '성공', '실패'라는 세 가지 상태를 정의했습니다. ② `state` 타입의 상태에 따라 컴포넌트를 올바르게 렌더할 수 있도록, `state` 타입이 가질 수 있는 세 가지 상태에 대한 모든 대응을 구현해야 합니다. ③ 그렇지 않으면 컴파일 에러가 발생합니다.\n\n```rescript\ntype state = Loading | Success | Fail  // ①\n\n// ② 올바름: state 타입의 모든 사례 구현\nswitch state {\n\t| Loading =>  <LoadingComponent />\n\t| Success =>  <SuccessComponent />\n\t| Fail =>  <FailComponent />\n}\n\n// ③ 컴파일 오류: Loading 미구현\nswitch state {\n\t| Success =>  <SuccessComponent />\n\t| Fail =>  <FailComponent />\n}\n```\n\n### 배리언트를 이용하여 타입을 더 구체적으로 선언 가능\n\n배리언트(variant)는 여러가지 타입을 OR(논리합, 합집합)로 결합하는 데이터 구조입니다. 여러가지 타입을 포괄하고자 할 때, 너무 일반적인 타입을 사용하는 대신 배리언트로 구체적인 타입 여러 개를 결합할 수 있습니다. 다음은 한 AoC 문제 풀이에서 값과 단위(inch, cm)로 이루어진 키를 파스하는 사례입니다.\n\n```rescript\n// 원본 텍스트: \"height:165cm\", \"height:65inch\"\n// ① 배리언트를 사용하지 않은 방식\n// height : (165, \"cm\"), (65, \"inch\")\ntype height = (int, string)\n\n// ② 배리언트를 사용하는 방식\n// height : Cm(165), Inch(65)\ntype height = Cm(int) | Inch(int)\n```\n\n① 배리언트를 사용하지 않은 예에서는 키를 정수와 문자열의 튜플 `(int, string)`로 정의했습니다. ② 배리언트를 사용한 방식에서는 키를 센티미터 단위 정수`Cm(Int)`나 인치 단위 정수`Inch(int)`로 정의했습니다. 이처럼 배리언트를 사용함으로써 값의 유형을 더 구체적으로 정의할 수 있습니다.\n\n배리언트를 이용한 타입 정의는 패턴 매칭과 결합할 때 더욱 유용합니다.\n\n```rescript\n// ① 배리언트를 사용하지 않는 방식\nlet (value, unit) = height  // 정수와 문자열의 튜플을 구조분해\nif (unit == 'cm') {\n  ...  // 센티미터 단위 처리\n}\nelse if (unit == 'inch') {\n  ...  // 인치 단위 처리\n}\nelse {\n  ...  // 'cm', 'inch' 가 아닌 경우. 에러 처리\n}\n\n// ② 배리언트를 사용하는 방식\nswitch height {\n\t| Cm(value) => ...  // 센티미터 단위 처리\n\t| Inch(value) => ...  // 인치 단위 처리\n}\n```\n\n배리언트를 사용하지 않을 때는 문자열 비교를 이용하기 때문에 안전하게 하려고 `else`를 추가합니다. 논리상 `else`는 `unit`에서 나올 수 없는 경우이지만 `else`를 정의해야 하기 때문에 에러로 처리합니다. 하지만 배리언트를 사용하면 두 가지의 구체적으로 상태로 한정했기 때문에 `unit`의 의미가 그대로 코드에 적용됩니다. 따라서 그 외 경우(`else`)가 일어나지 않습니다.\n\n배리언트는 유지보수에도 유용합니다. 후에 새로운 단위 피트(Feet)가 추가된다고 생각해봅시다. ①에서는 `unit`이 사용된 부분을 개발자가 직접 찾으며 조건을 추가해야 합니다. 에러가 발생하지 않기 때문에 어쩌면 개발자가 모르고 지나갈 수 있죠. 그러나 ② 경우 배리언트에 Feet(Int)만 추가하면 컴파일러가 모든 상태를 다루지 않은 패턴 매치를 위치와 함께 수정하라고 에러를 발생시킬 것입니다.\n\n### 옵션 타입\n\n리스크립트에는 자바스크립트의 `null`과 `undefined`가 없습니다. 값이 없는 상태는 '옵션(option)' 타입으로 정의할 수 있습니다. 옵션 타입은 값이 있거나 없거나 둘 중 하나의 상태를 갖습니다.\n\n옵션은 자바스크립트 런타임에서 `null`, `undefined` 때문에 발생하는 오류들을 막아줍니다. 옵션을 처음 접했을 때는 낯설고 어려워 보였지만, 익숙해지니 `undefined is not a function`, `cannot read properties of null` 등 프론트엔드 개발자들을 괴롭히는 온갖 오류들을 피할 수 있어 고마웠습니다. 타입을 이용해 값이 없을 수 있음을 명시함으로써, 로직에서 값이 없는 경우를 대응하지 않을 경우 컴파일 에러가 일어나도록 합니다. 런타임 에러를 컴파일 에러로 완화하고 예방하는 것이죠.\n\n옵션 타입을 위한 연산 중, map 함수를 살펴봅시다. map 함수는 인자로 받은 함수를 실행해주는데, 이를 이용하여 값이 있을 때만 함수를 실행하는 로직을 if 문 없이 선언적으로 구현할 수 있습니다.\n\n자바스크립트에서는 다음과 같이 실수로 null 관련 오류를 일으키기 쉽습니다.\n\n```javascript\n// \"dog\"이 \"hello cat\"에 매치되지 않아 dog 에 null 이 대입됩니다.\nvar dog = 'hello cat'.match(/dog/g)\n\n// null 에서 length 속성을 읽을 수 없어 오류가 발생합니다.\ndog.length\n```\n\n리스크립트의 옵션을 이용하면 null 에러를 컴파일 타임에 막을 수 있습니다. if 문도 사용하지 않고 말이죠.\n\n```rescript\n// dog : Option<Array<string>> 타입. match_ 메서드에 반환 타입이 정의되어 있습니다.\nlet dog = Js.String2.match_(\"hello cat\", %re(\"/dog/g\"))\n\n// 컴파일 에러: 옵션 타입에서는 배열 타입의 length 함수를 직접 사용할 수 없습니다.\ndog -> Array.length\n\n// 올바른 코드: 값이 없는 경우 0을 반환하고, 값이 있는 경우 함수를 실행합니다.\ndog -> Option.mapWithDefault(0, d => d -> Array.length)\n```\n\n### 함수의 입출력 타입에 대한 고려\n\n리스크립트에서는 모든 변수의 타입을 구체적으로 명시하는데, 그 덕분에 함수의 인터페이스를 파악할 때도 함수의 인자와 반환값의 타입을 중심으로 고려하게 됩니다. 저는 이런 특성 덕분에 함수형 프로그래밍 원리를 더 쉽게 이해할 수 있었습니다.\n\n예전에는 함수형 프로그래밍이라는 게 단순히 반복문 대신 맵(map)과 리듀스(reduce)를 사용하는 것이라고 막연하게 생각했습니다. 물론, 반복문을 사용하지 않는 것이 곧 함수형 프로그래밍인 것은 아닙니다. 하지만 실제로 함수형 프로그래밍에서는 절차형 프로그래밍에서보다 반복문을 적게 사용합니다. 함수의 타입 시그니처를 살펴보다가 그 이유를 명확히 알 수 있었습니다.\n\n반복문의 타입 시그니처는 `input<a'..> → void`입니다. 컬렉션을 입력받지만 반환값은 없는 것이죠. 반환값이 없다는 건 함수 외부의 상태를 변경하는 부작용(side-effect)으로만 실행 결과를 낼 수 있다는 걸 뜻합니다. 부작용을 일으키는 코드가 많아지면 프로그램의 데이터 흐름이 복잡해지고 유지보수가 어려워지기 때문에 함수형 패러다임에서는 부작용이 없는 순수 함수를 선호합니다.\n\n반복문은 반환값이 없으므로 조합도 불가능합니다. 조합(compose)이란 한 순수 함수의 출력을 다른 순수 함수의 입력으로 잇는 식으로 연결하여 더 큰 로직을 만들어내는 방법입니다. 함수형 프로그래밍의 핵심 방법 중 하나입니다.\n\n다음 코드는 반복문 함수인 `forEach`로 작성한 코드와, 그 코드를 반복문을 사용하지 않도록 개선해 본 것입니다.\n\n```rescript\n// 반복문 함수 forEach를 사용하여 부작용을 일으킨 코드\n// 순수 함수가 좋다는 걸 알아도 처음에는 이런 코드를 만들기 쉽습니다.\nlet a = []\n\nRange.forEach(start, end, i => {\n  if condition(split_arr[i]) {\n    return\n  } else {\n    let b = processing(split_arr[i])\n    a.push(b)\n  }\n})\n\n// 리뷰 의견: forEach를 사용해 부작용이 발생했습니다. forEach를 사용하지 않도록 수정해보세요.\n\n// 개선\nlet result = split_arr\n  ->Array.keep(s => condition(s))\n  ->Array.map(s => processing(s))\n```\n\n### 작은 함수들의 조합으로 프로그램을 구성하기\n\n코드 리뷰 중 \"코드를 작성하기 전에 함수 시그니처를 먼저 정의해보라\"라는 의견이 있었습니다. 그렇게 해보니 각 입력 타입을 출력 타입으로 변환하는 형태를 미리 파악할 수 있었고, 변환 단계마다 각각의 작은 함수가 담당해야 할 기능을 분리하여 생각하고 구현할 수 있었습니다.\n\n절차적으로 사고하면 각 단계의 행동을 서술하는 식으로 코드를 작성하게 됩니다. 반면, 함수 시그니처를 먼저 정의하면 함수의 역할과 데이터의 형태를 중심으로 코드를 작성할 수 있습니다.\n\n```text\n// 절차적으로 생각하는 방식\n- string 을 passport 데이터 객체로 바꾸는 함수\n  - input string 을 split 한다.\n  - split된 요소를 key, value 값으로 나누어 passport 객체로 만든다.\n\n// 선언적으로 생각하는 방식\n- parser : string -> Array<passport>\n  - splitter: string -> Array<string>\n  - stringToPassport: Array<string> -> Array<passport>\n\nparser = splitter o stringToPassport\n```\n\n이런 연습을 하니 자연히 사고 방식도 함수형 패러다임으로 옮겨갔습니다. 전에는 각 함수마다 수행해야 할 단계별 동작을 생각하는 절차적 프로그래밍 방식에 익숙했습니다. 지금은 각 단계를 시그니처로 표현합니다. 그러면 전체 처리 과정이 데이터 구조의 변화에 따라 명확하게 분리됩니다. 시그니처로 표현한 단계들은 곧 작은 함수들이 되는데, 이 함수들은 전후 문맥과 독립적으로 자신의 일만을 담당하도록 정의합니다. 그러면 전체 프로그램도 여러 개의 순수 함수를 조합하는 형태로 구성됩니다.\n\n시그니처를 먼저 정의하면, 시그니처만 보고도 함수를 어떻게 구현해야할지 미리 예상할 수 있습니다. 앞의 코드에서 `stringToPassport` 함수는 시그니처만 보고도 map 함수를 사용해야 한다는 걸 알 수 있습니다. 왜 그럴까요? map 함수의 시그니처를 살펴보면 다음과 같습니다.\n\n```rescript\n- Array<'a>.map(Array<'a>, ('a) ⇒ 'b) : Array<'b>\n- List<'a>.map(List<'a>, ('a) ⇒ 'b) : List<'b>\n- Option<'a>.map(Option<'a>, ('a) ⇒ 'b) : Option<'b>\n```\n\n`Array`, `List`, `Option`을 어떤 값을 감싸는 컨테이너로 생각한다면, map 함수는 그 안의 값의 타입을 바꾸는 함수로 볼 수 있습니다. 이에 따라 `stringToPassport` 함수는 `Array`라는 컨테이너 안의 값의 타입을 `string`에서 `passport`로 바꾸는 것이기에 map 함수를 사용하는 것이 적절합니다.\n\n### 그 외의 장점\n\n- 리스크립트는 다양한 컬렉션 타입을 조작하는 함수를 내장 API로 지원합니다. 그래서 컬렉션 조작을 위해 람다(Ramda), 로대시(Lodash) 같은 라이브러리를 사용하지 않아도 됩니다.\n- 파이프 연산자 `->`를 지원합니다. 방향을 명확히 알 수 있어 체이닝보다 좋습니다.\n- 트랜스파일된 자바스크립트 코드의 가독성이 매우 좋습니다. 리스크립트 코드가 자바스크립트 코드로 트랜스파일되는 방식을 파악하기 쉽습니다.\n\n## 마치며\n\n리스크립트는 다른 언어와 차이점이 많아 처음 접했을 때는 손발이 묶인 듯 불편했습니다. 문제를 풀며 언어를 익히는 동안 빠르게 답을 내려고 서두르기보다는, 언어가 제공하는 특징을 최대한 활용하는 구현을 찾으려고 노력했습니다. 감사하게도 프론트엔드 팀 동료들이 코드를 친절하게 리뷰해주고, 도움 될 자료들을 아낌없이 공유해 주었습니다. 그결과 지금은 코드를 이해하고 구현하는데 어느정도 익숙해졌습니다.\n\n부트캠프에서 리스크립트를 배우며 얻은 것이 참 많습니다. 새로운 언어와 함께 그 언어의 철학(함수형 패러다임)을 더 자세히 이해할 수 있었습니다. 절차형 코드를 함수형 코드로 개선하며 그 구성의 차이를 직접 느껴본 것도 즐거웠습니다. 무엇보다도 함수형 프로그래밍에 관해 이야기 나눌 수 있는 팀원들이 있어 행복합니다. 앞으로 그린랩스에서 함수형 프로그래머로서 팀원들과 함께 성장하게 될 것이 기대됩니다.\n\n<br />\n<br />\n<Author\n  email=\"hyosaritech@gmail.com\"\n  name=\"김효은\"\n  description=\"프론트엔드 엔지니어\"\n  date=\"2021-10-29\"\n/>\n<br />\n<br />\n\n## 참고자료\n\n- https://rescript-lang.org/docs/manual/latest/introduction\n","excerpt":"안녕하세요. 그린랩스 웹 개발팀에서 프론트엔드 엔지니어로 근무하고 있는 김효은입니다. 입사 전에는 타입스크립트 환경에서 서비스를 개발했습니다. 개발자로서 성장 자극을 찾던 중에 '함수형 프로그래밍' 패러다임을 소개하는 온라인 강의를 듣게 되었어요…","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","tags":[{"name":"ReScript","slug":"re-script"}]},{"slug":"/programmers-naming","title":"프로그래머를 위한 이름 짓는 원리","date":"2021년 9월 24일","body":"\n<Author\n  email=\"bakyeono@gmail.com\"\n  name=\"박연오\"\n  description=\"개발자/개구리 애호가/이름 짓기에 진심인 편\"\n  date=\"2021-09-24\"\n/>\n\n컴퓨터 프로그래머는 '이름 짓기'를 가장 전문적으로 다루는 직업일지도 모릅니다. 어쩌면 철학관의 작명사보다도 더요. 우리는 좋은 이름을 찾기 위해 많은 시간과 노력을 들입니다. 이름의 좋고 나쁨이 소프트웨어의 유지보수성에 큰 영향을 끼친다는 것을 경험으로 알고 있기 때문입니다.\n\n하지만 정작 컴퓨터 과학 커리큘럼이나 기술 서적에서 이름 짓는 방법을 찾아보기는 쉽지 않습니다. 일이 바쁠 때는 이름 짓는 데 시간을 많이 쓰는 게 잘못처럼 느껴지기도 합니다. 이름은 각자의 취향일 뿐이며 이름의 품질 기준 따위는 없으니 기계적으로 규칙만 정하면 된다고 생각하시는 분도 가끔 만날 수 있습니다.\n\n그렇다면 다음과 같은 의문이 제기됩니다.\n\n- 이름은 프로그래머들이 생각하는 것만큼 실제로 중요한 것일까요?\n- 어떤 이름이 좋다 나쁘다 판단할 수 있는 기준은 무엇일까요?\n\n이 글에서는 [{'<'}클로저 기본원리(Elements of Clojure){'>'}(재커리 텔먼 저, Leanpub 출판)](http://leanpub.com/elementsofclojure)에 실린 이름 짓는 원리를 소개하며 이 의문을 풀어보려 합니다.\n\n## 이름이 중요한 이유\n\n{'<'}클로저 기본원리{'>'}에서는 이름이 **간접화(indirection)**의 수단이기 때문에 중요하다고 설명합니다. 이 때 간접화란, 무엇(가리키는 방법, 인터페이스)과 어떻게(실제 구현)를 분리하는 것을 뜻합니다. 대부분의 프로그래머에게는 추상화(abstraction)라는 용어가 더 익숙할 것입니다. 하지만 추상화라는 용어에는 그것 말고도 더 많은 뜻이 담겨 있습니다. 한 단어가 갖는 의미가 넓으면 문맥에서 뜻을 파악할 때 더 많은 노력이 듭니다. 그래서 재커리 텔먼은 의도적으로 의미가 더 좁은 용어인 간접화를 사용합니다.\n\n간단한 클로저 함수에서 간접화의 예를 살펴보겠습니다.\n\n```clojure\n(defn get-태양-목성\n  [m k]\n  (get-in m [:태양 :목성 k]))\n```\n\n이 코드를 자세히 이해하실 필요는 없습니다. 함수에 등장하는 이름을 중심으로 훑어봅시다.\n\n- 함수 `get-태양-목성`을 정의했습니다.\n- 매개변수 `m`: 함수가 넘겨받을 맵 인자에 붙일 이름입니다.\n- 매개변수 `k`: 함수가 넘겨받을 키워드 인자에 붙일 이름입니다.\n- `(get-in m [:태양 :목성 k])`: 함수의 본문으로, 중첩 해시맵 `m`에서 세 키워드 `:태양` `:목성` `k` 에 해당하는 값을 차례대로 꺼냅니다.\n\n여기서 `m`과 `k`라는 매개변수 이름은 클로저 생태계에서 관례적으로 사용되는 이름이므로 신경쓰지 말고, 함수 이름 `get-태양-목성`이 좋은 이름인지 생각해봅시다. 이 이름에는 나쁜 점이 두 가지 있습니다.\n\n1. 함수의 이름만 보고 하는 일을 알기가 어렵습니다.\n2. 함수 호출을 내부 구현으로 변경하더라도 코드의 이해도가 낮아지지 않습니다. 다시 말해, 함수의 이름이 제공하는 이점이 없습니다.\n\n`get-태양-목성`이라는 이름은 모호해서 그 이름만 보고는 함수가 무슨 일을 할지 예상하기가 어렵습니다. 그래서 별도의 문서를 보거나 함수의 내부 구현을 봐야 합니다. 그런데 함수의 구현을 보면 간결한 내용이라 오히려 함수 이름을 사용하는 것보다 구현을 인라인으로 사용하는 편이 더 이해하기 쉽습니다.\n\n```clojure\n(get-태양-목성 m :칼리스토)         ; 함수가 무슨 일을 하는지 짐작하기 어렵습니다.\n(get-in m [:태양 :목성 :칼리스토])  ; 구현으로 대체하면 오히려 이해하기 쉽습니다.\n```\n\n그러면 \"과연 이 함수가 필요하긴 한 것인가?\", \"그냥 구현을 풀어 쓰는게 더 나은 게 아닌가?\"라는 합리적인 의심을 하게 됩니다. 이런 문제가 생기는 이유는 함수의 이름을 내부 구현을 축약해 붙였기 때문입니다. 함수의 구현이 아니라, 함수의 목적에서 그 이름을 딴다면 이야기는 달라집니다.\n\n```clojure\n(get-태양-목성 m :칼리스토)  ; 함수가 무슨 일을 하는지 짐작하기 어렵습니다.\n(get-목성의-달 m :칼리스토)  ; 목성의 위성을 꺼낸다는 걸 짐작할 수 있습니다.\n```\n\n함수의 구현은 그대로 두고 이름을 `get-목성의-달`으로 바꿨을 뿐입니다. 그런데 다음과 같은 장점이 생깁니다.\n\n- 함수의 이름이 간접화 계층(indirection layer)을 형성합니다.\n- 함수의 목적(계약)과 수단(구현)이 분리됩니다.\n- 함수의 내부 구현이 인터페이스에서 숨겨지며, 변경 가능하게 됩니다.\n\n여기서 한걸음 더 나아가 매개변수/인자의 이름까지 적절히 변경하면 간접화 수준을 더 높일 수 있습니다.\n\n```clojure\n(get-목성의-달 은하 :칼리스토)  ; 은하 데이터에서 목성의 위성을 꺼내나 봐요.\n```\n\n이제 매개변수/인자에서도 간접화 계층이 형성되어 새로운 이점이 생깁니다.\n\n- 함수가 어떤 데이터를 대상으로 동작하는지 이해하기 쉬워집니다.\n- 은하계 데이터의 구현이 이름 속에 숨겨집니다. `m`은 인자가 맵 구조여야 한다는 걸 뜻하지만, `은하`는 인자의 목적만을 묘사하고 구현에 대해서는 묘사하지 않기 때문이죠.\n\n이처럼 구현이 아닌 목적을 기준으로 이름을 붙이면 이름은 간접화를 형성하는 수단이 됩니다. 간접화 계층을 한 층 한 층씩 점진적으로 쌓아 올림으로써 프로그래머는 코드 전체를 동시에 이해하지 않고도 작업을 할 수 있게 됩니다. 프로그램을 만드는 일은 간접화 계층을 쌓아올리는 일이고, 간접화 계층은 이름을 붙임으로써 형성할 수 있습니다. 그러므로 프로그램을 만드는 일은 곧 이름 짓는 과정을 반복하는 일입니다.\n\n## 좋은 이름을 어떻게 찾을 수 있을까?\n\n이름이 그렇게 중요한 것이라면, 어떤 이름이 좋은 이름이라고 할 수 있을까요? 프로그래밍 입문서 [{'<'}연오의 파이썬{'>'}(박연오 저, 인사이트 출판)](https://python.bakyeono.net)에서 저는 이 질문에 대해 '문맥에서 충분히 구체적이면서 간결한 이름'이라고 간단히 답했습니다.\n\n> 의미있는 이름은 프로그램이 다루는 문제에 따라 다르다. 수학 방정식을 푸는 프로그램이라면 x, y, z 처럼 간단한 이름도 충분히 의미 있는 이름이 될 것이다. 반대로 '면적'이라는 꽤 명확해 보이는 이름도 문맥에 따라 의미가 모호해질 수 있다. 다음 이름들을 생각해 보자.\n>\n> - 면적\n> - 원의 면적\n> - 동전의 면적\n> - 십원 주화의 면적\n> - 1970년대 십원 주화의 면적\n> - 내가 가진 1970년대 십원 주화의 면적\n>\n> 동전교환기를 제어하는 프로그램을 만든다면, 그냥 '면적'보다는 더 명확한 이름이 필요할 것이다. 오늘날 발행되는 주화만 취급한다면 '십원 주화의 면적' 정도면 충분한 이름이 될 것이다.\n>\n> (중략)\n>\n> **이처럼, 그 이름이 사용되는 문맥에서 충분히 구체적이면서 간결한 이름이 좋다.**\n>\n> {'<'}연오의 파이썬{'>'} '2.2절 변수와 이름' 중\n\n간결한(일반적인) 이름과 자세한(구체적인) 이름 사이에서 배율을 조절하며 알맞은 이름을 찾아야 한다고 설명한 것입니다. 이것은 문학 글쓰기 교재 [{'<'}개구리를 위한 글쓰기 공작소{'>'}(이만교 저, 그린비 출판)](http://www.yes24.com/Product/Goods/7947689)를 참고해 쓴 것입니다. 프로그래머와 작가는 '언어'로 무언가(코드와 글)를 '쓰는' 일을 한다는 점에서 공통점이 있어, 글쓰기 교재에서도 프로그래머가 배울 점이 있습니다.\n\n> 모든 언어는 일정한 의미망을 갖는데, 그 의미망의 크기에 따라서 상위어와 하위어로 나눈다. 상위어일수록 의미가 포괄적이고, 하위어일수록 구체적이다.\n>\n> (중략)\n>\n> 하위어와 상위어를 적절하게 가름할 필요가 있다. 알맞은 층위에서 알맞게 말하는 것이 가장 알맞다. 가령 구체화가 필요할 때는 하위어를, 일반화가 필요할 때는 상위어를 사용한다.\n>\n> (중략)\n>\n> 추상의 사다리는 위로 올라갈수록 높은 추상 레벨이 되면서 보다 일반화되고, 내려올수록 낮은 추상 레벨이 되면서 보다 구체화된다. 낮은 레벨의 추상만 사용할 경우 내용은 지나치게 잡다해지고, 높은 추상만 고집할 경우 내용이 허황될 우려가 있다.\n>\n> {'<'}개구리를 위한 글쓰기 공작소{'>'} '3장 거칠게 청킹하지 마라' 중\n\n그런데 추상과 구체 사이에서 이름을 찾을 때는 '어떤 특성에 초점을 맞출지'를 함께 고려해야 합니다. 그에 따라 이름이 달라지기 때문입니다. 이 점에 관해서 {'<'}클로저 기본원리{'>'}에서는 프레게의 의미이론을 소개하며 설명합니다.\n\n## 프레게의 의미이론\n\n19세기 독일 논리학자 프레게(Gottlob Frege)는 과거 철학자들의 언어철학을 비판하고 문제점을 보완하는 새로운 의미이론을 발표했습니다. 프레게의 의미이론은 이름을 '어떻게' 좁혀야 하는지 판단할 때 참고가 됩니다.\n\n프레게가 비판한 과거의 이론에서는 **'기호(zeichen)'**의 의미는 곧 그 기호가 가리키는 **'지시체(bedeutung)'**를 뜻한다고 생각했습니다. 그런데 이런 생각은 하나의 지시체를 서로 다른 기호로 가리키는 경우에 문제가 됩니다.\n\n프레게는 샛별과 개밥바라기의 예를 듭니다. 샛별과 개밥바라기는 고대 그리스 사람들이 관측했던 두 천체입니다.\n\n- 샛별(Φώσφορος, 새벽에 동쪽에 보이는 별)\n- 개밥바라기(Ἕσπερος, 저녁에 서쪽에 보이는 별)\n\n그런데 그리스인들은 나중에 샛별과 개밥바라기가 둘 다 같은 천체, 금성이라는 사실을 알게 되었습니다. 기호 '샛별'과 기호 '개밥바라기'는 금성을 동일한 지시체로 공유하는 것입니다. 기호의 의미가 곧 지시체라면, 지시체가 동일한 두 기호를 서로 바꿔 쓰더라도 아무 문제가 없어야 합니다. 실제로 아래의 예에서는 문제가 되지 않습니다.\n\n1. 샛별은 샛별이다. (참)\n2. 샛별은 개밥바라기다. (참)\n\n샛별과 개밥바라기는 동일한 천체이므로 두 명제는 모두 참입니다. 그런데 두 기호를 서로 바꿔 사용할 수 없는 경우가 있습니다.\n\n1. 호메로스는 샛별이 샛별이라는 걸 알았다. (참)\n2. 호메로스는 샛별이 개밥바라기라는 걸 알았다. (거짓)\n\n샛별과 개밥바라기가 같은 별이라는 사실이 밝혀진 것은 호메로스가 죽은지 100년도 지난 뒤의 일입니다. 호메로스가 샛별이 개밥바라기라는 걸 알았을 가능성은 거의 0에 가까우므로, 두번째 명제는 거짓으로 간주해야 합니다. 따라서 위 예에서는 샛별과 개밥바라기라는 이름을 서로 바꿔 사용할 수 없습니다.\n\n이 문제가 생기는 이유는 기호에는 지시체만이 아니라 **'의미(sinn)'**가 함께 포함되어 있기 때문입니다. 위 예에서 기호, 의미, 지시체는 각각 다음과 같습니다.\n\n- 샛별(기호) - 새벽에 동쪽에 보이는 별(의미) - 금성(지시체)\n- 개밥바라기(기호) - 저녁에 서쪽에 보이는 별(의미) - 금성(지시체)\n\n두 기호가 같은 지시체를 가리키더라도, 지시체를 지시하는 방법인 의미가 다르다면 기호의 뜻도 다릅니다. 그러므로 이름을 지을 때는 일반적인 이름과 구체적인 이름 사이에서 알맞은 배율을 찾는 것만이 아니라, 지시체를 어떤 의미로 바라볼 것인지도 함께 고려해야 합니다.\n\n## 코드에서의 의미이론\n\n프레게의 의미이론에서 살펴본 것과 비슷한 예를 프로그램 코드 버전으로 확인해 봅시다. 동일한 값에 두 개의 이름을 정의합니다.\n\n```clojure\n(def a 42)\n(def b 42)\n```\n\n`a` 와 `b` 는 둘 다 42라는 동일한 값을 가리킵니다. 하지만 다음 두 명제는 동일하지 않습니다.\n\n```clojure\n(= a a)\n(= a b)\n```\n\n지금은 `a`와 `b`가 둘 다 같은 값을 지시하므로 식을 평가한 결과는 같겠습니다만, 나중에 `a`와 `b`가 지시하는 값이 달라지는 경우를 고려한다면 두 식은 서로 다른 명제입니다.\n\n이 예에서 다음과 같은 생각을 이끌어낼 수 있습니다.\n\n1. 이름(기호)과 값(지시체)은 서로 다릅니다.\n2. 두 기호가 같은 값을 가리키더라도 의미가 서로 다를 수 있습니다.\n3. 이름은 가리키는 대상(지시체)뿐만이 아니라 그 대상이 무엇이어야 하는지(의미)를, 그리고 나중에 어떤 대상이 될 수 있는지(의미)를 함께 나타냅니다.\n4. 이름은 간접화 계층을 형성하므로, 코드에서 값을 변경해야 하는 경우에 값 자체를 변경하는 대신에 이름이 다른 값을 가리키도록 수정하는 것이 가능합니다.\n5. 동일한 값을 가리키는 여러 개의 이름을 정의한 경우, 이는 비록 지금은 두 이름이 같은 대상을 가리키지만 나중에는 가리키는 대상이 서로 달라질 수도 있다고 프로그래머가 예상했기 때문일 것입니다.\n\n이 설명이 공감되지 않는다면, `a`와 `b`를 좀 더 구체적인 예(`number-of-slots`, `number-of-cards`)로 바꿔 생각해보시면 더 쉽게 이해하실 수 있을 것 같습니다.\n\n## 의미를 기준으로 이름을 붙여야 하는 이유\n\n지시체(구현)를 기준으로 하는 것보다, 의미(목적)를 기준으로 이름을 붙이는 것이 더 좋다는 점은 앞서 `get-태양-목성`과 `get-태양의-달`의 비교로 간단히 언급했습니다. 더 자세한 예를 알아봅시다.\n\n예: 회사에서 내부적으로 사용하는 고유식별자를 `id`라고 이름 붙이기로 약속했습니다. 고유식별자를 구현하는 방식은 UUID(랜덤 128비트 값)로 정했습니다.\n\n이 사례에서 기호, 의미, 지시체를 찾아봅시다.\n\n- 기호: 이름의 텍스트 표기. 이 사례에서는 '`id`'\n- 의미: 대상에 부여한 핵심 속성들. 이 사례에서는 '식별자의 고유성'\n- 지시체: 이름의 참조 대상. 이 사례에서는 'UUID 구현'\n\n다음 두 명제를 고려해 봅시다.\n\n1. 우리 회사의 고유식별자는 고유하다. (참)\n2. 우리 회사의 고유식별자는 128비트 값이다. (구현에 따라 참일 수도 거짓일 수도 있음)\n\n이름을 `id`(식별자)라고 붙였는데 식별을 위해서는 값이 고유해야 하므로 이 이름에는 '고유성'이라는 특성이 포함되어 있습니다. 그러므로 첫 명제는 항상 참입니다. 하지만 두번째 명제에서 '128비트 값'이라는 특성은 `id`라는 이름에 내재된 특성이 아닙니다. 두번째 명제는 항진명제가 아니며, 거짓으로 취급해야 합니다. 만약 두번째 명제를 참으로 간주한다면 '128비트 값'이라는 특성이 회사의 도그마가 되어 장래에 새 설계를 막는 구실을 할 것입니다.\n\n코드에서 낯선 이름을 봤을 때, 코드를 읽는 사람이 알아야 하는 건 그 이름의 의미(목적)뿐입니다. 그 지시체(구현)가 무엇인지는 알 필요가 없으며, 알고 싶지도 않을 것입니다. 이름을 보고도 구현을 참고해야만 한다면 간접화가 제대로 되지 않은 셈입니다.\n\n구현을 묘사하는 이름은 간접화 계층을 올바르게 형성하지 못하며, 구현을 변경하기 위해서는 인터페이스를 함께 변경할 수밖에 없도록 만듭니다. 반면에 의미를 묘사하는 이름은 간접화 계층을 형성하여 이름과 구현을 분리하며, 인터페이스를 유지한 채로 내부 구현을 변경하는 것을 가능하게 합니다.\n\n## 협의성과 일관성\n\n{'<'}클로저 기본원리{'>'}에서는 좋은 이름을 판단하는 두 가지 기준으로, '협의성'과 '일관성'을 제시합니다.\n\n- 협의성(narrowness): 나타내지 않는 것을 제거하여 나타내는 의미를 좁힌 상태\n- 일관성(consistency): 의미의 일관성이 있어 전체적인 문맥, 도메인, 프로그래밍 언어의 생태계 속에서 쉽게 이해되는 상태\n\n### 협의성(의미가 좁음)\n\n협의성에 대해서는 앞에서도 설명했습니다. 이름이 너무 일반적이지도 않고, 너무 구체적이지도 않게 균형을 갖추었으며, 대상의 핵심 특성에 맞게 의미를 좁힌 것을 말합니다.\n\n- 일반적인 이름은 대상의 특성 중 일부만을 서술합니다. 대상의 핵심 특성을 모호하게 묘사하여 과도한 변경을 허용합니다.\n- 구체적인 이름은 대상의 특성 중 대부분을 서술합니다. 대상의 내부 구현까지 노출함으로써 변경을 어렵게 만들거나, 사소한 세부 사항까지도 무시하지 못하도록 만듭니다.\n- 의미가 좁은 이름은 일반과 구체 사이에서 균형을 갖추며, 대상에서 나타내고자 하는 특성을 잘 설명하는 이름입니다.\n\n그런데 이름의 협의성을 높이는 수단에는 이름 자체를 자세히 묘사하는 것 외에도 여러 가지가 있습니다.\n\n- 자세한 기호 (a, area, area-of-coin, area-of-10krw-coin)\n- 기호를 둘러싼 문맥 (coin-exchanger/area-of-coin)\n- 문서 (\"이 동전교환기 펌웨어에서는 동전을 면적에 따라 구별하며...\")\n- 작업자들의 일상적인 대화 (\"그 동전교환기에서 외국 동전도 지원했던가?\")\n\n즉, 협의성은 코드 밖에서도 형성되거나 파괴될 수 있습니다. 이렇게 다양한 수단에 의해 협의성이 형성되므로, 긴 이름(`unique-arbitrary-string-id`) 대신 짧은 이름(`id`)을 사용하더라도 협의성을 유지할 수 있습니다. 하지만 그렇기 때문에 이름을 둘러싼 전체 문맥을 벗어나면 협의성이 상실될 수도 있습니다.\n\n### 일관성(의미가 한결같음)\n\n협의성이 전체적인 문맥 속에서 형성된다는 걸 고려하면, 일관성도 좋은 이름의 중요한 특성입니다. 이름에 일관성이 있다는 것은 문맥이 바뀌더라도 항상 같은 의미를 나타내는 것을 말합니다. 일관성 높은 이름은 코드를 읽는 사람이 그 의미를 더 적은 노력으로 파악할 수 있게 해줍니다. 반대로, 이름을 볼 때마다 \"이 이름이 저 이름공간에서는 무슨 의미였더라?\"하는 생각이 든다면 이름의 일관성이 낮은 것입니다.\n\n예를 들어, 클로저에서는 `map`이라는 이름이 특정한 시퀀스 함수를 가리킵니다. 그런데 어떤 이름공간에 한정해서 `map`이라는 이름이 '지리 정보를 담은 데이터 컬렉션'을 가리키도록 재정의했다고 해봅시다. 그러면 다음과 같은 문제가 생깁니다.\n\n- `map`이라는 이름이 어떤 의미를 가리키는지에 관해 문서화를 해야 합니다.\n- 코드를 읽는 사람은 `map`이라는 이름이 등장할 때마다 문맥을 의식적으로 구별해야 합니다.\n- 특정 이름공간에서만이 아니라 전체 코드와 전체 문서에서, 현재 논의하는 `map` 이 어떤 `map`을 뜻하는 것인지 명시해야 합니다.\n\n협의성과 일관성이 모두 높은 이름을 찾거나 만들어내는 것은 쉽지 않습니다. 다만, 이 두 특성을 어떤 이름이 좋은지 나쁜지를 판단하는 기준으로 삼으면 이름을 지을 때 도움이 될 수 있겠습니다.\n\n## 의도적 비일관성\n\n일관성을 의도적으로 깨트리는 경우를 종종 볼 수 있습니다. 예를 들어, 어떤 대학에서 `student`라는 데이터 유형을 다음과 같이 부서별로 다르게 정의했다고 합시다.\n\n- 입학부서: `student`는 입학지원자이다.\n- 회계부서: `student`는 현 학기에 등록한 자이다.\n- 각 학과부서: `student`는 학과의 수업에 등록한 자이다.\n\n각 부서별로 서로 다른 소프트웨어를 개발해 사용한다면, `student`라는 이름을 혼동 없이 사용할 수 있습니다. 기호의 의미는 문맥 속에서 추론되므로, 별도의 문맥을 정의하면 하나의 이름을 서로 다른 용도로 사용할 수 있기 때문입니다.\n\n하지만 이런 방식에는 단점이 있습니다.\n\n- 실제로는 서로 다른 프로그램을 만드는 것이 아니라, 하나의 프로그램에서 부서별로 이름공간만 다르게 정의하는 사례가 많습니다. 이런 경우, 입학부서 이름공간에 회계부서 이름공간의 `student`를 가져오는 등 이름과 데이터가 뒤섞일 위험이 생깁니다.\n- 코드를 읽을 때 문맥을 전환하며 이름의 의미를 파악해야 합니다. 코드 읽는 비용이 커지며, 오독의 여지가 생깁니다.\n\n이처럼 여러 개의 문맥을 형성하여 이름에 다양한 의미를 부여하는 의도적 비일관성에는 비용이 따릅니다.\n\n문맥이 여러 갈래로 쪼개지는 문제를 방지하려면 이름의 의미를 가장 일반적인 경우에 맞춰 좁혀야 합니다.\n\n- `student`를 입학지원자로 정의하는 경우, 이 이름은 입학부서에서만 일관성이 유지되고 그 밖에서는 일관성이 깨집니다.\n- 모든 부서에서 일관성을 갖추려면 각 부서의 `student`에 대해 그 실제 의미에 맞는 이름을 서로 다르게 정의해야 합니다. `student`와 같은 모호한 이름을 사용해서는 안 됩니다.\n\n완전한 일관성을 달성하는 유일한 방법은 기호와 의미 사이에 일대일 관계를 형성하는 것입니다. 각 의미에 맞는 기호를 고안해내야 합니다. 이를 위해서는 자연 이름 대신 인공 이름을 사용하는 것도 검토해 볼 필요가 있습니다.\n\n## 자연 이름, 인공 이름\n\n자연 이름은 평소 여러 가지 의미로 널리 사용되는 말을 이용한 이름이고, 인공 이름은 특정한 의미가 없는 말이나 새로운 말을 이용한 이름입니다. 이 둘은 서로 상반된 특징을 가집니다.\n\n자연 이름\n\n- 예: student\n- 명료성: 모호함. 그 이름에 이미 수많은 의미가 담겨 있으며, 따라서 의미가 모호합니다.\n- 이해 수준: 스펙트럼이 넓음. 누구나 그 의미를 유추할 수 있어, 약간의 의미를 이해합니다. 하지만 이해 수준은 사람마다 달라서, 약간만 이해하는 사람도 있고 자세히 이해하는 사람도 있습니다.\n- 참여도: 높음. 학습 없이도 의미를 유추할 수 있습니다. 초보자도 바로 참여할 수 있습니다.\n\n인공 이름\n\n- 예: monad\n- 명료성: 분명함. 임의의 특정한 의미로 정의할 수 있으므로 모호하지 않습니다.\n- 이해 수준: 이분법적. 누군가가 그 뜻을 알거나, 모르거나 둘 중 하나입니다.\n- 참여도: 낮음. 이름의 의미를 유추할 수 없습니다. 이름의 의미를 모르는 사람은 참여가 불가능하며, 의미를 배워야만 참여할 수 있습니다.\n\n인공 이름은 협의성과 일관성이 높지만, 학습 비용을 높이고 참여도를 낮추며 문서화가 반드시 필요하다는 단점도 있습니다. 제 생각으로는 모든 이름을 인공 이름으로 만들어내는 것은 참여자들의 초기 진입을 어렵게 만들기 때문에 바람직하지 않을 것 같습니다. 일부 전문 영역에서는 인공 이름을 많이 정의해서 의도적으로 진입 장벽을 설정하는 듯한 사례도 볼 수 있습니다. 이렇듯 자연 이름과 인공 이름의 장단점을 따져 알맞은 이름을 골라야 하겠습니다.\n\n## 그 외의 팁들\n\n{'<'}클로저 기본원리{'>'}에는 클로저에서 이름을 지을 때 고려해볼 자세한 사항이 더 많이 나와 있습니다. 클로저에 특화된 내용은 빼고, 다른 언어를 사용하는 분들도 참고해 볼만한 팁들을 몇 가지만 더 소개해 보겠습니다.\n\n### 짧은 이름과 자기명세성이 높은 이름 중에서 고민할 때 (이름의 길이와 자기명세성이 비례한다고 가정)\n\n- 여러 번 반복해서 사용되는 값에는 짧은 이름을 붙이는 것이 유리합니다.\n- 자기명세성이 약한 이름을 짓는 경우, 그 이름이 가리키는 대상의 구현은 최대한 간결해야 합니다. 이름만으로 이해하지 못하고 코드를 봐야 하니까요.\n\n### 피할 수 있다면, 피하세요\n\n- 좋은 이름을 짓기는 어렵습니다. 그러므로 이름이 없어도 되는 경우에 억지로 이름을 붙이지 마세요.\n- 데이터를 일련의 과정에 따라 변환하는 경우 중간 과정의 데이터들 `a - b - c - d - e` 모두에 이름을 붙이기보다는, 처음과 마지막의 `a - e` 에만 이름을 붙이는 것이 낫습니다.\n- 어떤 함수의 이름이 그 구현보다 자기명세성이 약하다면, 그 함수에는 이름을 붙이지 마세요. 익명 함수를 사용하면 됩니다. 이는 함수가 비교적 크고 복잡해도 마찬가지입니다. 큰 것이 반드시 나쁜 것을 의미하는 것은 아닙니다.\n- 함수가 너무 커졌는데도 함수를 조각낼 부분 이름들을 떠올리지 못했다면, 그대로 두세요. 나중에 좋은 이름이 생각나면 그 때 분리하면 됩니다. 억지로 떼어내서 붙여 둔 이름이 좋은 간접화 계층을 생성하지 못한다면, 결국 구현체를 봐야 하므로 의미가 없겠지요?\n\n### 함수를 이름공간으로 묶는 경우\n\n- 한 이름공간에는 공통된 목적에 한정된 함수들을 담는 것이 좋습니다. 그러면 이름의 의미가 좁혀집니다.\n- 일반적으로 다루는 데이터 유형이나 데이터 스코프가 동일한 함수들을 같은 이름공간으로 묶게 됩니다.\n- 하지만 이름공간이 너무 많아지면 코드를 읽는 비용이 커집니다. 예를 들어 데이터베이스의 테이블 개수만큼 이름공간을 만든다면 비효율적일 가능성이 높습니다.\n- 이름공간은 꼭 필요할 때만 추가하는 것이 좋습니다. \"새로운 데이터 유형 / 데이터 스코프를 위한 이름공간을 추가함으로써, 전체 코드가 간결해지는가?\" 하고 자문해 보세요.\n\n## 요약\n\n**이름이 중요한 이유**\n\n이름은 간접화 계층을 형성합니다. 덕분에 프로그래머는 코드 전체를 동시에 이해하지 않고도 프로그램을 만들 수 있습니다. 이름은 프로그램의 추상성을 높이는 중요한 역할을 합니다.\n\n**프레게의 의미이론**\n\n두 기호가 같은 지시체를 가리키더라도 의미가 다르다면 기호의 뜻도 다릅니다.\n\n**코드에서의 의미이론**\n\n이름은 지시체(구현)가 아니라 의미(목적)를 기준으로 지어야 합니다. 그래야 적절한 간접화 계층이 형성됩니다. 의미를 드러내는 이름을 지을 수 없다면, 이름을 붙여야하는 대상이 아닐 수도 있습니다.\n\n**협의성**\n\n이름이 너무 일반적이면 의미가 모호하며 과도한 변경을 허용하게 됩니다. 이름이 너무 구체적이면 구현이 인터페이스에 노출되며 변경이 어려워집니다. 그 사이에서 강조하고자 하는 대상의 특성에 맞춰 의미를 좁힌 이름이 좋습니다.\n\n**일관성**\n\n이름의 협의성은 문맥에 의해서도 형성됩니다. 하지만 어떤 이름의 의미가 문맥에 따라 달라진다면 이름의 의미를 이해하거나 커뮤니케이션 하는 데 더 많은 비용이 듭니다. 어떤 문맥에서든 동일한 의미를 갖는 이름이 더 좋습니다.\n\n**의도적 비일관성**\n\n이름의 의미는 문맥 속에서 파악되므로, 하나의 이름을 다양한 문맥에서 다르게 정의하여 재사용할 수도 있습니다. 하지만 일관성이 낮아짐에 따르는 비용을 감수해야 합니다.\n\n**자연 이름과 인공 이름**\n\n자연 이름과 인공 이름은 서로 반대의 특성을 갖습니다. 이름의 협의성과 일관성을 높이기 위해 인공 이름을 고려해볼 수 있지만, 자연 이름과 인공 이름의 장단점을 따져서 적절한 이름을 골라야 하겠습니다.\n\n## 마치며\n\n**'좋은 이름 짓는 방법'**은 프로그래머들의 성배입니다. {'<'}클로저 기본원리{'>'}에서 명확한 답을 찾을 수 있는 것은 아니고, 이견도 얼마든지 있을 수 있습니다. 이 글에서 소개한 요소들을 모두 고려하더라도 이름을 짓는 일은 여전히 어려울 겁니다. 다만 이름이 왜 중요한지를 설명할 수 있다는 것과, 어떤 이름이 좋은지 나쁜지 헷갈릴 때 참고할 기준을 갖추는 건 도움이 될 것 같습니다. 이 글에서는 클로저에 국한되지 않는 일반적인 작명 기준을 주로 설명했습니다. {'<'}클로저 기본원리{'>'}에는 클로저에서 이름을 지을 때 참고할 수 있는 내용이 더 많이 실려 있으니 한번 살펴보시기 바랍니다.\n\n## 참고 자료\n\n- [{'<'}클로저 기본원리(Elements of Clojure){'>'} 재커리 텔먼 저, Leanpub 출판](http://leanpub.com/elementsofclojure)\n- [{'<'}연오의 파이썬'>' 박연오 저, 인사이트 출판](https://python.bakyeono.net)\n- [{'<'}개구리를 위한 글쓰기 공작소{'>'} 이만교 저, 그린비 출판](http://www.yes24.com/Product/Goods/7947689)\n- [의도를 드러내는 이름(Intention Revealing Names)](https://wiki.c2.com/?IntentionRevealingNames): 스몰톡(Smalltalk) 언어에서 메서드 이름을 지을 때 구현 대신 의도에서 이름을 붙이라는 내용의 문서. 정재훈 님의 소개로 링크합니다.\n","excerpt":"컴퓨터 프로그래머는 '이름 짓기'를 가장 전문적으로 다루는 직업일지도 모릅니다. 어쩌면 철학관의 작명사보다도 더요. 우리는 좋은 이름을 찾기 위해 많은 시간과 노력을 들입니다. 이름의 좋고 나쁨이 소프트웨어의 유지보수성에 큰 영향을 끼친다는 것을…","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","tags":[{"name":"name","slug":"name"},{"name":"naming","slug":"naming"},{"name":"Elements of Clojure","slug":"elements-of-clojure"}]},{"slug":"/introduce-a-ring","title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021년 9월 17일","body":"\n## <a name=\"contents\"/>목차\n\n- [Ring 이란](#what-is-ring)\n- [간단한 요청 - 응답](#simple-request-and-response)\n- [로컬호스트에 웹서버 띄우기](#launch-web-server-in-localhost)\n- [미들웨어 설정해보기](#setting-up-middleware)\n- [정적 자원을 서빙 해보기](#serving-static-resources)\n- [파라미터들 다루기](#params)\n- [세션과 쿠키](#session-and-cookie)\n- [마치며](#end-of-document)\n\n## <a name=\"what-is-ring\"/>Ring 이란\n\nRing은 파이썬의 WSGI(Web Server Gateway Interface)에 영감을 받은 클로저 웹 애플리케이션 라이브러리입니다.\n\nWSGI는 웹 서버와 파이썬 애플리케이션 사이의 표준 인터페이스로서, 웹 서버에 들어온 요청을 애플리케이션으로 전달하는 역할을 합니다.\n클로저에서는 Ring이 이 일을 담당합니다.\nRing은 저수준 인터페이스(handler, middleware, request, response 등)만을 제공합니다.\n고수준 인터페이스(routing 등)를 사용하려면 Ring을 기반으로 하는 다른 라이브러리들을 사용해야 합니다.\n\n이 튜토리얼에서는 Ring의 저수준 인터페이스들을 이용하여 간단한 웹 애플리케이션을 만들어보겠습니다.\n\n**필요한 프로그램 목록**\n\n| 이름               | 버전          |\n| ------------------ | ------------- |\n| Clojure            | 1.10.3        |\n| deps               | 클로저에 포함 |\n| IntelliJ (Cursive) | 2021.2        |\n\n## <a name=\"simple-request-and-response\"/>간단한 요청 - 응답\n\n인텔리제이에서 사용할 프로젝트를 만듭니다.\ndeps를 패키지 매니저로 사용할 것이므로 deps를 지정해주고 적절한 이름으로 만듭니다.\n\n![](/create-project.png)\n\n프로젝트 최상위 경로에 있는 `deps.edn` 을 다음과 같이 변경합니다.\n`deps.edn`은 클로저에서 사용하는 패키지 매니저인 deps 의 설정 파일입니다.\n이 글에서는 자세히 소개하지 않습니다.\n자세한 내용은 [공식문서](https://clojure.org/guides/deps_and_cli)를 참고하세요.\n\n```clojure\n{:paths [\"src\"]\n :deps {ring/ring {:mvn/version \"1.9.3\"}}}\n```\n\n_deps.edn_\n\n`deps.edn` 파일을 만든 뒤 IDE 프로그램인 인텔리제이에서 'Add as Clojure Deps project'를 클릭하여\n프로젝트에 `deps.edn` 파일을 설정 파일로 등록하여 IDE와 연동합니다.\n\n![deps 추가 방법](/add-as-clojure-deps-project.png)\n\n## <a name=\"launch-web-server-in-localhost\"/>로컬호스트에 웹서버 띄우기\n\n`src` 디렉터리를 생성하고, 'mark directory as source folder'를 클릭하여 소스 폴더로 설정합니다.\n소스 폴더 안에는 `hello_world` 라는 이름으로 앱 디렉터리를 지정합니다.\n\n![프로젝트 폴더 구조](/project-layout1.png)\n\n- 폴더 이름에 하이픈(-) 이 들어있으면 \"Namespace name does not correspond to filesystem hierarchy\" 라는 오류 메시지를 보실 수 있습니다.\n  하이픈 대신 언더바(\\_)를 사용해야 합니다.\n\n이제 웹 서버에 들어온 요청을 넘겨받아 적절한 처리를 하고 응답을 넘겨줄 핸들러를 정의할 차례입니다.\n핸들러를 정의할 클로저 namespace 파일을 생성합시다.\n저는 core.clj 라고 이름 지었습니다.\n\n```clojure\n(ns hello-world.core)\n\n(defn handler [request]\n  {:status 200\n   :headers {\"Content-Type\" \"text/html\"}\n   :body \"Hello World\"})\n```\n\n_namespace(ns) 의 폴더명에 섞인 언더바가 하이픈으로 변경된 것에 주의_\n\n이제 인텔리제이에서 REPL을 실행할 수 있게 설정합시다. 특별히 수정할 것 없이 이름만 정해주면 됩니다.\n\n![REPL configuration](/how-to-configure-repl.png)\n\n이제 `run` 메뉴에서 REPL을 실행할 수 있습니다.\n\nREPL에서 아래의 코드를 입력하여 로컬 환경에서 웹 서버 애플리케이션을 띄워봅시다.\n\n```clojure\n(use 'ring.adapter.jetty)\n(use 'hello-world.core)\n(def server (run-jetty handler {:port  3000\n                                :join? false}))\n\n(.stop server)\n(.start server)\n```\n\n_REPL_\n\n![response](/result-simple-response.png)\n\n잘 되었다면 `def server ...` 를 REPL 에서 실행하는 순간 웹서버가 시작되는 것을 로그에서 확인할 수 있습니다.\n웹 브라우저를 이용해 웹 서버의 URL에 접속하면, 핸들러에 정의해 둔 메시지가 응답되는 것을 확인할 수 있습니다.\n\n- Ring 의 응답 데이터 구조\n\n```clojure\n{:ssl-client-cert nil,\n :protocol \"HTTP/1.1\",\n :remote-addr \"127.0.0.1\",\n :headers {\"sec-fetch-site\" \"none\",\n           \"host\" \"localhost:3000\",\n           \"user-agent\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:90.0) Gecko/20100101 Firefox/90.0\",\n           \"cookie\" \"...\",\n           \"sec-fetch-user\" \"?1\",\n           \"connection\" \"keep-alive\",\n           \"upgrade-insecure-requests\" \"1\",\n           \"accept\" \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n           \"accept-language\" \"ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3\",\n           \"sec-fetch-dest\" \"document\",\n           \"accept-encoding\" \"gzip, deflate\",\n           \"sec-fetch-mode\" \"navigate\"},\n  :server-port 3000,\n  :content-length nil,\n  :content-type nil,\n  :character-encoding nil,\n  :uri \"/\",\n  :server-name \"localhost\",\n  :query-string nil,\n  :body #object[org.eclipse.jetty.server.HttpInputOverHTTP 0x6a5c0707 \"HttpInputOverHTTP@6a5c0707[c=0,q=0,[0]=null,s=STREAM]\"],\n  :scheme :http,\n  :request-method :get}\n```\n\n이제 Ring 이 제공하는 `response` 함수를 활용해봅시다. `ring.util.response` 는 아래와 같이 구현되어 있습니다.\n\n```clojure\n(defn response\n  \"Returns a skeletal Ring response with the given body, status of 200, and no\n  headers.\"\n  [body]\n  {:status  200\n   :headers {}\n   :body    body})\n```\n\n_ring.utils.response/response 구현체_\n\n빈 헤더와 HTTP 상태 코드 200, 그리고 사용자가 넘겨준 body를 반환하도록 정의되어 있습니다.\n이를 이용해 우리가 앞서 만든 코드를 아래와 같이 수정 할 수 있습니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.util.response :refer [response]]))\n\n(defn handler [request]\n  (response \"{\\\"test\\\": \\\"asd\\\"}\"))\n```\n\n이 외에도 redirect, created, bad-request 등 HTTP 응답 상태 코드에 대응하는 여러가지 응답 함수가 있으므로 상황에 따라 사용할 수 있습니다.\nHTTP 응답 헤더도 설정할 수 있습니다. 만약 Content-Type 헤더를 `application/json` 으로 설정하여 응답을 주고 싶다면 아래와 같이 핸들러를 정의합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.util.response :refer [response header]]))\n\n(defn handler [request]\n  (header (response \"{\\\"test\\\": \\\"asd\\\"}\") \"Content-Type\" \"application/json\")\n```\n\n헤더를 설정하는 또 다른 방법으로, 아래와 같이 `content-type` 함수를 사용하는 것도 가능합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.util.response :refer [response content-type]]))\n\n(defn handler [request]\n  (content-type (response \"{\\\"test\\\": \\\"asd\\\"}\") \"application/json\")\n```\n\n## <a name=\"setting-up-middleware\"/>미들웨어 설정해보기\n\n모든 핸들러가 `Content-Type` 헤더를 `application/json` 으로 설정하려면 어떻게 해야 할까요?\n각 핸들러마다 헤더를 명시적으로 설정해줘도 되지만, 미들웨어를 이용하면 일괄로 처리할 수 있습니다.\n`Content-type` 헤더 설정을 미들웨어에서 처리해봅시다.\n\n```clojure\n(ns hello-world.core)\n\n(defn handler [request]\n  {:status 200\n   :headers {\"Content-Type\" \"text/html\"}\n   :body \"{\\\"test\\\": \\\"asd\\\"}\"})\n\n(defn wrap-content-type [handler content-type]\n  (fn [request]\n    (let [response (handler request)]\n       (assoc-in response [:headers \"Content-Type\"] content-type))))\n\n(def app\n  (-> handler\n      (wrap-content-type \"application/json\")))\n```\n\n_미들웨어를 추가한 core.clj_\n\n애플리케이션이 실행될 때 `wrap-content-type` 이 `handler` 함수를 감싸므로 `handler` 함수 안에서 헤더 설정을 명시하지 않아도 됩니다.\n애플리케이션에 미들웨어를 등록한 걸 반영하기 위해서는, `run-jetty` 의 실행 대상을 `handler` 대신 `app` 으로 바꿔야 합니다.\n서버를 실행시켜 둔 상태라면 서버도 다시 로드해야 합니다.\n\n```clojure\n(.stop server)\n(use 'hello-world.core :reload)\n(def server (run-jetty app {:port 3000\n                            :join? false}))\n(.start server)\n```\n\n_미들웨어를 적용하기 위해 (run-jetty handler ...) 에서 (run-jetty app ...) 으로 변경한 것에 주목_\n\n웹 브라우저에서 웹 서버에 다시 접속해보면, 응답 헤더가 올바르게 전달되어 브라우저에서 데이터를 JSON으로 인식하는 걸 확인할 수 있습니다.\n\n![미들웨어를 추가한 결과](/result-middleware.png)\n\n미들웨어를 통해 자동 리로딩 기능을 설정할 수 있습니다.\nREPL을 이용하여 서버를 띄웠을 때는 변경을 반영하기 위해 서버를 재시작 해야했습니다.\n자동 리로딩을 이용하면 변경을 파일에 저장하면 서버를 재시작 하지 않아도 변경이 반영됩니다.\n개발 편의성을 위해 설정해 봅시다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.reload :refer [wrap-reload]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [request]\n      {:status 200\n       :headers {\"Content-Type\" \"text/html\"}\n       :body \"{\\\"test\\\": \\\"asd\\\"}\"})\n\n(def reloadable-app\n  (-> handler\n      wrap-reload))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n_자동 리로딩을 적용한 core.clj_\n\n자동 리로딩을 설정하려면 `ring.middlewrae.reload/wrap-reload` 를 불러와야 하고,\n`(defn -main [] ())`를 선언하여 프로그램 실행 지점을 만들어주어야 합니다.\n\n만약 기존에 REPL로 웹 서버 애플리케이션을 띄워둔 게 있다면 꺼주어야 합니다.\n그리고 프로그램 실행 지점을 통해 실행합니다.\n\n![](/run-with-main.png)\n\n이제 자동 리로딩이 잘 동작하는지 확인하기 위해 핸들러 `:body` 를 바꾸겠습니다.\n\n```clojure\n...\n\n(defn handler [request]\n      {:status 200\n       :headers {\"Content-Type\" \"text/html\"}\n       :body \"{\\\"test\\\": \\\"foobar\\\"}\"})\n\n...\n```\n\n파일을 저장하고 웹 브라우저에서 새로고침을 두어번하면 변경한 응답이 반영되어 있습니다.\n\n## <a name=\"serving-static-resources\"/>정적 자원을 서빙 해보기\n\n이제 핸들러를 이용해 정적 자원을 응답하도록 설정해 봅시다.\n여기서 소개하는 것과 똑같은 구조가 아니어도 되지만,\n편의상 프로젝트 최상위 경로를 기준으로 아래와 같은 구조가 되도록 `resources/public` 폴더를 만들겠습니다.\n\n```text\n/app\n  /resources\n    /public\n  /src\n    /hello_world\n      core.clj\n  deps.edn\n```\n\n_폴더 구조_\n\n`resources/public` 에 서빙할 정적 자원을 넣어두시면 됩니다. 아래와 같이 간단한 `index.html` 파일을 만들어 넣습니다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>index</title>\n  </head>\n  <body>\n    Clojure time!\n  </body>\n</html>\n```\n\n_resources/public/index.html_\n\n지금은 라우팅 없이 하나의 핸들러 모든 요청을 처리하고 있습니다. 핸들러를 아래와 같이 수정합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.resource :refer [wrap-resource]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [request]\n  (response (slurp \"resources/public/index.html\")))\n\n(def reloadable-app\n  (-> handler\n      (wrap-resource \"public\")))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n_core.clj_\n\n위의 코드에서 보듯, 정적 자원을 서빙 하기 위해서는 `wrap-resource` 가 필요합니다.\n`wrap-resource` 는 파라미터로 핸들러와 경로를 받습니다.\n`root-path`를 `public` 으로 지정합니다.\n소스 코드를 저장하여 웹 서버가 리로드 되도록 하고, 웹 브라우저에서 [http://localhost:3000/index.html](http://localhost:3000/index.html) 에 접속해 봅시다.\n\n![template response](/result-static-resource.png)\n\n`index.html` 파일의 내용이 잘 출력되는 것을 확인할 수 있습니다.\n\n## <a name=\"params\"/>파라미터들 다루기\n\n다음으로 URL의 쿼리 파라미터와 폼 파라미터(application/x-www-form-urlencoded)를 읽어 처리하는 방법을 알아봅시다.\n먼저 URL의 쿼리 스트링을 파싱하는 미들웨어인 `ring.middleware.params/wrap-params` 를 추가합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.session :refer [wrap-session]]\n            [ring.middleware.params :refer [wrap-params]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [{:keys [query-params form-params params]}]\n  (response (str {:query-params query-params\n                  :form-params form-params\n                  :params params})))\n\n(def reloadable-app\n  (-> handler\n      wrap-params\n      wrap-session))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n`wrap-params` 는 요청에 `:query-params` 와 `:form-params`, `:params` 를 각각 키와 값으로 추가해줍니다.\n이름에서 알 수 있다시피 `query-params` 는 URL 쿼리 스트링을,\n`form-params` 은 폼 데이터를 그리고 `params` 는 모든 파라미터를 파싱하여 담고 있습니다.\n웹 서버를 리로드하고, 웹 브라우저에서 URL에 쿼리 스트링을 입력하여 접속하면 `query-params` 와 `params` 에 의도한 값인 `foo: 1` 이 들어감을 볼 수 있습니다.\n\n![query params response](/result-query-params.png)\n\n마찬가지로 x-www-form-urlencoded 데이터를 전달하면 `form-params` 에 요청 내용이 입력되는 것을 확인할 수 있습니다.\n\n![form params response](/result-form-params.png)\n\n하지만 `wrap-params` 는 `x-www-form-urlencoded` 형식의 데이터만을 파싱할 수 있습니다.\n`ring.middleware.params/wrap-params` 의 주석에 자세한 내용이 적혀 있습니다.\n\n> Middleware to parse urlencoded parameters from the query string and form\n> body (if the request is a url-encoded form).\n\n`multipart/form-data` 형식의 데이터를 처리하려면 `ring.middleware.multipart_params/wrap-multipart-params` 를 사용해야 합니다.\n그러면 `wrap-multipart-params` 를 이용해 파일 업로드를 처리해 봅시다.\n파일을 올릴 폴더를 준비합니다.\n\n```\n/app\n  /resources\n    /public\n  /src\n    /hello_world\n      core.clj\n  deps.edn\n```\n\n여기서는 이전에 만들어둔 `public` 폴더를 그대로 사용하도록 하겠습니다.\n`wrap-resource` 를 미들웨어에 추가하고 자원을 저장할 경로로 `public` 폴더를 지정합시다.\n파일 업로드를 처리할 준비가 끝났습니다.\n이제 업로드 요청을 받았을 때 파일이 어떤 식으로 `request-map` 에 실리는지 살펴봅시다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.resource :refer [wrap-resource]]\n            [ring.middleware.params :refer [wrap-params]]\n            [ring.middleware.multipart-params :refer [wrap-multipart-params]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [{params :params}]\n  (prn params)\n  (response \"\"))\n\n(def reloadable-app\n  (-> handler\n      wrap-params\n      wrap-multipart-params\n      (wrap-resource \"public\")))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n{' '}\n\n<br />\n\n```clojure\n{\"test\" {:filename \"20210805_145756.jpg\",\n         :content-type \"image/jpeg\",\n         :tempfile #object[java.io.File 0x805f6d6 \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T/ring-multipart-15013718029732306064.tmp\"],\n         :size 133949}}\n```\n\n_prn 결과_\n\n`request-map` 안에, 키(`test`)에 업로드된 파일의 정보가 들어옵니다.\n`:tempfile` 의 값에 있는 객체를 이용해 파일 내용을 읽거나 저장 할 수 있습니다.\n\n```clojure\n...\n    (:require [clojure.core :refer [bean]]\n              [clojure.java.io :refer [copy file]]\n              ...)\n\n(defn handler [{params :params}]\n  (let [save-path \"/tmp/\"\n        tmp-file (-> (get-in params [\"test\" :tempfile])\n                     bean\n                     :path)]\n    (copy (file tmp-file) (file (str save-path (get-in params [\"test\" :filename])))))\n  (response \"\"))\n```\n\n_업로드한 파일과 동일 이름으로 서버의 `save-path`에 저장_\n\n`:tempfile`의 값은 `java.io.File` 객체입니다. 이 객체를 사용하려면 자바빈 객체의 속성들을\n클로저의 맵으로 바꿔주는 `clojure.core/bean` 이 필요합니다.\n\n```clojure\n(def handler [{params :params}]\n    (prn (bean (get-in params [\"test\" :tempfile]))))\n```\n\n변경된 내용을 확인해봅시다.\n\n```clojure\n{:path \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T/ring-multipart-8223890071443078384.tmp\",\n :freeSpace 398616518656,\n :parent \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T\",\n :directory false,\n :parentFile #object[java.io.File 0x660a21ea \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T\"],\n :name \"ring-multipart-8223890071443078384.tmp\",\n :file true,\n ...}\n```\n\n_bean 에 의해 클로저 맵으로 변경된 java.io.File 객체_\n\n올린 임시 파일이 저장된 경로와 파일명을 알아냈으므로,\n`clojure.java.io/copy, file` 을 통해 파일 객체로 변환하여 복사할 수 있습니다.\n웹 브라우저로 파일 업로드를 테스트해보면 파일이 잘 올라가는 것을 확인할 수 있습니다.\n\n![서버에 올라간 파일](/result-upload-file.png)\n\n## <a name=\"session-and-cookie\"/>세션과 쿠키\n\n이번에는 세션과 쿠키를 다뤄 보겠습니다.\n`ring.middleware.session/wrap-session` 과 `ring.middleware.session/wrap-cookies` 가 필요합니다.\n\n```clojure\n(ns hello-world.core\n      (:require [ring.adapter.jetty :refer [run-jetty]]\n                [ring.middleware.session :refer [wrap-session]]\n                [ring.middleware.cookies :refer [wrap-cookies]]\n                [ring.util.response :refer [response]]))\n\n(defn handler [{session :session}]\n  (let [count (:count session 0)\n        session (assoc session :count (inc count))]\n    (-> (response (str (:count session)))\n        (assoc :session session)\n        (assoc :cookies {:cnt (:count session)}))))\n\n(def reloadable-app\n      (-> handler\n          wrap-session\n          wrap-cookies))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n먼저 웹 서버를 실행시켜 결과를 확인해 보겠습니다.\n\n![](/result-session.png)\n\n`count` 는 세션이 유지되는동안 페이지를 새로고침할 때마다 1씩 증가합니다.\n이는 세션에 담긴 값을 보여주는 응답에서 확인할 수 있습니다.\n마찬가지로 응답 쿠키에 `cnt` 도 잘 들어와 있고요.\n\n세션의 경우 요청에서 받아온 정보를 상태로 보관하고 있다가 응답으로 넘겨줄 수 있도록 구성되어 있습니다.\n세션의 저장 방식으로는 Ring에서 지원하는 `ring.middleware.session.memory/memory-store` 와\n`ring.middleware.session.cookie/cookie-store` 가 있습니다.\n또한 사용자가 직접 정의한 저장 방식을 지정하는 것도 가능합니다.\n\nRing의 기본 저장 방식은 `memory-store` 입니다.\n저장 방식을 변경하려면 미들웨어에서 `:store` 값을 변경하면 됩니다.\n\n```clojure\n(use 'ring.middleware.session.cookie)\n\n(def app\n  (wrap-session handler {:store (cookie-store {:key \"a 16-byte secret\"})})\n```\n\n_https://github.com/ring-clojure/ring/wiki/Sessions#session-stores_\n\n쿠키의 경우 아래와 같은 옵션이 지원됩니다.\n\n> `:domain` - restrict the cookie to a specific domain\n>\n> `:path` - restrict the cookie to a specific path\n>\n> `:secure` - restrict the cookie to HTTPS URLs if true\n>\n> `:http-only` - restrict the cookie to HTTP if true (not accessible via e.g. JavaScript)\n>\n> `:max-age` - the number of seconds until the cookie expires\n>\n> `:expires` - a specific date and time the cookie expires\n>\n> `:same-site` - Specify :strict,:lax, or :none to determine whether cookies should be sent with cross-site requests\n\n다음은 쿠키 설정의 한 예입니다.\n\n```clojure\n...\n\n(defn handler [{session :session}]\n  (let [session (update session :count (fnil inc 0))]\n    (-> (response (str (:count session)))\n        (assoc :session session)\n        (assoc :cookies {:cnt (:count session)\n                         :secret {:value \"foobar\", :secure true, :max-age 3600}}))))\n...\n```\n\n_core.clj/handler_\n\n![저장된 쿠키](/result-cookie.png)\n\n위에서 설정한대로, `secret` 키에 `foobar` 라는 값이 들어있고,\n`Secure: true` 와 `max-age` 가 최근 접속 후 1시간까지로 설정된 것을 확인하실 수 있습니다.\n\n## <a name=\"end-of-document\"/>마치며\n\n이것으로 클로저의 저수준 웹 서버 애플리케이션 개발을 해보았습니다.\n\n이 튜토리얼에서 소개된 내용의 대부분 [ring wiki](https://github.com/ring-clojure/ring/wiki) 를 참고하고 정리한 것입니다.\n더 자세한 내용이 필요하다면 참고하시기 바랍니다.\n\n감사합니다.\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"dw.kim@greenlabs.co.kr\"\n  name=\"김동욱\"\n  description=\"백엔드 개발자\"\n  date=\"2021-09-17\"\n/>\n","excerpt":"목차 Ring 이란간단한 요청 - 응답로컬호스트에 웹서버 띄우기미들웨어 설정해보기정적 자원을 서빙 해보기파라미터들 다루기세션과 쿠키마치며\nRing 이란\n\nRing은 파이썬의 WSGI(Web Server Gateway Interface)에…","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","tags":[{"name":"클로저","slug":"클로저"},{"name":"웹 애플리케이션 라이브러리","slug":"웹-애플리케이션-라이브러리"},{"name":"Ring","slug":"ring"},{"name":"튜토리얼","slug":"튜토리얼"}]},{"slug":"/clojure-bootcamp","title":"그린랩스에서 클로저 시작하기","date":"2021년 9월 13일","body":"\nimport img from './diploma.png';\n\n안녕하세요. 저는 7월에 그린랩스에 백엔드 개발자로 입사한 권정인이라고 합니다. 저는 파이썬으로 6개월간 인턴십을 수행하고, 현업에서는 자바로 1년, 자바스크립트(및 타입스크립트)로 3년 정도 개발을 했습니다. 그러던 중, 그린랩스에서 함수형으로 개발을 한다는 소문을 듣고 입사하게 되었습니다.\n\n그린랩스의 부트캠프에 대해 궁금해하시는 분들이 많다고 들었습니다. (저도 입사 전에 너무 궁금했거든요!) 클로저 무경험인 제가 겪은 부트캠프는 어땠는지 이 글을 통해 공유해보려고 합니다.\n\n## 부트캠프 소개\n\n그린랩스에 백엔드 개발자로 입사하시면 '부트캠프'라는 온보딩 과정이 제공됩니다. 클로저 숙련도에 따라 초급자는 3주, 중급자는 1주에 걸쳐 진행됩니다.\n\n초급자 과정은 <u>Advent of Code 10문제 풀고 리팩토링하기</u>, <u>클로저로 작성한 AWS Lambda 배포해보기</u>, <u>클로저 웹서버 띄워보기</u>로 구성되어 있습니다.\n\n중급자 과정은 <u>Advent of Code 4문제 풀고 리팩토링하기</u>, <u>클로저 웹서버 띄워보기</u>로 구성되어 있습니다.\n\n## 1~2주차\n\n### 📙 클로저 시작하기\n\n문제를 풀기 전에 팀원분이 빌려주신 [{'<'}클로저 시작하기{'>'}(캐린 마이어 저, 인사이트 출판)](https://blog.insightbook.co.kr/2016/03/30/%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90%EA%B3%BC-7%EC%A3%BC-%ED%9B%88%EB%A0%A8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/)라는 책을 2장까지 읽었습니다.\n\n1장에서는 데이터 타입에 대해 공부했습니다.\n\n> 클로저의 데이터 타입은 정수, 실수, 분수, 문자열, 불린(boolean)을 포함하는 **단순값**, 리스트(list), 벡터(vector), 맵(map), 집합(set)을 포함하는 **컬렉션**이 있습니다.\n\n2장에서는 함수(defn), if, reduce, map 등에 대해 공부했습니다.\n\n부트캠프 코치님이 이 정도면 문제 풀기에 충분할 거라 하시더라고요. 문제가 어렵지 않을 거라는 예감이 들었습니다.\n\n### Advent of Code 문제풀기\n\n> 🎄 [Advent of Code(이하 AoC)](https://adventofcode.com)는 2015년부터 시작된 12월 1일부터 25일까지 크리스마스를 테마로 진행되는 문제 풀기 행사입니다.\n\n클로저 초급자인 저는 10개의 AoC 문제를 받았습니다. 동료분들이 한국어로 번역한 문제를 제공해 주어, 문제를 푸는 데만 시간을 쏟을 수 있었습니다. 한국어로 번역된 문제는 [그린랩스 GitHub](https://github.com/green-labs/bootcamp-aoc/tree/main/translations)에 공개되어 있습니다.\n\n제가 풀었던 기초적인 문제를 하나 살펴보겠습니다.\n\n**주어진 입력의 숫자를 더할 때마다 나오는 숫자 중, 처음으로 두 번 나오는 숫자를 구하시오.**\n\n문제의 입력 예로 `+3 +3 +4 -2 -4`를 들어 봅시다. `3(+3) -> 6(+3) -> 10(+4) -> 8(-2) -> 4(-4) -> 7(+3) -> 10(+3)` 와 같이 입력 순서에 따라 수를 반복하여 더합니다. 그러면 `10`이 처음으로 두 번 나오는 것을 발견할 수 있습니다. 이 입력 예의 답은 `10` 입니다.\n\n문제가 어렵지 않죠? 진짜 문제는 자바스크립트 코드밖에 떠오르지 않는 제 머릿속이었습니다...\n\n```javascript\nlet seen = new Set();\nlet sum = 0;\n\nfor (let index = 0; ; index++) {\n  sum += input[index % input.length];\n  if (seen.has(sum)) break; // 두 번 나오는 숫자가 있을 경우 break\n  seen.add(sum);\n}\n\nconsole.log(sum); // 답\n```\n\n자바스크립트 풀이와 비슷한 방법으로 클로저 코드를 작성해 보았습니다. 클로저에서는 `loop/recur`를 사용하여 코드를 반복 실행할 수 있었습니다. `#{}`은 클로저에서 집합을 만드는 표현입니다.\n\n```clojure\n(loop [input (cycle input)\n       sum 0\n       seen? #{}]\n  (let [sum (+ sum (first input))]\n    (if (seen? sum) ; 두 번 나오는 숫자가 있을 경우\n      (println sum) ; 답\n      (recur (next input) sum (conj seen? sum)))))\n```\n\n### 매일 오후 5:30 피드백의 시간\n\n문제를 풀다 보면 어느새 리뷰 시간인 오후 5시 30분이 되었고, 회의실이나 개더타운 앱에서 코드를 함께 보며 리뷰를 했습니다. 많은 피드백을 받았지만, 그중 몇 가지만 정리해 보겠습니다.\n\n1. 코드 스타일\n\n   처음에는 코드 스타일을 개선하라는 의견을 많이 받았습니다. 클로저에 익숙하지 않은 채로 작성하여 클로저에 어울리지 않는 코드를 많이 작성했습니다. 함수형 언어는 **가독성**이 높은 것이 장점이라는데, 뜻밖에도 제가 함수형 언어로 짠 코드는 다음날이 되면 저 자신도 읽지 못하는 사태가 벌어지곤 했습니다. 😂\n\n   동료 분들이 클로저 코드 스타일을 개선하는 데 도움이 되는 문서들을 공유해주셨습니다.\n\n   - [https://guide.clojure.style/](https://guide.clojure.style/)\n   - [https://bsless.github.io/code-smells/](https://bsless.github.io/code-smells/)\n\n2. 쓰레딩 매크로를 사용하기\n\n   ```clojure\n   (update (assoc {:name \"Socrates\", :age 39} :hair-color :gray) :age inc))\n\n   ;; 쓰레딩 매크로 사용\n   (-> {:name \"Socrates\", :age 39}\n       (assoc :hair-color :gray) ; 위의 식을 평가한 결과가 assoc 뒤의 첫번째 인자로 삽입된다\n       (update :age inc)) ; 위의 식을 평가한 결과가 update 뒤의 첫번째 인자로 삽입된다\n   ```\n\n   1번째 줄의 코드와 4~6번째 줄의 코드는 같은 동작을 합니다. `->` 쓰레딩 매크로를 사용하면 이전 식을 평가한 결괏값이 첫 번째 인자로 사용되기 때문이죠. 이전 식의 평가치를 마지막 인자로 사용하는 `->>` 쓰레딩 매크로도 있습니다. 쓰레딩 매크로를 사용하면 순서가 드러나기 때문에 가독성이 더 높아집니다.\n\n3. 함수 잘 나누기\n\n   ```clojure\n   ;; 줄줄 풀어서 문제를 푼 예\n   (->> input\n        (reduce (fn []\n          ; 문자열 파싱하기\n        )\n        (filter (fn []\n          ; 값이 유효한지 검사하기\n        )\n        count)\n\n   ;; 함수를 잘 나눈 예\n   (->> (parse input)\n        (filter valid?)\n        count)\n   ```\n\n   함수를 잘 나눠 추상화 수준을 높이면 어떤 로직을 처리하고자 하는지 쉽게 파악할 수 있습니다. 함수를 잘 나눈 예를 보면, 'input을 파싱하고 유효한 값을 count 하려는' 의도를 쉽게 읽을 수 있습니다.\n\n4. 문제 많이 풀기\n\n   처음부터 문제 하나를 완벽하게 풀려고 드는 것보다, 일단 단순 무식한 해법으로라도 문제를 많이 풀어보는 접근법이 더 좋았습니다. 어차피 배우면서 고쳐야 하기 때문이죠!\n\n### 끝나지 않는 리팩토링\n\n위에서 풀었던 문제를 `loop/recur` 대신 `reduce`로 리팩토링해 보기로 했습니다. `reduce`는 시퀀스를 하나의 값으로 축약하는 함수입니다. `reduce`는 출력을 예상할 수 있어, 그렇지 못한 `loop/recur`보다 간단한 코드를 만들 수 있습니다. 답을 찾으면 바로 반환하는 `loop/recur`에 비해 모든 값을 확인해야 하는 `reduce`가 더 비효율적이라고 생각했지만, 클로저의 `reduce`에는 중간에 탈출할 수 있는 `reduced`가 있어 그런 비효율도 피할 수 있습니다.\n\n```clojure\n(reduce\n  (fn [{:keys [sum seen?]} x]\n    (let [sum (+ sum x)]\n      (if (seen? sum) ; 두 번 나오는 숫자가 있을 경우\n        (reduced sum) ; 답\n        {:sum sum :seen? (conj seen? sum)})))\n  {:sum 0 :seen? #{}} (cycle input))\n```\n\n각 반복 단계마다 `sum`을 구하여 `seen?`에 추가해두고, 다음 단계에서 이전에 본 `sum`들을 `seen?`에서 확인하는 방식으로 문제를 풀 수 있었습니다. `if` 의 조건식인 `(seen? sum)` 은 `seen?` 집합에 `sum`이 있으면 그 값을 반환하므로 참으로 평가됩니다. (클로저에서는 `false`, `nil`을 제외한 모든 값이 참으로 평가(truthy)됩니다.)\n\n### 지연 시퀀스\n\n며칠 후엔 클로저의 지연 평가라는 개념을 배우게 되었습니다. 지연 평가는 실제로 필요해지는 순간까지 평가를 미루는 방법인데요. 이로 인해 클로저에서는 무한한 시퀀스를 다룰 수 있다고 합니다. `range` 함수로 무한 시퀀스를 쉽게 만들 수 있습니다.\n\n```clojure\n(range 5) ; => (0 1 2 3 4)\n(range 5 10) ; => (5 6 7 8 9)\n(range) ; => (0 1 2 3 4 5 6 7 8 9 10 ...)\n(take 10 (range)) ; => ?\n```\n\n`range`함수는 인자 없이 사용하면 위 예시의 3번째 줄처럼 무한한 시퀀스를 생성합니다. 3번째 줄을 실제로 평가하면 오류가 발생합니다.\n\n![Crash](./crash.png)\n4번째 줄을 평가하면 어떤 일이 일어날까요? `take` 함수는 시퀀스 앞에서 n개의 요소를 가져오는 함수입니다. 오류가 날 것으로 생각할 수도 있지만, 오류 없이 `(0 1 2 3 4 5 6 7 8 9)`가 반환됩니다. 무한 시퀀스를 생성한 후 10개의 값을 가져오는 게 아니라, 실제로 필요한 10개의 요소만을 생성하는 것이죠. 지연 시퀀스의 힘이 느껴지시나요?\n\n지연 시퀀스를 사용해서 다시 문제를 풀어봅시다.\n\n```clojure\n(defn first-duplicate\n  [input]\n  (reduce (fn [seen? x]\n            (if (seen? x) ; 두 번 나오는 숫자가 있을 경우\n              (reduced x) ; 답\n              (conj seen? x)))\n          #{} input))\n\n(->> (cycle input) ; (1)\n     (reductions +) ; (2)\n     first-duplicate) ; (3)\n```\n\n`reduce`를 사용하여 시퀀스의 처음 중복되는 숫자를 찾는 함수 `first-duplicate`를 작성했습니다.\n\n(1) 입력을 무한히 반복해서 넣습니다.  \n(2) 더하기(+)를 적용한 시퀀스를 생성합니다. `reductions`는 입력에 함수(여기서는 +)를 적용한 지연 시퀀스를 생성하는 코어 함수입니다.  \n(3) 첫 번째 반복되는 숫자를 찾습니다.\n\n저는 리팩토링을 통해 무엇을 얻었을까요? `reduce`를 사용한 풀이에서는 현재 값을 더하고 중복 여부를 확인하는 일을 한 함수 안에서 모두 했습니다. 개선된 풀이에서는 함수들을 작은 역할로 분리하여 가독성과 재사용성을 높일 수 있었습니다. `first-duplicate` 함수는 어떤 컬렉션에 대해서도 사용할 수 있어 재사용성이 높습니다. 또한 `reductions`와 같은 코어 함수를 잘 활용해서 코드가 간결해졌습니다.\n\n어떤 언어든지 잘 활용하기 위해서는 언어가 제공하는 라이브러리에 익숙해야 할 것입니다. 특히나 클로저에는 강력한 코어 함수가 많아서 이들을 잘 활용하면 코드 품질이 극적으로 향상되는 것 같습니다. 이 글에서 소개한 문제 외에도 여러 문제를 풀면서 `juxt`, `frequencies` 등 유용한 코어 함수들을 접할 수 있었습니다. 코드 리뷰를 받다 보면, '이럴 때 이 함수!' 하면서 다들 보따리에서 하나씩 꺼내 주시기도 합니다. 특히 문제를 풀려는 방식과 의도를 잘 전달했을 때 그런 유용한 피드백을 더 많이 받을 수 있었던 것 같습니다.\n\n## 3주차\n\n3주차에는 클로저 관련 도구에 익숙해지기 위해 <u>클로저로 작성한 AWS Lambda 배포해보기</u>와 <u>클로저 웹서버 띄워보기</u>를 실습했습니다.\n\n### 클로저로 작성한 AWS Lambda 배포해보기\n\nAWS Lambda가 지원하는 런타임의 목록에는 클로저가 명시되어 있지 않습니다. 하지만 JVM 기반 언어를 지원하기 때문에 클로저를 사용할 수 있습니다. 동료들이 작성해 둔 매뉴얼을 보며 Lambda 함수를 몇 가지 만들어보는 실습을 했습니다. 이 과정은 다른 언어와 비슷합니다. 소스 코드와 dependency를 묶은 패키지를 생성하고 AWS에 올리는 방식입니다.\n\n### 클로저 웹서버 띄워보기\n\n그린랩스에는 농사에 관한 정보를 한눈에 볼 수 있는 '팜모닝'이라는 서비스가 있습니다. 이 서비스의 백엔드는 클로저로 개발되어 있어요. 클로저 웹 프로젝트에 친숙해지기 위해, 그리고 앞으로 실제 개발에 사용하기 위해 로컬에서 웹서버를 띄워보는 실습을 했습니다.\n\n![farmmorning](./farmmorning.png)\n\n팜모닝 서비스 개발자분들의 도움을 받아 IDE를 설정하고 구조를 살펴봤습니다. 이 프로젝트는 [ring](https://github.com/ring-clojure/ring), [reitit](https://github.com/metosin/reitit), [honeysql](https://github.com/seancorfield/honeysql), [lacinia](https://github.com/walmartlabs/lacinia), [hikari-cp](https://github.com/tomekw/hikari-cp) 등의 오픈 소스로 구성되어 있는데요. 하나하나 역할을 이해하고 코드를 눈에 익히다 보니 일주일이 금방 지나갔습니다.\n\n곧 클로저 웹서버 구성 튜토리얼도 블로그를 통해 공개될 예정이라고 하니 기대해주세요!\n\n## 🎓 졸업\n\n<div style={{ width: 50 + '%', maxWidth: 354 + 'px', margin: '0 auto' }}>\n  <img src={img} />\n</div>\n\n이름이 부트캠프라 처음엔 겁나기도 했지만 되돌아보니 사실 신규입사자에 대한 그린랩스 개발팀의 열렬한 환영이었던 것 같습니다.\n\n귀여운 졸업장도 받고 부트캠프도 끝났지만, 저의 클로저 프로그래밍은 이제 시작입니다. 실무에 투입된 지 한 달 정도 되었는데, 실무에서 쓰이는 클로저는 AoC 문제처럼 복잡하고 어렵진 않지만 고민해야 할 부분이 더 많습니다. 실제 세상에는 예외가 많아서 코드가 지저분해지기 쉽기도 하고요. 그런 와중에도 아름다운 코드를 놓치지 않는 멋진 개발자가 되어야 합니다.\n\n부트캠프는 클로저뿐 아니라 동료들과도 가까워질 수 있는 시간이었습니다. 처음 프로젝트 설정에 도움을 주셨던 분들, 코드를 리뷰해주시는 분들, 같이 밥을 먹으며 문제에 대한 생각을 나누었던 분들, 부트캠프를 응원해주시는 분들, 같이 리뷰를 받으며 더 좋은 코드를 쓰기 위해 고민했던 분들 모두 감사드립니다.\n\n덕분에 부트캠프 과정을 재미있고 뜻깊게 보냈습니다. 앞으로 그린랩스에서의 여정도 즐거울 것이라는 기대가 됩니다.\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"jungin.kwon1@gmail.com\"\n  name=\"권정인\"\n  description=\"백엔드 개발자\"\n  date=\"2021-09-13\"\n/>\n","excerpt":"안녕하세요. 저는 7월에 그린랩스에 백엔드 개발자로 입사한 권정인이라고 합니다. 저는 파이썬으로 6개월간 인턴십을 수행하고, 현업에서는 자바로 1년, 자바스크립트(및 타입스크립트)로 3년 정도 개발을 했습니다. 그러던 중, 그린랩스에서 함수형으로…","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","tags":[{"name":"Clojure","slug":"clojure"}]},{"slug":"/algebraic-data-type","title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021년 8월 31일","body":"\n### 대수적 데이터 타입(ADT: Algebraic Data Type)이란?\n\n대수적 데이터 타입에는 곱타입(product type)과 합타입(sum type)이 있습니다.<br /><br />\n\n#### 곱타입(Product type)\n\n<br />\n\n```reason\ntype boolAndInt = (bool, int)\n```\n\n`boolAndInt` 타입은 bool 타입과 int 타입을 가지는 튜플 타입입니다. `boolAndInt` 타입이 표현할 수 있는 데이터의 개수는 int 타입으로 표현할 수 있는 수([-2^31 .. 2^31-1]) 곱하기 2 입니다.\n\n```reason\n(true, 1)\n(false, 1)\n(true, 2)\n(false, 2)\n...\n```\n\n그래서 튜플은 <b>곱타입(product type)</b>이라고 합니다. 튜플, 레코드 등은 곱타입에 속합니다.<br /><br />\n\n#### 합타입(Sum type)\n\n<br />\n\n```reason\ntype boolOrInt = Bool(bool) | Int(int)\n```\n\n`boolOrInt` 타입은 bool 혹은 int 중 하나가 되는 배리언트입니다. `boolOrInt`로 표현할 수 있는 데이터의 개수는 int 타입으로 표현할 수 있는 수([-2^31 .. 2^31-1]) 더하기 2 입니다.\n\n```reason\ntrue,\nfalse,\n1,\n2,\n...\n```\n\n그래서 배리언트는 <b>합타입(sum type)</b>이라고 합니다. 배리언트, 태그드 유니언 등은 합타입에 속합니다.\n\n대수적 데이터 타입이란 위의 예와 같이 곱하기 혹은 더하기로 조합된 데이터 타입을 말합니다. 예를 들어 어떤 두 개의 타입 A와 B를 곱하거나 더해서 C라는 타입으로 조합하면, 이것을 대수적 데이터 타입이라고 부를 수 있습니다.\n\n숫자를 곱하거나 더하듯이, 숫자 대신 타입을 곱하거나 더하는 대상으로 사용하기 때문에 대수적(algebraic)이라고 합니다.\n\n### 대수적 데이터 타입으로 본 리액트 상태관리\n\n아래 리액트 컴포넌트는 bool과 int 타입, 두 개의 상태를 갖고 있습니다.\n\n```reason\n@react.component\nlet make = () => {\n  let (isError, setError) = React.useState(_ => false)\n  let (data, setData) = React.useState(_ => 1)\n\n  ...\n}\n```\n\n이 컴포넌트가 가질 수 있는 상태는 위에서 살펴본 곱타입과 같이 int로 표현할 수 있는 정수의 개수 곱하기 2가 됩니다. 즉, 상태가 하나씩 늘어날 때마다 컴포넌트는 곱으로 증가하는 상태를 가지게 됩니다. 상태가 늘어날수록 컴포넌트의 복잡도는 곱으로 늘어납니다.\n\n```reason\ntype status = (bool, int)\n\n@react.component\nlet make = () => {\n  let ((isError, data), setStatus) = React.useState(_ => (false, 1))\n\n  ...\n}\n```\n\n두 개의 상태 값을 하나의 튜플로 만들고 useState를 하나만 사용하더라도, 상태가 줄어들어 컴포넌트의 복잡도가 낮아지지 않았다는 것을 알 수 있습니다. 왜냐하면 튜플은 곱타입이고, 여전히 int로 표현할 수 있는 정수의 개수 곱하기 2의 상태값을 갖고 있기 때문입니다. 레코드나 오브젝트로 튜플을 대체해도 마찬가지입니다. 레코드와 오브젝트 모두 곱타입이기 때문입니다.\n\n### 합타입으로 상태를 정의하자.\n\n자바스크립트에는 배리언트나 태그드 유니언이 없기 때문에, 보통 오브젝트로 데이터를 모델링하는 경우가 많습니다. 자바스크립트 라이브러리인 [swr](https://swr.vercel.app/ko)도 데이터 요청 응답의 결과를 오브젝트로 반환합니다.\n\n```reason\n// 리스크립트의 레코드로 바인딩 한 swr의 응답 결과\nlet {data, error} = Swr.useSwr(url, fetcher, options)\n```\n\n이 경우 총 4가지의 상태가 존재할 수 있습니다.\n\n- data(X), error(X) => 로딩중\n- data(O), error(X) => 성공\n- data(X), error(O) => 에러\n- data(O), error(O) => ??\n\nerror와 data는 런타임에 동시에 존재할 수는 있지만, 양립할 수 없는 상태라고 볼 수 있습니다. 즉, error와 data를 곱타입이 아닌 합타입으로 모델링한다면, 상태를 줄이고 복잡도를 낮출 수 있습니다.\n\n자바스크립트에는 적절한 데이터 타입이 존재하지 않지만, 타입스크립트에서는 [서로소 합집합](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#discriminating-unions) 타입, 리스크립트에서는 배리언트 타입을 이용하여 합타입으로 상태를 모델링 할 수 있습니다. 그리고 모든 상태에 대해 대응하였는지 여부까지 컴파일 타임에 체크가 가능합니다.\n\n```reason\nmodule Orders = {\n  type result = Loading | Loaded(Js.Json.t) | Error(Js.Promise.error)\n\n  let use = () => {\n    let {data, error} = Swr.useSwr(url, fetcher, options)\n\n    switch error {\n    | Some(error') => Error(error')\n    | None =>\n      switch data {\n      | Some(data') => Loaded(data')\n      | None => Loading\n      }\n    }\n  }\n}\n\nlet status = Orders.use() // Loading | Loaded | Error\n```\n\n배리언트 타입의 응답 데이터를 반환하는 커스텀 훅을 만들어서 상태를 다시 정의할 수 있습니다. 합타입으로 상태를 정의하면 얻을 수 있는 이점이 있습니다.\n\n- 직교(orthogonal)하는 상태로 컴포넌트의 상태를 정의할 수 있습니다.\n- 불필요한 상태를 제거하여 컴포넌트의 복잡도를 줄일 수 있습니다.\n\n### 합타입과 패턴매칭\n\n합타입으로 조합된 타입들 각각은 동시에 존재할 수 없습니다. 리스크립트에서 패턴매칭은 모든 가능한 경우를 처리했는 지(Exhaustiveness checking)를 컴파일러가 보장해줍니다. 그래서 배리언트 타입의 상태와 함께 사용하면, 가능한 모든 상태에 대한 처리를 했는지 컴파일 타임에 체크할 수 있습니다.\n\n```reason\nswitch status {\n| Loading => <Loading />\n| Error(error) => <Error error />\n| Loaded(orders) => <Orders orders />\n}\n```\n\n### 결론\n\n일견 복잡해보이는 구조의 데이터도 결국 원시 타입의 자료형으로 이루어졌을 것입니다. 만약 어떤 데이터가 원시 타입의 값을 합과 곱으로 조합한 대수적 데이터 타입이고, 그 데이터를 더하거나 곱할 수 있는 연산을 정의한다면, 복잡해 보이는 데이터도 더하고 곱할 수 있습니다.\n역으로, 대수적 데이터 타입으로 데이터를 바라보면 합과 곱이라는 연산으로 데이터를 모델링하거나, 복잡한 구조로 보이는 데이터의 구조를 쉽게 파악할 수 있습니다.\n\n리액트 컴포넌트의 상태는 컴포넌트의 복잡도를 결정합니다. 합타입을 이용하여 직교하는 상태로 정의하면 복잡도를 낮출 수 있습니다.\n\n<br />\n<br />\n<Author\n  email=\"woonki.moon@gmail.com\"\n  name=\"문운기\"\n  description=\"프론트엔드 개발자\"\n  date=\"2021-08-31\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [Algebraic data type - Wikipedia](https://en.wikipedia.org/wiki/Algebraic_data_type)\n","excerpt":"대수적 데이터 타입(ADT: Algebraic Data Type)이란? 대수적 데이터 타입에는 곱타입(product type)과 합타입(sum type)이 있습니다.\n\n곱타입(Product type)\ntype boolAndInt = (bool, int…","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","tags":[{"name":"Algebraic Data Type","slug":"algebraic-data-type"},{"name":"ReScriptReact","slug":"re-script-react"}]},{"slug":"/start-your-clojure-project-now-2","title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021년 6월 1일","body":"\n[다음글](https://freshcodeit.com/how-to-stop-being-afraid-of-clojure)을 번역했습니다.\n\n## 3. 클로저의 여러 모습\n\n클로저는 단지 [웹](https://freshcodeit.com/services/web-development)이나 [모바일 개발](https://freshcodeit.com/services/mobile-development) 뿐만 아니라, 데이터 사이언스와 DL/ML([incanter](https://github.com/incanter/incanter), [scicloj](https://github.com/scicloj))에도 활발히 활용되고 있습니다.\n\n아직 개인적으로 이 분야의 일을 경험하진 못했습니다. 하지만 DSL의 경험은, 클로저의 우아함을 다시금 느껴볼 수 있게 해줬습니다.\n\n### 3.1 DSL (domain specific language)\n\n도메인 특화 언어는 특정한 문제를 풀기 위한 한 단계 더 추상회된 언어입니다. 클로저에서 DSL은 주로 데이터 구조로 표현됩니다. 아래의 [honeysql](https://github.com/seancorfield/honeysql) 예제를 볼까요.\n\n```clojure\n{:select [:a :b :c]\n :from   [:foo]\n :where  [:= :f.a \"baz\"]}\n```\n\n이처럼 컨텍스트에 구애받지 않는 문법은 DSL를 커스터마이즈 할 수 있도록 합니다.\n\n좀 더 현실적인 예를 들어보겠습니다. 언젠가 [searchkit](https://demo.searchkit.co/)과 비슷한 GUI 필터링 모드를 만들어야 했었는데요, SQL 과 복잡한 논리 표현을 이용해서 GUI 필터를 확장하는 것이 요구사항이었습니다.\n\n이전 GUI 에서의 필터 조건은 오직 AND만 쓰거나 OR만 쓰거나 둘 중 하나였기 때문에, 그 둘을 동시에 사용하거나 다시 그룹핑 하는 것이 불가능했습니다.\n\n```clojure\ncondition_1 AND (condition_2 OR condition_3)\n```\n\n문제는 [ElasticSearch SQL JDBC](https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-sql.html) driver가 SQL 쿼리들을 올바른 ElasticSearch 쿼리에 맵핑하지 않는 것에 있었습니다.\n\n팀 내부에선 SQL 쿼리를 파싱해서 그와 동형인(isomorphic) Elasticsearch 쿼리로 바꾸는 일을 진행해야 했습니다. 동시에 컨텍스트에 기반해 에러 하이라이팅과 쿼리 요소들을 자동완성해주는 (예약어와 식별자 등) 기능을 구현하는 것도 필요했고요.\n\n예를 들어, 사용 가능한 컬럼들을 드랍다운으로 모아서 보여주거나, BETWEEN 과 같은 오퍼레이터를 숫자 필드에서 사용할 수 있도록 하는 일들이 전부 일의 범주에 포함되었습니다.\n\n[클로저는 이 작업에 완벽히 적합](https://freshcodeit.com/services/clojure-development-company)한 언어였습니다. **클로저의 동형성(homoiconicity)와 데이터 지향 접근이 바로 해결**이었죠. 다시 한번 구현해야하는 개념을 집어보면,\n\n1. SQL 문자를 추상 구문 트리로 바꿈 (AST, abstract syntax tree)\n2. AST를 ElasticSearch 쿼리로 바꿈\n\n첫 번째 단계에선 Instaparse 라이브러리([instaparse](https://github.com/Engelberg/instaparse))가 쓰였습니다.\n\n컨텍스트에 구애받지 않는 문법인 Backus-Naur 형태(BNF) 표현을 실행 가능한 파서로 바꾸는 데 쓰이는 라이브러리로, 문자열을 입력받아 AST를 중첩된 클로저 컬렉션의 형태로 출력하는 역할을 합니다.\n\n결과로 받은 파스 트리의 모든 노드는 자동 완성 기능에 필요한 유용한 메타데이터 정보를 포함하고 있습니다. (라인에 맵핑되거나 인풋 문자의 컬럼에 해당하는) 또한 Instaparse는 파싱 실패에 대한 자세한 정보를 줄과 에러 구문의 컬럼등에 대해서 제공합니다.\n\n두번째 스테이지는 AST를 순회하며 각각에 패턴 매칭을 적용하며 구현될 수 있습니다.\n[여기](https://gist.github.com/idozorenko/a0c5bb5e5d38a5ba92cca7f43d1d3392) 이 접근에 대한 간략한 요약이 있는데요, 위의 케이스와 우리가 한 구현이 다른 점은, 우리는 수학적 AST 표현을 바로 클로저 코드로 바꿔 평가(evaluation)까지 해버렸다는 점입니다.\n\n### 3.2 클로저스크립트\n\n지금 현재는 자바스크립트가 브라우저, 그리고 많은 모바일 기기에서 가장 우세를 점하고 있는 언어입니다.\n\n[클로저스크립트](https://clojurescript.org/)는 **클로저를 자바스크립트로 변환시켜주는 컴파일러를 포함**합니다. 내부에서 구글의 Closure 도구들과 minification 컴파일러를 사용하는데요, ClojureScript는 컴파일러 말고 그 언어 자체를 의미하기도 합니다. (줄여서 cljs)\n\ncljs는 클로저의 모든 장점 - 데이터 구조, 함수형 접근, 매크로 등등 - 을 전부 포함함과 동시에, 언제든 프로덕션에 사용 가능한 생태계와 라이브러리들을 제공합니다. 클로저와는 플랫폼 레벨의 차이밖에 느껴지지 않는 셈이죠.\n\n**클로져 백엔드 + cljs 프론트엔드를 사용하면 한 언어와 공유된 모드로 풀스택 개발**이 가능합니다! npm 패키징과의 매끄러운 연결도 [shadow-cljs](https://github.com/thheller/shadow-cljs) 컴파일러를 통해 구현되어 있습니다.\n\n그리고 [cljs](https://cljsrn.org/)는 [React Native 모바일 앱](https://freshcodeit.com/portfolio-cases/tipster)을 만들 때 쓰일 수도 있습니다.\n\n## 4. ... 단점들?\n\n다른 어떤 기술과 마찬가지로, 클로저도 수많은 장점에 대한 트레이드 오프가 있습니다.\n\n- 클로저의 영속 자료 구조는 자바의 그것에 비해 [약간 덜 효율적](http://www.diva-portal.org/smash/get/diva2:1424342/FULLTEXT01.pdf)입니다. 성능을 향상하기 위한 팁들 - 벡터의 [transient](https://clojure.org/reference/transients) 버전을 사용한 백터, 맵, 셋을 사용한다거나 - 이 있지만, 동시 접근이 필요할 경우엔 지양됩니다.\n\n- 클로저는 호스트 플랫폼의 기능을 전부 사용할 수 있지만(자바 라이브러리들과 데이터 구조들), 통상적으로 동일한 자바나 스칼라 코드보다 약간 느립니다. 대부분의 애플리케이션에 대해서는 미미한 차이겠지만, 정말 높은 성능을 요구하는 시스템이나 모듈에 적용할 때는 신중해야 합니다.\n\n- 클로저는 또한 초심자에게 그리 배우기 쉬운 언어는 아닙니다. 하지만 대부분은 함수형 접근 때문에 어려운 것이 아니라 호스팅 플랫폼과의 상호작용 부분을 어려워 합니다. 시간을 갖고, 연습을 하다 보면 별 문제가 아니게 될 것입니다.\n\n- 모든 걸 고려해 보았을 때, 제 생각에 가장 심각한 클로저의 단점은 '마케팅' 입니다. 클로저는 최소한의 문법과, 잘 짜여진 생태계, 그리고 높은 잠재성을 가진 단순한 언어입니다. 클로저를 알기 전과 후는 명백히 다를 것입니다!\n  하지만 리습으로 부터 물려받은 과도한 복잡성과 부족한 표준 등의 클로저가 갖고 있는 '대중적 이미지' 는 실제로는 완전 반대임에도 불구하고 새로 유입된 개발자들로 하여금 클로저(혹은 클로저스크립트)에 투자하기를 꺼리게 만듭니다. 클로저를 마스터함으로써 얻을 수 있는 이득이 훨씬 큼에도 불구하고요!\n\n## 5. 뉴비를 위한 팁: 클로저, 어떻게 시작하면 좋을까?\n\n### 5.1 클로저 마스터의 세가지 원칙\n\n1. 연습하세요. 모든 기술에 통용되는 조언입니다. 만약 함수형 프로그래밍을 막 시작하셨다면, [Advent of Code](https://adventofcode.com/)나 [Project Euler](https://projecteuler.net/)들을 풀면서 언어에 대한 감각을 익히셔야 합니다. 저는 몇 개의 사이드 프로젝트에 클로저를 적용해보며 실력이 부쩍 늘었었습니다.\n\n2. 다른 사람들에게 배우세요. 커뮤니티나 클로저/리습 관련 서적을 참고하세요. 정말 [재미있고](http://landoflisp.com/) [훌륭한](https://www.braveclojure.com/) 자료들을 찾으실 수 있습니다.\n\n3. [리치 히키의 발표](https://awesomeopensource.com/project/tallesl/Rich-Hickey-fanclub)를 들으세요. 클로저 기능과 기술 솔루션들을 언어 창시자에게서 직접 명료하고 단순한 표현으로 들을 수 있습니다. 클로저리안들의 영감의 원천입니다.\n\n### 5.2 도움이 되는 링크\n\nClojure-how-to와 튜토리얼 링크를 공유합니다.\n\n- [클로저리안](https://clojurians.slack.com/ssb/redirect) <br />\n  슬랙 Clojure 채널입니다. 초보자들을 위한 섹션 (beginners, clojure, clojurescript)과\n  구직에 대한 정보(jobs, remote-jobs)도 제공합니다.\n\n- [클로저 레딧](https://www.reddit.com/r/Clojure) <br />\n  레딧의 클로저 하위 게시판입니다. 각종 발표와 라이브러리, 강의에 대한 정보가 공유됩니다.\n\n- [클로저 툴박스](https://www.clojure-toolbox.com/) <br />\n  최신의 클로저-클로저스크립트 라이브러리들의 모음입니다.\n\n- [리치 히키의 팬클럽](https://awesomeopensource.com/project/tallesl/Rich-Hickey-fanclub) <br />\n  리치 히키의 강연과 인터뷰 모음집입니다.\n\n- [클로저 잡스](https://jobs.braveclojure.com/) <br />\n  클로저 구루가 되실 분들을(이미 되신 분들도 포함해서!) 위한 실질적으로 클로저를\n  사용하는 구직 리스트입니다.\n\n## 6. 요약\n\n- 클로저는 **풀스택 웹개발**과 **모바일 개발**을 위한 언어임과 동시에 **데이터 사이언스, 스크립팅과 DSL에도 적용**될 수 있습니다.\n\n- 클로저는 성능과 재미를 둘 다 잡고자 하는 초보 혹은 숙련된 프로그래머 **모두에게 매력적인 함수형 언어**입니다.\n\n- 리습의 방언으로, [도전을 좋아하는](https://freshcodeit.com/freshcode-post/clojure-development-challenges) 재능있는 개발자들에게 인기 있습니다. 하지만 궁극적으로 **클로저는 개발을 단순화하는데 목적을 두고 만들어졌고, 제 생각엔 정말 완벽하게 목적을 달성**하고 있습니다! <br />\n\n**클로저, 지금 바로 시작하시죠!**\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"tlonist.sang@gmail.com\"\n  name=\"김상현\"\n  description=\"백엔드 개발자\"\n  date=\"2021-06-01\"\n/>\n","excerpt":"다음글을 번역했습니다. 3. 클로저의 여러 모습\n\n클로저는 단지 웹이나 모바일 개발 뿐만 아니라, 데이터 사이언스와 DL/ML(incanter, scicloj)에도 활발히 활용되고 있습니다.\n\n아직 개인적으로 이 분야의 일을 경험하진 못했습니다. 하지만…","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","tags":[{"name":"Clojure","slug":"clojure"},{"name":"functional-programming","slug":"functional-programming"}]},{"slug":"/start-your-clojure-project-now-1","title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021년 5월 30일","body":"\n> 저자와 [freshcodeit](https://freshcodeit.com/)의 허락을 받은 번역입니다. 원글과 차이가 있을 수 있습니다.\n\n> [클로저](https://clojure.org/)는 리습(Lisp)을 기반으로 한 함수형 언어입니다.\n> [번역한 글](https://freshcodeit.com/how-to-stop-being-afraid-of-clojure)에서는 클로저의 탄생배경과 특징, 학습 방법이 구체적으로 잘 소개되어 있습니다.\n> 그린랩스의 주 언어 중 하나인 클로저의 매력을 체험해보시죠!\n\n## 1. 클로저의 역사\n\n### 1.1 리치 히키\n\n클로저는 리치 히키 (Rich Hickey)가 만들었습니다. 클로저 커뮤니티에선 이미 숭배받는 괴짜 프로그래머로, 뉴욕 대학에서 C++를 가르쳤고, 이후 현실 프로세스와 데이터를 정형화하는 다양한 시스템을 개발했습니다. 2005년 안식년을 가지며 개인 프로젝트를 시작했고, 2년 뒤에 클로저의 첫 번째 버전이 탄생했습니다. 오늘날 리치 히키와 그가 CTO로 있는 회사 코그니텍(Cognitect)은 클로저를 위한 상업적 지원을 제공하고 있습니다.\n\n### 1.2 클로저를 쓰는 이유\n\n리치 히키는 클로저를 만든 이유에 대해 다음과 같이 대답했습니다.\n\n\"_왜 굳이 또 언어를 만들었냐고요? 저는 기본적으로_\n\n- _함수형 프로그래밍을 위한_\n- _리습(Lisp)이_\n- _이미 갖춰진 플랫폼과 상생하면서_\n- _동시성 문제를 잘 해결할 수 있기를_\n\n_원했기 때문입니다.\"_\n\n더욱 자세한 스토리는 언어의 창시자가 직접 작성한 \"[클로저의 역사](https://download.clojure.org/papers/clojure-hopl-iv-final.pdf)\"라는 기사에서 확인할 수 있습니다.\n\n**클로저는 어쩌면 당신의 기대만큼 새롭고 독창적인 기능들이 많이 있지는 않을 것입니다.** 당연히 자바와 비교하면 꽤나 실험적인 언어지만, 애초에 리치 히키는 이미 많이 검증된 아이디어와 컨셉을 기반으로 언어를 설계했습니다.\n\n**클로저는 리습의 방언이고, 람다 대수(Lambda calculus)는 일급, 고차함수를 다루는 리습의 핵심 개념입니다.** 다른 말로, 함수가 값처럼 취급되어 인자로도, 리턴 값으로도 쓰일 수 있다는 얘깁니다.\n\n리습은 '코드는 데이터다'라는 아이디어에서 출발했습니다. 리습의 기본 코드 단위는 아래와 같은 s-표현(symbolic expression)입니다.\n\n`(A (B 3) (C D) (()))`\n\n**S-표현**은 리스트와 값들로 구성되어 있는 리스트입니다. 특징으로는 [전위 표현](https://clojurebridgelondon.github.io/workshop/simple-values/prefix-notation.html)(prefix notation)을 사용하기 때문에 첫번째 인자는 함수 혹은 연산자이며, 그 뒤에 오는 값들은 인자로 취급됩니다. (+ 1 2 3) 은 + 연산자를 1 2 3 에 적용하게 되어 6 이라는 결과가 나옵니다.\n\n리습으로 짠 프로그램은 그 자신의 추상 구문 트리(Abstract syntax tree)와 동일합니다. 이 특징은 다른 말로 [동형성](https://en.wikipedia.org/wiki/Homoiconicity)(homoiconicity)이라고 하는데, 이런 특징은 프로그램이 실행 중일 때도 쉽게 수정이 가능하게 하는 (modifying on the fly) 메타 프로그래밍의 새로운 장을 열어줍니다.\n\n클로저는 리습을 현실 세계의 문제를 더 잘 다룰 수 있도록 혁신한 버전입니다. 예를 들어서, 리스트만 있던 리습에 비해 클로저는 맵, 벡터, 셋 과 같은 데이터 자료형이 추가되었습니다.\n\n첫 릴리즈 후 얼마 지나지 않아, 리습에 [매크로](https://clojure.org/reference/macros)라는 개념이 추가됐습니다. 리습 프로그램을 해석하는 과정에 매크로 확장(macro-expansion)이 추가되어, 프로그래머들이 리습을 확장해 사용하는 것이 전보다 훨씬 용이해졌습니다. 하지만, 이러한 용이함은 동시에 발목을 잡기도 했습니다. ([리습의 저주](http://www.winestockwebdesign.com/Essays/Lisp_Curse.html)) 시간이 흐름에 따라 리습 커뮤니티는 마구 확장됨과 동시에 파편화되었고, 잉여스러운 구현들이 넘쳤으며, 통일된 표준을 찾기 힘들었습니다.\n\n리습의 탄생 이후, 커먼 리습을 포함한 여러 방언이 나왔습니다. 하지만 현대 스크립트 언어인 파이썬이나 루비만큼의 인기를 얻진 못했죠. 그래서 클로저의 목표중 하나는 리습의 대중화였습니다. 이 목표는 JVM 플랫폼과 커뮤니티의 도움으로 잘 현실화 되고 있습니다.\n\n### 1.3 통계자료\n\n[클로저 2020의 설문 조사](https://clojure.org/news/2020/02/20/state-of-clojure-2020)에 따르면, 작년 한 해 기업용, 상업용 애플리케이션 개발에 점점 더 많이 사용되고 있음을 알 수 있습니다.\n\n클로저는 꾸준히 새로운 사용자들을 유입하고 있습니다. 2020년에는 응답자 중 15.78%가 처음 사용하기 시작했다고 했습니다. 지금 **클로저를 배우는 것이 시기적절하고 유망한 트렌드**로 보입니다.\n\n더 자세한 내용과 인사이트는 [클로저에 관한 지난 기사](https://freshcodeit.com/how-to-get-started-with-clojure)에서 찾아보실 수 있습니다.\n\n## 2. 클로저를 배우는 세 가지 단계\n\n루스 올슨([Russ Olsen](http://russolsen.com/))가 쓴 \"[Clojure Applied](https://pragprog.com/titles/vmclojeco/clojure-applied/)\"의 서문을 보면, 대부분의 사람들은 클로저를 배울 때 아래의 세 단계를 거칩니다.\n\n첫번째 단계에선 기본적인 문법과 원칙을 학습합니다. 예를 들어 괄호와 꺾쇠 괄호는 언제 어떻게 사용하며 리스트와 벡터의 차이는 무엇인가 등입니다.\n\n중간 단계에선 이제 조각을 맞춰가기 시작합니다. 불변 자료 구조를 적극적으로 사용하게 되고, 고차 함수를 실제 코드에 적용해보기도 합니다.\n\n언어에 대한 이해를 마친 마지막 단계에선, [클로저 생태계](https://freshcodeit.com/freshcode-post/why-clojure-4-tech-reasons)를 탐험하기 시작합니다. 다른 사람들이 만든 방대한 라이브러리와 애플리케이션을 새로운 지식과 접목해 프로그램을 만들어나갑니다.\n\n진짜 재미의 시작이죠!\n\n### 2.1 클로저 기초: 시작해보기\n\n#### 스크립트성 태스크\n\n저는 2013년 텔레콤 부문에서 자바EE 프로젝트를 하며 클로저를 처음 접했습니다. 당시의 메인 웹 애플리케이션은 이제 막 Java7으로 마이그레이션 된 상태였습니다. try-with-resources와 NIO는 있었지만 arrow 함수, 자바 스트림 API나 jshell 같은건 없었습니다.\n\n자바가 꽤 장황한 프로그래밍 언어로 인식된다는건 더 이상 비밀이 아닙니다. IDE, 최신 자바 문법과 API가 이 장황함을 어느 정도 성공적으로 가려줄 수는 있지만 말이죠.\n\n자바16이 현재 최신 버전임에도 불구하고, 젯브레인([JetBrain](https://www.jetbrains.com/lp/devecosystem-2020/java/))의 조사에 따르면 75%의 자바 개발자들이 2020년에도 Java8을 주로 사용하고 있고, 뉴렐릭([New Relic](https://newrelic.com/blog/nerd-life/state-of-java))은 80%가 넘는 상용 애플리케이션이 Java8을 사용하고 있다고 합니다.\n\n자바는 스크립트성 태스크엔 적합하진 않습니다. 이것이 셀레늄 테스트에서 클로저를 고려하게 된 이유 중 하나입니다. 다른 이유는\n\n- 안정적이며 JVM 친화적이다.\n- 코드 재사용성과 중복 방지의 측면에서 자바와 호환성이 좋다.\n- 재컴파일 필요 없이 REPL을 통해 인터랙티브 테스팅이 가능하다.\n- (자바나 스칼라보다) 문법이 간단해서 [QA 엔지니어](https://freshcodeit.com/services/quality-assurance)들이 테스트 케이스를 스스로 수정할 수 있다.\n\n가장 마지막 포인트에 대해선 의견이 분분했습니다. 함수형 언어로의 패러다임 전환은 숙련된 엔지니어들에게도 어려울 것이라는 걱정도 있었습니다. 하지만 팀은 당시 열정으로 가득 차 있었고, 혁신을 수용하는 분위기 속에서 다소 위험을 감수하고 클로저를 시도해보기로 정했습니다.\n\n가장 먼저, 웹사이트와 컨트롤 misc UI 컴포넌트를 탐색하기 위한 헬퍼함수들(helper functions)을 [clj-webdriver](https://github.com/semperos/clj-webdriver)를 사용해 개발했습니다. 그리고 실제 테스트 케이스들을 작성했습니다.\n\nREPL의 장점은 이제 누구나 아는 것이지만, 당시엔 정말 큰 반향을 일으켰습니다. 테스트 케이스들이 콘솔에서 바로(on-the-fly), 컴파일이나 스크립트를 재시작 할 필요 없이 작성되었고, 이 모든 것들이 JVM 위에서 돌아갔습니다. 믿을 수 없었죠!\n\n여기 실제 테스트 케이스의 예시입니다.\n\n```clojure\n(ns project.tests\n  (:use project.utils))\n\n(defcase standart-create-qos \"Create QoS policy\"\n  (select-main-menu \"SLA management\" \"QoS policy\")\n  (press-button \"Create new QoS policy\")\n  (input \"Name\" \"test_qos_2\")\n  (select-option \"Service class\" \"Class G\")\n  (select-option \"Profile type\" \"test_profile\")\n  (set-quality-rule \"For 15 minutes\" \"packet loss rate\" \"in the forward direction\" \"is less than\" \"10\")\n  (wait-response (press-button \"Save\"))\n  (check-row-exists \"test_qos_2\"))\n```\n\n클로저로 작성된 마지막 테스트 케이스들은 읽기 쉽고, 친숙해 보였으며.. 명령형이었습니다! DSL이 [QA 엔지니어](https://freshcodeit.com/freshcode-post/why-quality-assurance-is-so-important)들이 작성한 케이스의 3/4를 커버했습니다. 다른 케이스들은 개발자들이 투입되어야 했는데, 주로 QA를 도와 헬퍼 함수들을 짜는 역할을 보조했습니다.\n\n클로저를 막 시작한 단계에서는 언어의 [최소화된 문법 체계](https://learnxinyminutes.com/docs/clojure/)의 덕을 많이 봤습니다. ([https://learnxinyminutes.com/docs/clojure/](https://learnxinyminutes.com/docs/clojure/)) 괄호에 대한 초보자들의 두려움은 정말 과장된 거라는 생각이 들었어요.\n\n메이저 에디터와 IDE들은 paredit (혹은 parinfer) 플러그인을 지원합니다. 괄호의 짝을 맞춰주거나 실수로 삭제하는 걸 막아주고, 구조 수정을 쉽게 해주는 단축키를 제공해주는 등, 정말 단비와 같은 플러그인입니다. 아래는 구조 수정(structural editing)의 예시입니다.\n\n![https://static.tildacdn.com/tild3265-3938-4033-a230-336433333766/clojure_code.gif](https://static.tildacdn.com/tild3265-3938-4033-a230-336433333766/clojure_code.gif)\n\n아래는 히컵 스타일(Hiccup-style)의 마크업입니다.\n\n![https://static.tildacdn.com/tild6661-3532-4265-b830-393034366431/hiccup_clojure.gif](https://static.tildacdn.com/tild6661-3532-4265-b830-393034366431/hiccup_clojure.gif)\n\n자바 인터롭은 굉장히 직관적입니다. 몇 가지 문법과 함수 호출이 리스트의 첫번째에 있다는 것만 기억하면 간단합니다.\n\n예를 들어 아래의 자바 코드는,\n\n```java\npublic ByteArrayInputStream toInputStream (String s, String charset)\n  throws UnsupportedEncodingException {\n    return new ByteArrayInputStream(s.getBytes(charset));\n}\n```\n\n클로저에서는 아래와 같이 적힙니다.\n\n```clojure\n(defn string->stream [s charset]\n  (-> s\n    (.getBytes charset)\n    (ByteArrayInputStream.)))\n```\n\n또한 클로저는 대부분의 자바 라이브러리와 모듈에 대한 래퍼(wrapper)를 제공합니다. 따라서 같은 코드를 자바를 호출하지 않고 [바이트 스트림](https://github.com/clj-commons/byte-streams)만을 이용해서 재작성할 수 있습니다.\n\n```clojure\n(defn string->stream [s encoding]\n  (to-input-stream s {:encoding encoding}))\n```\n\n통합(integration)의 측면에선, JVM 툴킷이 전부 그대로 클로저에도 적용될 수 있답니다. 예를 들어, 당신이 직접 만든 YourKit이 클로저 앱을 프로파일링 하는데 그대로 사용될 수 있죠.\n\n이렇게 첫 번째 스테이지를 통과하면, 문법과 핵심 구조에 대해서 배우게 됩니다. 명심하세요. 한번 클로저를 시작하게 되면 멈추기가 참 힘듭니다. 계속 계속 파고들게 되니까요!\n\n### 2.2 중급자 과정\n\n#### 다양한 문제들\n\n보통 두 번째 단계가 가장 어렵습니다. 명령형 자바 스타일에서 리습의 스타일로 전환하는 것은 상당히 도전적인 과제입니다. 아무리 최소의 문법만 있다고 해도, 처음엔 큰 도움이 되기 힘들었죠. 이 시점에 풍부한 자료들과 책, 커뮤니티의 도움을 많이 받을 수 있습니다.\n\n우아함과 단순성을 기반으로 한 클로저는, 어쩌면 루빅스 큐브같은 퍼즐 같은 느낌을 줍니다. 복잡하게 느껴질 수도 있지만, 어떻게 동작하는지 파악하는 것은 큰 기쁨이죠.\n\n[Euler 프로젝트](https://projecteuler.net/), [4 clojure](https://www.4clojure.com/problems), [advent of code](https://adventofcode.com/) 등의 사이트를 방문하며 이 단계를 넘어가는 데 큰 도움을 받았습니다. 좀 더 어려운 게임화 과제 (gamification), 실전 테스크들, 그리고 진짜 훌륭한 프로젝트들을 접해볼 수도 있었지만, 저에게 있어 진짜 동기는 [클로저로 일을 하는 것](https://freshcodeit.com/services/clojure-development-company)이었습니다. 그래서 답을 찾아보고 분석하는데 초점을 맞췄습니다.\n\n<br />\n\n#### 함수형 접근\n\n클로저로 데이터 모델링을 하며 마주치는 첫번째 특징은, 친숙한 OOP적 요소가 없다는 것입니다.\n\n자바는 클래스를 정의하고, 그 안에 필드와 메소드를 만들어 객체의 특성과 행동을 정의합니다. 클로저의 함수는 특정 클래스 데이터의 '일부'가 아니라, 그 자체로 데이터를 처리하는 역할을 합니다. 클로저 함수는 네임스페이스라는 기본 단위로 분류됩니다.\n\n클로저는 순수하지 않은 함수의 작성도 허용하지만, 주로 map, reduce, filter, remove 등의 [고차 함수](https://en.wikipedia.org/wiki/Higher-order_function)와 함수의 컴포지션(partial, comp, juxt)을 활용할 것을 권장합니다.\n\n<br />\n\n#### 데이터 지향 접근\n\n{'<'}쉽게 이해하는 클로저{'>'}([https://www.youtube.com/watch?v=aSEQfqNYNAc](https://www.youtube.com/watch?v=aSEQfqNYNAc))에서 리치 히키는 데이터 지향 접근의 장점에 관해 이야기합니다.\n\n자바 데이터는 보통 접근자, 변형자 (혹은 쉽게 getter/ setter)로 접근합니다. 큰 POJO 객체의 경우, 데이터 접근을 위해 많은 보일러 플레이팅이 필요하게 되지요.\n물론 IDE를 통해 제공되는 [롬복](https://projectlombok.org/)과 같은 자동 완성 툴들이 도움을 줍니다. 비슷한 접근으로 자바 14부터는 레코드(Records)를 사용할 수 있습니다.\n\n하지만 아직까지 사용되는 필수 라이브러리를 살펴보면 문제는 여전합니다. 예를 들어 javax.servlet.http.HttpServletRequest 클래스를 한번 들여다보겠습니다.\n\n![https://thumb.tildacdn.com/tild6339-3165-4135-b466-653863346537/-/resize/397x/-/format/webp/HttpServletRequest.png](https://thumb.tildacdn.com/tild6339-3165-4135-b466-653863346537/-/resize/397x/-/format/webp/HttpServletRequest.png)\n\n여기 서로 다른 세 가지의 색으로 표기된 필드는 각각 서로 다른 인터페이스들이 필요합니다. getParameterMap 과 getHeader, remove와 set은 attribute에 사용되고 parameter에는 사용되지 못하는 등, 서로 다른 이름 규칙을 갖고 있습니다.\n\n불편한 인터페이스 외에도 데이터 조작 로직을 재사용할 수 없다는 것과 테스트를 생성하기 복잡하다는 문제도 있습니다.\n\n클로저는 데이터 지향 관점에서 생기는 문제를 그냥 객체를 맵에 맵핑함으로써 해결해버립니다.\n\n![https://thumb.tildacdn.com/tild3665-6261-4536-b061-376331363330/-/resize/560x/-/format/webp/Clojure__data-orient.png](https://thumb.tildacdn.com/tild3665-6261-4536-b061-376331363330/-/resize/560x/-/format/webp/Clojure__data-orient.png)\n\n어떤 데이터든 일반 시퀀스를 조작하듯 다룰 수 있다는 것이 핵심입니다. 그냥 맵이든, 헤더(header)들의 맵이든 어떤 형태의 컬렉션도 쉽게 다룰 수 있습니다. 컬렉션을 다루는 여러 함수는 범용적이기 때문에 일반적으로 훨씬 더 가치가 있습니다.\n\n쓰레딩 매크로 (threading macro) - >> 는 함수 호출을 훨씬 더 편리한 방법으로 작성할 수 있게 해줍니다. 자바의 Stream API 와 비슷하다고 할 수 있습니다.\n\n```clojure\n(->> request\n  :headers\n  (filter #(str/starts-with? % \"my-header\")))\n```\n\n적은 수의 데이터 구조에 함수형 접근이 합쳐지면, 데이터 조작 프로세스를 크게 개선할 수 있습니다. 궁극적으로는 프로그래밍 프로세스를 향상하고 가독성을 증대시킵니다.\n\n<br />\n\n#### 불변 자료 구조\n\n클로저 데이터 구조들은 불변(immutable)하며 영속적(persistent)입니다. 이 말은 '수정'하는 행위는 새로운 데이터를 반환한다는 얘기입니다.\n\n그걸 염두할 때 놀라운 점은, 연산에 걸리는 시간이 알고리즘 복잡도에 [크게 영향을 받지 않는다](https://www.innoq.com/blog/st/2010/04/clojure-performance-guarantees/)는 것입니다. (벡터나 해시맵의 값에 접근하는 시간복잡도는 O(log32(N)입니다))\n\n한 데이터 구조는 과거 버전의 데이터 구조와 같은 [소스를 공유](https://en.wikipedia.org/wiki/Persistent_data_structure#Clojure)하고 있기 때문에, 메모리 소모 측면에서도 큰 변동이 없습니다.\n\n불변 자료구조에서, 객체가 동등하다는 개념은 다른 의미를 갖습니다. 만약 두 객체가 같다면, 그 둘은 한 시점에서만 같은 것이 아니라, **영원히** 같습니다.\n\n이 접근은 멀티쓰레딩 측면에서 굉장히 유용합니다. 컬렉션을 사용할 때 매번 쓰레드 안전을 확인할 필요가 없기 때문이죠.\n\n애플리케이션 상태를 저장하기 위한 실질적인 방법은 쓰레드 안전한 뮤터블 컨테이너 (Var, Atom, Agent, Ref)를 사용하는 것입니다.\n\n클로저는 소프트웨어 트랜잭션 메모리([software transactional memory, STM](https://clojure.org/reference/refs))를 통해 Ref의 트랜잭션 변경을 지원합니다. 이 주제는 다른 글에서 다뤄보겠습니다.\n\n<br />\n\n#### 지연 평가 (lazy evaluations)\n\n클로저는 지연 평가 시퀀스를 지원합니다. 이는 시퀀스에 대한 평가가 미리 이뤄지는 것 (ahead of time)이 아니라 연산의 결과로 그 때 그 때 이뤄짐을 뜻합니다. 지연 함수 (Lazy function)은 지연 시퀀스를 반환하는 함수를 말합니다.\n\n지연 시퀀스로 무한을 표현할 수 있습니다. 만약 2백만 까지의 모든 소수(prime)을 더하는 알고리즘([프로젝트 오일러의 문제](https://projecteuler.net/problem=10))을 짜야한다고 할 때, 다음과 같은 표현이 가능합니다.\n\n```clojure\n(def primes\n  (filter prime? (iterate inc 1)))\n\n(defn solve []\n  (->> primes\n      (take-while #(< % 2E6))\n      (reduce +)))\n```\n\n소수를 판별하는 알고리즘인 prime은 생략하겠습니다. 여기서 primes(s가 추가로 붙었습니다) 함수는, 사실상 존재하는 모든 소수들을 반환할 수 있는 함수입니다.\n이를 가능하게 하는 것이 바로 지연 평가의 요소인 iterate 와 filter 덕분인데요, primes 시퀀스는 실제로 컬렉션 값에 접근 하기 전까지 평가되지 않습니다.\n\ntake-while 도 또한 지연 함수인데요, 따라서 solve의 reduce까지 와서야 컬렉션이 평가되어 하나의 답을 내놓게 됩니다.\n물론 위의 문제는 지연 무한 시퀀스 (lazy inifinite sequence)를 사용하지 않고서도 풀 수 있습니다. for를 사용 할 수도 있고요. 그래도 위의 방법이 훨씬 더 우아하지 않나요!\n\n### 2.3 고급단계\n\n#### 클로저를 이용한 웹 개발\n\n시간이 지나 클로저로 웹 개발을 할 기회가 생겼고, 클로저의 생태계를 탐험하는 세 번째 단계에 오게 되었습니다.\n\n링([Ring](https://github.com/ring-clojure/ring))은 클로저의 웹 개발 표준입니다. 파이썬과 루비에 각각 WSGI와 Rack이 있는것과 비슷합니다.\n\n링 저장소는 다음을 포함합니다.\n\n- request, response, middleware에 대한 스펙과 베이스 코드\n- jetty 웹 서버에 대한 기본 미들웨어 어댑터\n- 문서 (documentation)\n\n모든 현대 클로저 웹 프레임워크는 링 표준을 따르고 있습니다. 이는 아무 변화 없이 다른 플랫폼(Jetty, http-kit, Immutant 등등)에서 애플리케이션을 실행 할 수 있다는 말입니다.\n\n**링이 주는 간편함은 저에겐 거의 혁명이었습니다.** 링이 사용한 함수에 기반한 미들웨어의 개념에 대한 관용적 접근은 오늘날 많은 언어와 프레임워크에 사용되고 있습니다. (NodeJS의 Express도 그 중 하나입니다.)\n\n당시 저는 자바 서플릿과 스프링으로 몇년간 개발을 하고 있던터라, 자연스레 이 미들웨어적 접근을 스프링 부트의 경험과 비교하게 되었습니다. 여기 스프링으로 만든 기본적인 REST 서비스를 동일한 기능을 하는 클로저 코드를 비교한 코드입니다.\n\n- [스프링](https://spring.io/guides/gs/rest-service/) vs. [클로저](https://gist.github.com/idozorenko/2710c607e40acecbcb569b66a34813b2)\n\n저의 첫 번째 클로저 기반의 REST API는 거의 위의 예제처럼 생겼습니다. 아, 당시는 더 최신이었던 compojure-api 대신 compojure 라이브러리를 사용하긴 했어요. **REPL과 결합하여 링은 정말 엄청난 개발 생산성**을 보여줬습니다.\n\n[Compojure](https://github.com/weavejester/compojure)는 핸들러를 읽기 쉬운 routes의 리스트로 표현하는 라우팅 라이브러리입니다. 아래는 예제코드입니다.\n\n```clojure\n(def my-routes\n  (routes\n    (GET \"/foo\" [] \"Hello Foo\")\n    (GET \"/bar/:id\" [id] (str \"Hello \" id)))))\n```\n\n템플릿을 지원하는 라이브러리인 [Hiccup](https://github.com/weavejester/hiccup)은 HTML을 표현하는 편리한 DSL을 만들어줍니다.\n\n```clojure\n(html [:span {:class \"foo\"} \"bar\"]) ;; => <span class=\"foo\">bar</span>\n```\n\nHiccup의 최대 장점은 평범한 클로저 데이터 구조(벡터와 맵)과 함수들로 HTML에 대한 표현이 가능하다는 겁니다. `<>`와 같은 특수 부호들을 굳이 사용할 필요가 업습니다.\n\n```clojure\n(html [:ul (for [x (range 1 4)] [:li x])])\n;; => <ul><li>1</li><li>2</li><li>3</li></ul>\n```\n\n같은 포맷이 클로저스크립트의 ReactJS은 [Reagent](https://reagent-project.github.io/)에서도 역시 사용됩니다.\n\n<br />\n\n#### 확장성\n\n클로저의 확장성은 [소프트웨어 개발](https://freshcodeit.com/portfolio)에 중요한 역할을 합니다. 다른 언어들에 있는 **강력한 기능도 매크로를 통한 외부 라이브러리로 쉽게 구현**이 될 수 있기 때문이죠. [core.match 라이브러리](https://github.com/clojure/core.match)의 패턴 매칭 (pattern matching)을 예로 들어보겠습니다.\n\n```clojure\n(let [x {:a 1 :b 1}]\n  (match [x]\n    [{:a _ :b 2}] :a0\n    [{:a 1 :b 1}] :a1\n    [{:c 3 :d _ :e 4}] :a2\n    :else nil))\n;=> :a1\n```\n\n다른 패턴과 데이터형을 매치시킬 수 있도록 확장도 가능합니다.\n\n```clojure\n(matchm [(java.util.Date. 2010 10 1 12 30)]\n   [{:year 2009 :month a}] a\n   [{:year (:or 2010 2011) :month b}] b\n   :else :no-match)\n```\n\n놀랍지 않나요?\n\n다음은 [core.async](https://github.com/clojure/core.async)에 대해서 알아보겠습니다.\n\ncore.async는 Queue의 역할을 하는 채널과 쓰레드 풀(Thread pool), 제어역전(inversion of control)등의 디자인 패턴을 이용하여 비동기 통신을 하는 라이브러리입니다. Golang의 채널과 비슷한데요, 클로저의 구현은 언어자체에 탑재되어 있는 것이 아닌 라이브러리를 통해 이뤄진 점이 다릅니다.\n\n```clojure\n(defonce log-chan (chan))\n\n(defn loop-worker [msg]\n  (println (str \"hello, \" msg \"!\")))\n\n(go-loop []\n  (let [msg (<! log-chan)]\n    (loop-worker msg)\n    (recur)))\n\n(>!! log-chan \"world\")                ; => hello, world!\n(>!! log-chan \"core.async\")           ; => hello, core.async!\n```\n\n`go`와 `go-loop` 블록은 바로 제어를 리턴하여 다른 쓰레드에서 비동기적으로 처리되는 코드 블록을 정의합니다.\n\n`<!` 함수는 쓰레드를 go-loop 블록에 위치시킵니다. 메시지가 들어오면 loop-worker 핸들러가 호출되고, 블록이 다음 메시지를 멈춰 기다리게 됩니다.\n\n블록 함수 `>!!`는 스트링 값들을 log-chan 채널로 전달하며, loop-worker는 그 메시지들을 출력합니다.\n\ncore.async는 디폴트로 8개의 쓰레드를 go 블록에서 지원합니다.\n\ncore.async는 클로저스크립트에서도 활발히 사용되고 있습니다. 클로저스크립트는 블로킹 없는 접근을 통해서 콜백 지옥 문제를 해결하고 있습니다!\n\n<br />\n\n#### 스펙(clojure.spec)과 동적 타이핑\n\n클로저는 리습(Lisp)에서 동적 타입의 레거시를 물려받았습니다. 언어의 창시자의 리치 히키도 [동적 타입을 기본으로 사용하는 것을 지지](https://youtu.be/2V1FtfBDsLU?t=2267)하고 있습니다.\n\n수년간 타이핑에 대한 길고 복잡한 논의들이 있어왔기에 제 사견만 조금 덧붙여보겠습니다. 동적 타이핑이 정말 발등 찍히기 쉬운 건 맞습니다. 하지만 한편으로는 더 **실용적**이고 결과 지향적 접근이기도 합니다.\n\n정적 타입의 부재는 독립적인 컴포넌트나 심지어 전체 시스템을 \"바로바로\" 테스트해볼 수 있는 강력한 REPL과, 데이터의 명세를 표현할 수 있는 [core.spec](https://clojure.org/guides/spec)으로 상쇄합니다.\n\ncore.spec은 **데이터 스키마를 클로저 데이터 구조로 표현하여** 더 '데이터 지향적 접근'을 가능하게 합니다. 대담하게도, 클로저는 함수 체인의 처음부터 끝까지 전부 타입으로 추적할 필요가 없다고 얘기합니다.\n대신, spec을 잘 활용하면 되는데 spec은 API를 설명하고, 웹 형식을 검증하며, 심지어 **테스트 데이터 생성**까지 전부 도맡아 할 수 있기 때문입니다.\n\n아래는 spec이 request/response 검증과 타입 변환, swagger 문서 생성에까지 어떻게 사용되고 있는지에 대한 예시입니다.\n\n```clojure\n(s/def ::id int?)\n(s/def ::name string?)\n(s/def ::user (s/keys ::req-un [::id ::name]))\n\n(def app\n  (api\n    {:coercion :spec}\n    (GET \"/users/:id\" []\n      :path-params [id :- ::id]\n      :return ::user\n      (ok (users-by-id id)))))\n```\n\n수년간 정적 타입 언어인 자바를 써오다보니, 처음에는 클로저의 동적 타입 모델을 쓰면서 불안해했던것도 사실입니다. 물론 타입 체크를 통한 에러 색출과 인텔리센스는 정적 타이핑의 장점입니다만, **clojure.spec을 써보니 그 생각이 잘 나지 않게 되었습니다.**\n\n복잡한 알고리즘이나 구체적인 모듈을 사용할 때는 정적 타입의 도움을 받는것이 합리적입니다. 여기서 클로저의 확장성이 또 한번 빛을 발하는데요, [core.typed](https://typedclojure.org/) 라이브러리를 봅시다.\n\ncore.typed 라이브러리는 클로저 프로그램 전체 혹은 부분에 걸쳐 선택적으로 타입을 적용할 수 있도록하는 선택적 타입 시스템을 제공합니다.\n\n[2부](https://green-labs.github.io/start-your-clojure-project-now-2)에서 이어집니다.\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"tlonist.sang@gmail.com\"\n  name=\"김상현\"\n  description=\"백엔드 개발자\"\n  date=\"2021-05-30\"\n/>\n","excerpt":"저자와 freshcodeit의 허락을 받은 번역입니다. 원글과 차이가 있을 수 있습니다. 클로저는 리습(Lisp)을 기반으로 한 함수형 언어입니다.번역한 글에서는 클로저의 탄생배경과 특징, 학습 방법이 구체적으로 잘 소개되어 있습니다…","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","tags":[{"name":"Clojure","slug":"clojure"},{"name":"functional-programming","slug":"functional-programming"}]},{"slug":"/apply-and-compose","title":"함수형 프로그래밍과 중위연산자","date":"2021년 4월 27일","body":"\n함수형 프로그래밍의 목표는 무엇일까요? 여러 가지 의견이 있겠지만 함수의 재사용과 합성이야말로 함수형 프로그래밍의 궁극적인 목표라고 생각합니다. 작은 일을 정확하게 처리하는 함수들을 모으고 합성하면 크고 복잡한 문제를 더욱더 쉽게 해결할 수 있게 됩니다.\n\n하스켈을 비롯한 몇몇 언어들은 인자가 두 개인 함수를 +, \\*와 같은 중위 연산자로 취급 할 수 있습니다. 이 포스팅에서는 중위 연산자를 사용해서 함수의 합성과 적용이 산수 계산처럼 쉽게 표현되는 것을 보이려고 합니다.\n\n## 함수 평가해보기\n\n함수 `fn :: a → b`를 평가하는 것은 어렵지 않습니다. 단지 fn에 값을 적용해 주기만 하면 되기 때문이죠.\n\n```haskell\nfn value\n```\n\n## apply\n\n어떤 함수 하나와 그 함수의 첫 번째 인자를 입력받는 함수를 만들고 apply라는 이름을 붙여줍니다. 이 함수는 타입으로 인해 한 가지 방법으로만 구현이 가능합니다.\n\n```haskell\napply :: forall a b. (a -> b) -> a -> b\napply f x = f x\n```\n\napply 함수의 구현을 ReScript로 작성하면 다음과 같습니다.\n\n```reason\nlet apply = (fn: ('a => 'b), value: 'a): 'b => fn(value)\n```\n\nReScript는 타입 표기를 생략해도 정확한 타입을 추론해줍니다.\n\n```reason\nlet apply = (fn, value) => fn(value)\n```\n\napply 함수에 첫 번째 인자로 임의의 함수를 입력하면 그 함수 자신이 리턴됩니다. `apply fn` 을 평가하면 그대로 `fn`이 되는 것이죠. `apply fn`이 리턴 하는 타입이 `a → b`이기 때문에 이는 당연한 일입니다. 따라서 `apply fn value`는 `fn value`와 완전히 동일한 동작을 하게 됩니다. 이해를 돕고자 `apply fn`일 때의 리턴 타입을 명시적으로 괄호로 묶어보았습니다. (`apply fn`을 평가해서 `fn`이 되는 것은 하스켈과 ReScript 모두 함수가 커링되어있기 때문입니다.)\n\n```haskell\napply :: forall a b. (a -> b) -> (a -> b)\n```\n\napply 함수는 [map](https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:fmap), [ap](https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:ap), [flatMap](https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:-61--60--60-) 과 나란히 놓고 보면 그 특징과 연관성이 더욱 두드러집니다. 이런 내용은 다른 포스팅에서 다룰 기회를 가져보도록 하겠습니다.\n\n## compose\n\n두 개의 함수가 있고, 두 함수 중 하나의 리턴 타입이 다른 함수의 인자 자입과 동일하다고 가정해봅시다. 이를 코드로 표현하면 다음과 같습니다.\n\n```haskell\nf :: String -> Int\ng :: Int -> Boolean\n```\n\n함수 f에 대한 평가 결과를 g의 인자로 사용 할 수 있는 것이죠.\n\n```haskell\ng (f x) -- 다른 언어에서는 g(f(x)) 와같이 표현했을 것입니다.\n```\n\napply가 하나의 함수와 하나의 인자를 받았듯이, 두 개의 함수와 하나의 인자를 받아 합성해주는 함수를 만들고 compose 라는 이름을 붙여봅시다.\n\n```haskell\ncompose :: forall a b c. (b -> c) -> (a -> b) -> (a -> c)\n```\n\ncompose의 인자 순서가 `(b → c) → (a → b) → a → c` 인 것에 주의합시다. 인자의 입력부터 연속되는 함수의 평가는 `g (f x)`에서 보듯 오른쪽에서 왼쪽으로 적기 때문에 compose도 이 흐름에 맞춰서 구현하는 게 일반적입니다.\n\ncompose 함수를 사용해서 g (f x)를 표현하면 이렇게 됩니다.\n\n```haskell\ncomposite2Fn :: forall a c. a -> c\ncomposite2Fn x = (compose g f) x -- x는 a타입의 값입니다.\n```\n\n`=`를 기준으로 좌변에 있는 마지막 인자가 우변에서 가장 마지막에 입력이 된다면, 좌우 변에서 모두 생략시킬 수 있습니다. composite2Fn의 인자 x가 우변에 있는 함수에서 가장 끝에서 입력이 되었기 때문에 양쪽에서 모두 생략하고 이렇게 작성을 해도 같은 표현이 됩니다.\n\n```haskell\ncomposite2Fn :: forall a c. a -> c\ncomposite2Fn = compose g f -- compose g f는 여전히 a타입의 인자가 필요합니다.\n```\n\n이렇게 인자를 생략해서 함수 선언을 작성하는 방식을 point-free style이라고 부릅니다. 하스켈에서는 반복을 피하고 간결한 코드 작성을 위해서 자주 사용하는 기법입니다.\n\n`compose g f`를 먼저 평가하면 `a → c`타입의 함수가 됩니다. 이는 다시 말하면 compose 함수가 2개의 함수를 입력받아 순차적으로 실행하는 또 다른 함수를 만들어 낼 수 있다는 것을 의미합니다. `(compose g f) x`와 `g (f x)`가 완전히 같은 동작을 하게 된다는 것을 기억합시다.\n\n만약 `h :: c → d` 라는 함수가 있어 f, g, h를 합성하고 싶다면 어떻게 하면 될까요?\n\n```haskell\ncompose h (compose (g f)) x\n```\n\n같은 방식으로 더 많은 함수를 합성해 나간다면 무수히 많은 괄호가 필요하고 우리의 뇌는 이 괄호를 해석하기 위해 더 많은 일을 해야 할 것입니다. 이것을 단순하게 표현 할 수 있는 방법을 찾아봅시다.\n\n## 함수 풀어서 써보기\n\n첫 번째 인자에서 두 번째 인자를 더하는 함수 plus가 있다고 가정합니다.\n\n```haskell\nplus x y = x + y\n```\n\nplus함수를 사용해서 x,y,z 세 개의 숫자를 순서대로 더해나간다면 이렇게 표시할 수 있습니다.\n\n```haskell\nplus x (plus y z)\n```\n\n이 표현식을 바깥에서부터 안쪽으로 풀어나가면 다음과 같습니다.\n\n```haskell\nx + (plus y z)\nx + (y + z)\nx + y + z -- 더하기는 결합 법칙에 의해서 연산의 순서가 결과에 영향을 주지 않기 때문에 괄호가 생략 가능함을 떠올립시다.\n```\n\n이번에는 i,j,k,l 네 개의 변수를 더해가는 과정을 안쪽에서부터 풀어봅시다.\n\n```haskell\nplus i (plus j (plus k l))\nplus i (plus j (k + l))\nplus i (j + (k + l))\ni + (j + (k + l))\n```\n\n## 함수의 위치\n\n인자가 2개인 함수라면, 사칙 연산의 연산자를 숫자 중간에 적을 수 있듯이 인자가 2개인 함수 호출에 대해서는 함수를 중간에 표시를 할 수 있습니다. 이러한 방식을 infix operation이라고 부릅니다. 하스켈을 포함한 몇몇 언어에서는 함수의 이름을 백틱(`)으로 감싸주면 infix operation으로 사용할 수 있습니다.\n\n```haskell\ni `plus` j `plus` k `plus` l -- i + j + k + l 과 완전히 동일합니다.\n```\n\n또한 + 연산자처럼 함수 이름이 특수문자로만 이루어졌다면 자동으로 infix operator로서 동작합니다. 일반적인 함수를 백틱으로 감싸 infix operator로 사용했듯이, 특수문자 함수명인 infix operator를 괄호로 감싸주면 일반 함수처럼 중간이 아닌 앞에 적을 수 있게 됩니다.\n\n```haskell\n(+) i ((+) j ((+) k l)) -- plus i (plus j (plus k l)) 와 같은 의미입니다.\n```\n\npoint-free style과 이를 합치면 plus 함수를 이렇게 정의 할 수 있습니다.\n\n```haskell\nplus = (+) -- plus x y = (+) x y 의 point-free 표기입니다.\n```\n\ncompose 함수도 infix operation으로 사용할 수 있습니다.\n\n```haskell\n(h `compose` (g `compose` f)) x\n```\n\ncompose 함수의 infix opearator로 `.`을 지정하고 apply에는 `$` 를 지정해봅니다. 특수문자로 이루어진 함수명은 괄호를 써야 일반 함수처럼 다룰 수 있습니다.\n\n```haskell\n($) = apply\n(.) = compose\n```\n\ncompose 함수는 +와 마찬가지로 결합법칙을 만족하기 때문에 연산 순서와 관계없고 따라서 아래와 같은 항등식이 성립합니다. 어떤 자료구조가 이처럼 대수 법칙을 만족한다면 결과를 예측하기 쉬워지므로 논리의 검증이 편해집니다.\n\n```haskell\nh . (g . f) = (h . g) . f = h . g . f\n```\n\n이제 f,g,h함수의 합성은 간단하게 할 수 있습니다.\n\n```haskell\n(h . g . f) x\n```\n\n다른 언어와 마찬가지로 연산자 양옆의 공백은 생략해도 됩니다. apply까지 사용하면 괄호도 필요 없어집니다.\n\n```haskell\nh.g.f $ x\n```\n\n중첩된 괄호의 늪에서 빠져나와 간단명료한 방법으로 함수를 합성할 수 있게 되었습니다.\n\n## 마치며\n\n이번 포스팅에서는 함수를 합성하는 방법과 하스켈에서 이를 간단하게 표현하는 방법에 대해서 살펴보았습니다. 하스켈에서는 infix operator, currying, point-free 표기 등을 사용해서 마치 수식을 다루는 것과 같이 단순하고 명료한 코드를 작성하고 합성해서 복잡한 문제를 해결하는 방식을 선호합니다. 기존 언어에서도 이런 관점으로 코드를 작성하고 리팩토링을 해나간다면 단순하면서도 견고한 코드를 작성하기가 쉬워질 것입니다.\n\n<br />\n<br />\n<Author\n  email=\"ck.kim@greenlabs.co.kr\"\n  name=\"김춘구\"\n  description=\"함수형 프로그래머\"\n  date=\"2021-04-27\"\n/>\n<br />\n<br />\n","excerpt":"함수형 프로그래밍의 목표는 무엇일까요? 여러 가지 의견이 있겠지만 함수의 재사용과 합성이야말로 함수형 프로그래밍의 궁극적인 목표라고 생각합니다. 작은 일을 정확하게 처리하는 함수들을 모으고 합성하면 크고 복잡한 문제를 더욱더 쉽게 해결할 수 있게…","description":"show me the $","tags":[{"name":"functional programming","slug":"functional-programming"},{"name":"infix operator","slug":"infix-operator"}]},{"slug":"/why-rescript","title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021년 1월 29일","body":"\n## 시작하며\n\n> **_그린랩스에서 리스크립트(ReScript) 공식 문서를 한글로 번역해서 공개합니다._**\n>\n> **_[(https://green-labs.github.io/rescript-in-korean/)](https://green-labs.github.io/rescript-in-korean/)_**\n\n현재 그린랩스에서는 ReasonML로 웹 개발을 하고 있습니다. 하지만 미래에 리스크립트로 넘어가려고 합니다. 웹 개발에 사용하는 경우 ReasonML보다 리스크립트가 더 적합하다고 생각하기 때문입니다. 이번 포스트에서는 리스크립트가 무엇이며, ReasonML 과의 차이점은 어떤 것이 있는지 살펴봅니다. 그리고 그린랩스가 리스크립트로 전환하려는 의사 결정을 하게 된 과정에 대해서 설명하려고 합니다.\n\n## ReasonML? 버클스크립트? 리스크립트?\n\nReasonML로 웹 개발을 하는 과정은 다음과 같습니다.\n\n1. ReasonML 문법으로 코드 작성\n2. 작성한 ReasonML 코드를 자바스크립트로 변환\n3. 변환된 자바스크립트 코드를 브라우저나 노드 환경에서 실행\n\n위의 과정에서 버클스크립트는 ReasonML 코드를 자바스크립트 코드로 변환하는 핵심 역할을 합니다.\n\n작년 8월, 공식적으로 [버클스크립트(BuckleScript)는 리스크립트(ReScript)로 이름을 바꿨습니다.](https://rescript-lang.org/blog/bucklescript-is-rebranding) 지난 수 년간 버클스크립트는 분명한 성과가 있었지만, 가지고 있는 문제 또한 명확했는데, 버클스크립트 개발진들은 버클스크립트가 가지고 있는 문제를 해결하고자 이름을 바꾸고 새로운 프로젝트의 시작을 선언했습니다.\n\n## 버클스크립트의 성과\n\n버클스크립트는 OCaml을 컴파일해서, 빠르고 읽기 좋은 자바스크립트 코드를 생성해보자는 아이디어에서 출발했습니다. 그 이후, 버클스크립트 생태계 위에서 ReasonML이 탄생했습니다. 수년이 지난 지금, 버클스크립트는 웹 생태계가 겪고 있는 다양한 문제들의 해결하고 있습니다. 다음은 버클스크립트가 이룬 성과들입니다.\n\n- 프론트엔드 개발을 위한 빠르고 믿을만한 빌드 시스템\n- 타입 안정성을 가진 라이브러리(bs-\\*)를 위한 생태계\n- 믿고 쓸 수 있는(production-ready) 표준 라이브러리 밸트(Belt)\n\n위는 분명히 ReasonML과 버클스크립트를 선택한 개발자들만이 누릴 수 있는 큰 장점인 반면 한계 또한 명확했습니다.\n\n## 버클스크립트와 ReasonML의 문제\n\n많은 사람들이 버클스크립트에 매력을 느끼고 사용을 시작했지만 문제가 하나 있었습니다. 바로 처음 시작하는 사람들이 너무나 많은 것을 배워야 한다는 점입니다. 그에 따라 중도에 포기하는 사람이 많았습니다.\n\n버클스크립트를 사용하기 위해서는 OCaml의 기본 철학을 개념적으로 이해해야 하고, ReasonML 문법을 알아야 합니다. 또한 자바스크립트 코드를 생성할 때 필요한 버클스크립트 고유의 특징 또한 배워야 합니다. 예를 들어 한 개발자가 ReasonReact 애플리케이션을 만들기 위해서는 다음의 나열된 것들을 두루두루 알고 있어야 합니다.\n\n- 자바스크립트와 리액트\n- OCaml 언어의 기본 철학\n- ReasonML 문법\n- 버클스크립트의 자바스크립트 호환 문법\n- 버클스크립트의 빌드 시스템\n- ReasonReact만의 특별한 문법\n\n커뮤니티에서도 ReasonML의 진입 장벽이 높다는 이야기가 여러 차례 나왔습니다. [Ahrefs](https://ahrefs.com/)에서 Reason 및 ReasonReact로 포팅을 한 후에 [1년 반 동안 제품에 ReasonML을 사용한 소감](https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b)을 팀원들을 대상으로 인터뷰한 적이 있는데, 복수의 팀원들이 *ReasonML과 버클스크립트는 정말 훌륭하지만, 배우기가 쉽지 않았다*고 언급했습니다.\n\n이런 지적을 수용해 ReasonML과 버클스크립트 팀은 더욱더 문서화를 열심히 했습니다. 심지어 공식 웹사이트에 *새롭게 시작하는 사람들을 위한 예제[^1]*까지 생겼습니다. 이런 노력은 분명히 칭찬받을만한 것이었지만 문제는 쉽게 해결되지 않았습니다. 이런 상황에 대해 버클스크립트 팀은 \"이상하게도 문서화를 하면 할수록 사람들은 더욱 힘들어하는 역설적인 상황이 반복되었다\"라고 회고했습니다.\n\n## 리브랜딩: 리스크립트(ReScript)\n\n버클스크립트 팀은 위와 같은 진입 장벽을 인정했고, 문서화로 해결할 수 없는 이 상황을 받아들이기로 했습니다. 그리고 문제를 해결하기로 했습니다. 그 결과 리스크립트가 탄생했습니다. 파편화된 생태계와 문서들을 하나로 통합하여 혼란을 줄이고, 보다 친절한 가이드를 제공하고자 했습니다. 결정적으로 그들이 생각했던 가장 중요한 목표는 바로 개발자가 리스크립트 하나만 알면 되게 하자는 것입니다.\n\n리스크립트 팀에서 공식적으로 언급한 목표는 다음과 같습니다.\n\n- 컴파일러와 빌드시스템\n- 독자적인 문법(dedicated syntax)\n- 에디터 지원\n- 하나의 문서([https://rescript-lang.org](https://rescript-lang.org))\n- 하나의 통합된 포럼\n\n여기서 주목해야 할 점은 ReasonML과 다른 독자적인 문법(dedicated syntax)이 생긴다는 것입니다. 이것은 기존에 ReasonML을 사용해 웹 개발을 했던 많은 회사들과 개발자들에게 당황스러운 발표였습니다. 아마도 버클스크립트 팀에 대한 신뢰와는 별개로 새로운 언어 문법을 만든다는 것이 주는 무게감이 남다르기 때문인 것 같습니다. 이 발표 이후 TinyMCE라는 유명한 위지윅 에디터를 만드는 팀에서도 이 부분을 언급했는데, 그들은 리스크립트가 안정적이게 될 때까지, [ReasonML로 개발하는 것을 유지하고, 리스크립트의 발전을 지켜보겠다고 이야기했습니다.](https://www.tiny.cloud/blog/tinymce-reasonml/)\n\n사실 리브랜딩 이전에도 버클스크립트는 [독자적인 문법을 추가한 적이 있었는데,](https://rescript-lang.org/blog/bucklescript-8-1-new-syntax) 아마도 이러한 시도들이 리스크립트의 탄생에 대한 복선이었던 것 같습니다.\n\n<div>\n  <img src=\"./to_rescript.jpg\" alt=\"to_rescript\" />\n</div>\n*출처: https://rescript-lang.org/blog/new-rescript-logo\n\n## 리스크립트와 ReasonML을 비교했을 때 다른 점\n\n리스크립트와 ReasonML을 비교했을 때 다른 점은 그린랩스에서 번역한 [리스크립트 문법으로 변경하기](https://green-labs.github.io/rescript-in-korean/Overview/04-Migrate-to-ReScript-Syntax) 페이지를 읽어보면 좋습니다. 주요한 변경 사항만 간단히 살펴보면 다음과 같습니다.\n\n- 세미 콜론을 찍지 않아도 됩니다.\n- `if`, `switch`, `try`에 괄호가 필요 없습니다.\n- 타입 인자 문법이 `option(int)`에서 `option<int>`와 같이 바뀌었습니다.\n- 백틱을 사용하는 문자열이 생겼습니다. 줄바꿈과 유니코드를 지원합니다.\n- 배열 문법이 `[|1, 2, 3|]`에서 `[1, 2, 3]`로 바뀌었는데, 자바스크립트에서는 배열이 가장 기본적인 자료 구조이기 때문입니다.\n- 리스트 문법이 `[1, 2, 3]`에서 `list{1, 2, 3}`으로 바뀌었습니다.\n- 일급 모듈의 문법이 `(module S: Student)` 에서 `module(S: Student)`로 바뀌었습니다.\n- 객체에 접근하는 방법이 `settings##visible #= true`에서 `settings[\"visible\"] = true`로 바뀌었습니다.\n- 재귀적인 타입을 선언하려면 이제 명시적으로 작성해주어야 합니다. 타입 선언이 기본적으로 재귀적일 수 없도록 되어있습니다.\n\n원래 ReasonML은 네이티브 환경과 자바스크립트 환경, 두 가지를 모두 지원하는 언어입니다. 각각의 컴파일러가 공유하는 지점이 있고, 백엔드에 따라서 네이티브 빌드 결과물이 나오기도 하고, 자바스크립트 코드가 나오기도 하는 것입니다. 두 개의 플랫폼을 지원한다는 것은 매우 좋은 일이지만 그에 따른 단점도 있었습니다. 두 개의 플랫폼을 고려하다 보면 문법(Syntax)을 보다 중립적으로 선택해야 했고, 호스트에 최적화된 기능을 언어 자체에 녹이기도 힘들었습니다.\n\n반면에 리스크립트는 자바스크립트에서 배열이 가장 기본적인 자료 구조이기 때문에 배열의 문법을 리스트의 문법보다 편하게 만들었고, 객체에 접근하는 방법을 자바스크립트 객체에 접근하는 방법과 비슷하게 바꿨습니다. 이제 더 이상 네이티브 환경을 생각하지 않아도 되기 때문에 보다 적극적으로 자바스크립트 개발자들에게 헌신적인 문법을 제공할 수 있게 된 것입니다.\n\n또한 기존에 불편한 점으로 지적되었던 유니코드를 지원하는 점 등은 개발자들이 매우 환영할만한 일입니다.\n\n**[Reason 문법 예]**\n\n```reason\nmodule Button = {\n  [@react.component]\n  let make = (~count: int, ~user) =>\n    {\n      let times =\n        switch (count) {\n        | 1 => \"once\"\n        | n => Belt.Int.toString(n) ++ \" times\"\n        };\n      let username = user##name;\n      let msg = (username ++ {js|님, 클릭해주세요. |js}) ++ times;\n\n      <button> msg->React.string </button>;\n    };\n};\n```\n\n**[리스크립트 문법 예]**\n\n```rescript\nmodule Button = {\n  @react.component\n  let make = (~count: int, ~user) => {\n    let times = switch count {\n    | 1 => \"once\"\n    | n => Belt.Int.toString(n) ++ \" times\"\n    }\n    let username = user[\"name\"]\n    let msg = username ++ `님, 클릭해주세요. ` ++ times\n\n    <button> {msg->React.string} </button>\n  }\n}\n```\n\n## ReasonML의 미래\n\n그럼 ReasonML은 리스크립트의 독자적인 노선을 어떻게 생각할까요? 그리고 ReasonML의 미래는 어떻게 되는 것일까요? 이에 대한 [Jordan Walke를 포함한 ReasonML 팀의 답변을 정리해보면 다음과 같습니다.](https://github.com/reasonml/reason/issues/2634)\n\n1. 만약 네이티브 애플리케이션을 개발한다면, ReasonML은 좋은 선택지가 될 것입니다. 현재 Jordan Walke를 비롯한 많은 개발자들이 ReasonML이 네이티브 환경에서 실행되는 환경을 개선하는 프로젝트에 집중[^2]하고 있습니다.\n2. 만약 네이티브와 브라우저를 동시에 지원해야 하는 상황이라면, ReasonML은 좋은 선택지가 될 것입니다. 리스크립트가 호환을 약속했고, 또 리스크립트가 없더라도, [js_of_ocaml](https://ocsigen.org/js_of_ocaml/3.7.0/manual/overview)이라는 프로젝트가 있기 때문에, 여러분의 프로젝트가 네이티브와 자바스크립트를 모두 고려한다면, 여전히 ReasonML은 좋은 선택지입니다.\n3. 만약 네이티브 빌드가 필요가 없고, 자바스크립트 환경만 고려한다면 버클스크립트를 사용했듯, 리스크립트를 계속 사용하면 됩니다.\n\n## 그린랩스의 선택 과정\n\n작년 8월에 팀이 막 꾸려지고 프로젝트를 시작할 때, 리스크립트가 나왔습니다. 그 당시 리스크립트는 에디터 지원이 많이 미숙했고, 특히 언어가 막 나온 상태였기 때문에 레퍼런스가 전무했습니다. 그에 따라 오로지 공식 문서를 참고할 수밖에 없었는데, 그때의 공식 문서는 내용이 많이 부실했습니다.\n\n그래서 우선 ReasonML로 프로젝트를 시작하기로 결정했습니다. 최신 리스크립트 컴파일러를 썼지만 ReasonML 문법을 사용했습니다. ReasonML은 상대적으로 레퍼런스가 많았고, 리스크립트 컴파일러가 ReasonML 문법에 대한 호환이 완벽하게 지켜졌기 때문에 문제가 없었습니다.\n\n6개월 정도가 지난 지금, 리스크립트는 에디터 지원도 충분해졌고, 특히 공식 문서가 굉장히 탄탄해졌습니다. 그래서 최근에 합류하신 분들은 리스크립트로 온보딩을 합니다. 또한 얼마 전에 작은 프로젝트 하나를 리스크립트로 구현하고 배포했습니다. 회사 서비스에 반영했던 첫 번째 리스크립트 프로젝트였습니다.\n\n현재 ReasonML/리스크립트를 모두 사용하고 있습니다. 강조하고 싶은 점은 리스크립트로 온보딩하신 분들이 기존 ReasonML 프로젝트에 기여하시는 것도 큰 장벽이 없었다는 것입니다. 위에 나열한 차이점만 존재할 뿐, 두 언어의 뿌리는 같기 때문입니다. 마찬가지로 기존 구성원들이 새로 입사하신 분들의 리스크립트 코드를 리뷰하는데도 무리가 없었습니다. 그럼에도 불구하고 조만간 전체 프로젝트를 리스크립트로 넘어갈 것입니다. 웹 개발에는 리스크립트가 더 적합하기 때문입니다.\n\n이러한 경험을 바탕으로 이제부터 그린랩스가 국내 리스크립트 생태계에 기여하고자 합니다. 그 첫번째 프로젝트로 공식 문서를 번역해 공개하게 되었습니다.\n\n> **_[리스크립트(ReScript) 한글 공식 문서 (https://green-labs.github.io/rescript-in-korean/)](https://green-labs.github.io/rescript-in-korean/)_**\n\n이 문서가 리스크립트를 시작하는 한국 개발자분들께 많은 도움이 되길 바랍니다.\n\n<br />\n<br />\n<Author\n  email=\"kimchhickey@gmail.com\"\n  name=\"양성민\"\n  description=\"백엔드 엔지니어\"\n  date=\"2021-01-29\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [https://rescript-lang.org/blog/bucklescript-is-rebranding](https://rescript-lang.org/blog/bucklescript-is-rebranding)\n- [https://reasonml.chat/t/rescript-and-the-future-of-reasonml/2559](https://reasonml.chat/t/rescript-and-the-future-of-reasonml/2559)\n- [https://reasonml.org/](https://reasonml.org/)\n- [https://forum.rescript-lang.org/t/rescript-frequently-asked-questions/59](https://forum.rescript-lang.org/t/rescript-frequently-asked-questions/59)\n- [https://rescript-lang.org/blog/bucklescript-8-1-new-syntax](https://rescript-lang.org/blog/bucklescript-8-1-new-syntax)\n- [https://www.tiny.cloud/blog/tinymce-reasonml/](https://www.tiny.cloud/blog/tinymce-reasonml/)\n\n[^1]: 현재는 페이지가 리스크립트로 옮겨져서 찾을 수 없습니다. 구글에서 \"Newcomers Examples ReasonML\"을 검색하시면 그 흔적을 찾을 수 있습니다.\n[^2]: 실제로 Jordan Walke는 발표를 통해서 현재 네이티브에서 동작하는 ReasonML 프로젝트에 더 많은 시간을 쏟고 있다고 이야기했습니다.\n","excerpt":"시작하며 그린랩스에서 리스크립트(ReScript) 공식 문서를 한글로 번역해서 공개합니다.\n\n(https://green-labs.github.io/rescript-in-korean/)\n\n현재 그린랩스에서는 ReasonML로 웹 개발을 하고 있습니다…","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","tags":[{"name":"ReasonML","slug":"reason-ml"},{"name":"ReScript","slug":"re-script"},{"name":"Bucklescript","slug":"bucklescript"}]},{"slug":"/reasonml-ways-with-types","title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020년 12월 21일","body":"\n자바스크립트나 다른 동적 타입을 가진 언어에서는, 함수나 분기문에서 타입이 다른 데이터를 리턴하는 것이 자연스럽습니다.\n하지만 ReasonML에서는 항상 같은 데이터 타입이 리턴되어야 합니다. 처음 ReasonML을 접하게 되면 이런 타입 시스템의 특성 때문에 당황하실 수 있습니다. 코드 예시를 통해 바로 확인해보겠습니다.\n\n## 자바스크립트 vs. ReasonML\n\n아래의 test 함수는 인자가 숫자(number)일 때는 숫자를, 문자열일때는 문자열을, 그 외에는 `{foo: \"bar\"}`라는 객체를 반환합니다.\n\n```javascript\nlet test = (input) => {\n  if (typeof input === \"number\") return input;\n  else if (typeof input === \"string\") return input;\n  else return { foo: \"bar\" };\n};\n\ntest(1); /*  1  */\ntest(\"hello world!\"); /*  hello world!  */\ntest([1 2 3 4]); /*  {foo: \"bar\"}  */\n```\n\n혹은 각 분기문마다 같은 타입의 다른 필드를 가진 객체를 리턴 할 수도 있습니다.\n아래의 함수는 인자가 참일 때는 `{foo: \"bar\"}`를, 거짓일 때는 `{hello: \"world\"}`를 반환합니다.\n\n```javascript\nif (input === true) {\n  return { foo: 'bar' };\n} else {\n  return { hello: 'world' };\n}\n/*  OK  */\n```\n\n하지만 ReasonML에선 안전한(sound) 타입 시스템을 위해 모든 분기문의 리턴값은 반드시 한 타입으로 정해져 있습니다.\n위의 `{foo: \"bar\"}`와 `{hello: \"world\"}`는 다른 타입으로 간주되어 컴파일이 실패합니다.\n하나의 예시를 더 보겠습니다.\n\n```reason\nif (input === true) {\n  2;  /*  ReasonML에선 마지막 표현식이 리턴으로 간주됩니다.*/\n} else {\n  \"hello\";\n}\n```\n\n결과는 아래와 같습니다.\n\n```console\nThis has type: string\nSomewhere wanted: int\n\nYou can convert string to int with Belt.Int.fromString.\n```\n\n타입이 객체인 경우 세부 모든 세부 필드의 값이 일치해야(구조적 타입) 오류가 나지 않습니다.\n\n```reason\nswitch ((input: bool)) {\n| true => {\"foo\": \"bar\"}\n| false => {\"hello\": \"world\"}\n}\n```\n\n결과는 마찬가지로 컴파일 오류입니다.\n\n```console\n  This has type: {. \"hello\": string}\n  Somewhere wanted: {. \"foo\": string}\n  The second object type has no method hello\n```\n\n하지만 개발을 하다보면 다른 객체를 반환하는 것이 꼭 필요한 경우가 생깁니다. 아래의 예시처럼요.\n\n## 현업에서 마주친 상황\n\n그린랩스에선 프리즈마(Prisma)[^1] 라는 DB 클라이언트를 사용하여 백엔드 개발을 하고 있습니다.\n프리즈마는 ORM처럼 고유의 문법을 사용하며, 중첩된 객체들로 관계형 쿼리를 표현할 수 있습니다. [^2] 아래는 간략화된 실제 코드입니다.\nisHeavy 라는 bool 변수의 값에 따라 참일 경우 20kg보다 무거운 수박을, 거짓일 경우 20kg과 같거나 가벼운 수박을 조회하는 함수입니다.\n\n```javascript\n/*\n  수박 중에서, 조건(isHeavy)에 따라\n  20kg보다 무겁거나, 20kg과 같거나 작은 모든 데이터를 리턴해라\n*/\nawait prisma.watermelon.findMany({\n  where: isHeavy\n    ? { weight: { gt: 20 } }\n    : { weight: { lte: 20 } };\n  });\n```\n\n위 코드를 ReasonML로 옮기면 아래와 같습니다.\n\n```reason\nprisma.watermelon\n->Prisma.findMany({\n  \"where\": {\n    isHeavy\n      ? {\n        \"weight\": {\n          \"gt\": 20,\n        },\n      }\n      : {\n        \"weight\": {\n          \"lte\": 20,\n        },\n      };\n  },\n});\n```\n\n하지만 위의 ReasonML 코드는 컴파일이 실패하고 아래의 오류가 뜹니다.\n\n```console\nError:\nThis expression has type {. \"weight\": {. \"lte\": int}}\nbut an expression was expected of type {. \"weight\": {. \"gt\": int}}\nThe second object type has no method lte\n```\n\nReasonML의 객체 타입 추론은 재귀적으로 작동하여 중첩된 필드까지 전부 검사합니다.\n얼핏 보면 똑같은 `{\"weight\":...}` 객체처럼 보일 수 있지만, 그 안에 하나는 gt라는 키를, 다른 하나는 lte라는 키를 가진 서로 다른 객체이기에 컴파일이 안되는 것이죠.\n그럼 이 문제를 어떻게 해결할까요?\n\n### 해결 방안 1 - [%raw]로 JS코드 직접 넣기\n\n[%raw]를 쓰면 **JS 코드를 직접 삽입**하고 타입 검사를 피할 수 있습니다.\n\n```reason\n[%raw {| console.log(\"hello world!\") |}] /* Js.log(\"hello world!) 와 동일*/\n```\n\n아래는 [%raw]를 적용해본 예시입니다.\n\n```reason\nprisma.watermelon -> Prisma.findMany{\n%raw {|\n  where: isHeavy\n   ? {\"weight\": {\"gt\": 20},}\n   : {\"weight\": {\"lte\": 20},}\n  |};\n};\n```\n\n위의 코드가 컴파일되면 %raw 안의 구문이 그대로 Js 코드가 되어 나옵니다.\n\n```javascript\nisHeavy ? { weight: { gt: 20 } } : { weight: { lte: 20 } };\n```\n\n### 해결 방안 2 - Obj.magic 컴파일러 속이기\n\n`Obj.magic`은 ReasonML 내장함수 중 하나로, 마술(magic)이라는 이름처럼 교묘한 트릭으로 코드를 왜곡합니다. 아래처럼 사용할 수 있습니다.\n\n```reason {3-5}\nisHeavy\n  ? {weight: {gt: 20}}\n  : Obj.magic( /* 컴파일러가 체크하지 않음! */\n      {weight: {lte: 20}}\n    );\n```\n\nObj.magic는 OCaml의 %identity의 바인딩인데요, %identity는 컴파일러에게 '값이 동일하더라도 타입을 다르게 인식해라'라고 말하는 역할을 합니다.\n\n```reason\nexternal magic : 'a -> 'b = \"%identity\";\n```\n\n따라서 `{lte ...}` 는 사실상 `{gt ...}`와 같은 타입으로 인식되어 위의 문제를 회피할 수 있습니다.\n그러나 위 두 방법은 안전하게(sound) 느껴지지 않습니다. 다른 언어를 직접 사용하거나 컴파일러를 속이지 않고, ReasonML 안전한 방법으로 해결할 수는 없을까요?\n\n### 해결 방안 3 - Js.Dict\n\n조금 더 나은 방법으로는 Js.Dict를 사용해 볼 수 있습니다.\n\nJs.Dict는 ReasonML에서 사용할 수 있는 Dictionary 모듈입니다.\n\n```reason\nlet test = Js.Dict.empty();\ntest->Js.Dict.set(\"foo\", \"bar\");\n\ntest->Js.log; /* => {foo: \"bar\"} */\n```\n\n[공식문서](https://rescript-lang.org/docs/manual/latest/api/js/dict)에 다양한 쓰임이 나와 있으니 참고하세요.\n\nJs.Dict를 사용하여 조건에 따라 gt 혹은 lte를 리턴하는 conditionFunc를 만들었습니다.\n\n```reason\nlet result = Js.Dict.empty();\nlet conditionFunc = (isHeavy: bool) => {\n  isHeavy\n    ? result->Js.Dict.set(\"gt\", 20)\n    : result->Js.Dict.set(\"lte\", 20);\n  result;\n};\n```\n\nconditionFunc를 호출하여 콘솔에 찍어보면, 우리가 원했던 객체가 나옵니다.\n\n```console\n{ gt: '20' } //conditionFunc(true)\n{ lte: '20' } //conditionFunc(false)\n```\n\n위 표현이 가능한 이유는 아래와 같습니다.\n![ReasonML-Dict-Example](./reasonml-dict.png)\n\nJs.Dict로 감싼 두 표현은 Js.Dict.t 타입으로 인식되기 때문에 컴파일상 아무 문제가 없습니다. 마치 \"foo\"와 \"bar\"가 값은 다르지만 같은 string 타입인 것처럼요.\nraw나 obj.magic을 썼을 때 보다는 조금 더 타입 안정성이 확보된 것 같습니다. 하지만 **Js.Dict.t 타입이면 다 받을 수 있기 때문에 gt, lte와 같은 키만 들어갈 수 있는지는 보장되지 않습니다.**\n만약 `gt`가 들어갈 자리에 `gd`를 치면 런타임에서 에러가 나겠죠?\n\n### 해결 방안 4 - 배리언트(Variant)\n\n배리언트를 사용해 타입 안정성을 더 높힐 수 있습니다.\n배리언트는 다른 언어의 **enum** 과 비슷한 기능인데, 임의의 데이터를 배리언트로 감싸 표현할 수 있습니다. 또한 패턴 매칭 되기 때문에 다양한 방법으로 활용 가능한 자료형입니다. 간단한 예로 account라는 타입을 보겠습니다.\n\n```reason\ntype account =\n  | None\n  | Instagram(string)\n  | Facebook(string, int)\n```\n\naccount는 None, Instagram, Facebook 중 하나의 타입이 될 수 있는 배리언트입니다. 패턴매칭으로 안의 값을 가져 올 수 있습니다.\n\n```reason\nlet myAccount = Facebook(\"Josh\", 26);\nlet friendAccount = Instagram(\"Jenny\");\n\nswitch (myAccount) {\n| Facebook(name, age) => \"my name is \" ++ name ++ \" and, \" ++ string_of_int(age) ++ \" years old.\"\n| Instagram(name) => \"my name is \" ++ name ++ \".\"\n};\n/* my name is Josh and I am 26 years old. 출력!! */\n```\n\n[공식문서](https://reasonml.github.io/docs/en/variant)에 다양한 쓰임새가 나와있습니다.\n실제로는 아래처럼 쓰일 수 있습니다.\n\n```reason {21}\n/*  allType 배리언트 선언  */\ntype allType =\n  | GT(int)\n  | LTE(int);\n\n/*  배리언트로 감싸진 객체 반환 */\nlet conditionFunc = (isHeavy: bool) => {\n  isHeavy ? GT(20) : LTE(20);\n};\n\n\nconditionFunc(true)->Js.log; /*  { TAG: 0, _0: 20 }  */\n```\n\nconditionFunc를 실행하면 원하는 객체가 아닌 **{'{'} TAG: 0, \\_0: 20 {'}'}**와 같은 배리언트로 둘러싼 값이 나오기 때문에, 원하는 값으로 만들기 위해 앞서 설명한 Js.Dict를 활용하겠습니다.\n\n```reason\nlet toData = (input: allType) => {\n  let ret = Js.Dict.empty();\n  switch (input) {\n  | GT(v) => ret->Js.Dict.set(\"gt\", v)\n  | LTE(v) => ret->Js.Dict.set(\"lte\", v)\n  };\n  ret;\n};\n\nconditionFunc(true)->toData->Js.log; /*  { gt: '20' }  */\n```\n\n이렇게 해서 배리언트를 사용하여 서로 다른 객체를 반환하는데 성공했습니다! 그림으로 다시 보겠습니다.\n\n![ReasonML-Variant-Example](./reasonml-variant1.png)\n\n이렇게 allType 배리언트를 선언하고, 안에 20을 넣었습니다.\n\n![ReasonML-Variant-Example](./reasonml-variant2.png)\n그 후 배리언트 안의 값을 꺼내어, toData 함수를 사용하여 객체를 재구성했습니다.\n\n배리언트를 통한 작업은 Js.Dict만 사용한 이전의 해법보다 더 엄밀한 타이핑이 적용되었습니다. 이제 conditionFunc는 GT, LTE만 리턴하며 allType에 정의되지 않은 타입을 절대 리턴하지 않습니다.\nJs.Dict가 key-value 쌍이 있는 모든 객체를 리턴했던것과 차별되는 부분입니다. 하지만 코드가 길고 배리언트 안의 값을 뽑아서 Js.Dict로 재구성하는 등의 부수적인 절차가 필요했습니다.\n\n### 해결 방안 5 - 배리언트와 언박싱 GADT(심화)\n\n마지막으로, GADT(General Algebraic Data Types)와 언박싱 태그(@unboxed)를 이용한 좀 더 고차원적인 해법도 있습니다.\n그 중에서도 GADT는 난이도가 높은 개념이라 다른 포스팅에서 추가로 다루도록 하고, 간략히 언박싱에 대해서만 먼저 다루겠습니다. 설명은 BuckleScript를 개발한 Hongbo님이 작성한 [리스크립트 블로그 글](https://rescript-lang.org/blog/bucklescript-release-7-0-2)을 참고했습니다.\n\n```reason\n/*  언박싱  */\n[@unboxed]\n/*  GADT 정의  */\ntype t =\n  | Any ('a) : t;\n\n/*  GADT 배리언트의 배열 정의  */\nlet array = [|Any(3), Any(\"a\")|];\n```\n\n<br />\n\n```javascript\n/*  컴파일 결과  */\nvar array = [3, 'a'];\n```\n\n3, \"a\"처럼 서로 타입이 다른 데이터를 Any 로 감싸 한 배열에 넣었습니다. 컴파일 결과 배열 안에는 Any의 실 값 3과 \"a\"가 잘 들어 있습니다. 여기서 만약 언박싱 태그가 없었다면 컴파일 결과는 어땠을까요? 아래와 같습니다.\n\n```javascript\n/*  @unboxed가 없을 때  */\nvar array = [\n  /*  Any  */ {\n    _0: 'hello',\n  },\n  /*  Any  */ {\n    _0: 3,\n  },\n];\n```\n\n이렇듯 \\_0 같은 메타 정보가 붙어 안의 값을 직접 불러오는 것이 번거로워집니다. 하지만 언박싱을 이용하면 값을 바로 가져오기 때문에 서로 다른 타입의 데이터를 한 배열에서 직접 사용할 수 있습니다. 이제 실제 코드에서 사용해보겠습니다.\n\n```reason\n[@unboxed]\ntype t =\n  | Any(Js.t({..})): t;\n  /*\n    - t는 GADT의 개념으로 사용되었습니다.\n    - Any 안의 값을 JSON으로 제한합니다.\n  */\n\n[...]\n\"weight\":\n  if (isHeavy) {\n    Any({\"gt\": 20}); /*  Any에 @unboxed가 있으므로 실 값이 바로 리턴됩니다.  */\n  } else {\n    Any({\"lte\": 20});\n  }\n```\n\n<br />\n\n```reason\ntype t =\n  | Any(Js.t({..})): t;\n```\n\n위의 코드는 Any 안의 데이터를 JS 객체로 한정하는 역할을 합니다. 다른 원시타입(int, string 등)은 올 수 없습니다.\n아래는 JS로 컴파일된 결과입니다.\n\n```javascript\n\"where\": {\n  \"weight\":\n    if (isHeavy) {\n      return {\"gt\": 20};\n    } else {\n      return {\"lte\": 20};\n    }\n},\n```\n\n무엇을 한 것인지 다시 한번 짚어보겠습니다.\n\n![ReasonML-Not-Compile-Example](./reasonml-any1.png)\n\n- 하나의 분기문에서 리턴하는 객체의 구조가 다르면, 컴파일이 되지 않습니다.\n- 따라서 GADT를 활용하여 JSON이 올 수 있는 Any타입을 만들었습니다.\n\n![ReasonML-Compile-Example](./reasonml-any2.png)\n\n- 이후 언박싱 태그를 붙여 Any 안의 값을 바로 꺼내올 수 있도록 했습니다.\n\n## 비교\n\nReasonML의 타입 시스템을 상대하는 다섯가지 방법에 대해 알아보았습니다. 흥미롭게도, 타입 안정성과 코드의 간결함은 반비례 관계에 있습니다.\n모든 데이터에 타입을 적용하면 안정성은 높아지는 대신 코드가 길어지고, 반대로 타입 시스템을 무시하고 코드를 작성하면 코드는 짧지만 안전하지 않습니다. 그림으로 이 느낌을 표현해보았습니다.\n\n![ReasonML-Comparison-Graph](./reasonml-graph.png)\n\n이처럼 트레이드 오프가 명확한 상황에선 **어떤 부분의 안정성을 중요시 할 것인가**가 중요한 질문입니다.\n그랜랩스는 **비즈니스 데이터는 완전한 타이핑**으로 오류 없는 코드를, **라이브러리 혹은 기존의 API를 사용할 때는 선택적인 타이핑**으로 개발의 효율을 추구하고 있습니다.\n위의 프리즈마 쿼리를 작성하는 예시는 후자에 해당하므로 5번(언박싱과 GADT) 방식을 사용하였습니다.\n\n## 맺으며\n\n이번 글에서는 ReasonML의 타입시스템을 적용하며 만날 수 있는 기본적인 문제에 대한 대처방안을 알아보았습니다.\n\n1. `[%raw]` 를 통해 직접 JS 코드 넣기\n2. `Obj.magic`을 이용한 컴파일러 속이기\n3. `Js.Dict` 로 감싸서 리턴하기\n4. 배리언트를 이용한 해법\n5. 언박싱과 GADT을 이용한 해법\n\n이번에 설명하지 못했던 GADT의 개념과 배리언트의 더 자세한 사용법은 앞으로의 포스팅에서 다루도록 하겠습니다.\n또 다른 글에서 만나길 기대하며, Merry ReasonML, Happy new year!\n\n<br />\n<br />\n<br />\n<br />\n\n#### 참고자료\n\n- [https://reasonml.github.io/](https://reasonml.github.io/)\n- [https://rescript-lang.org/blog/bucklescript-release-7-0-2](https://rescript-lang.org/blog/bucklescript-release-7-0-2)\n- [https://rescript-lang.org/docs/manual/latest/api/js/dict](https://rescript-lang.org/docs/manual/latest/api/js/dict)\n- [https://rescript-lang.org/docs/manual/latest/object](https://rescript-lang.org/docs/manual/latest/object)\n\n[^1]: [https://www.prisma.io/](https://www.prisma.io/)\n[^2]: [https://www.prisma.io/docs/concepts/components/prisma-client/filtering](https://www.prisma.io/docs/concepts/components/prisma-client/filtering)\n\n<Author\n  email=\"tlonist.sang@gmail.com\"\n  name=\"김상현\"\n  description=\"백엔드 개발자\"\n  date=\"2020-12-21\"\n/>\n","excerpt":"자바스크립트나 다른 동적 타입을 가진 언어에서는, 함수나 분기문에서 타입이 다른 데이터를 리턴하는 것이 자연스럽습니다. 하지만 ReasonML에서는 항상 같은 데이터 타입이 리턴되어야 합니다. 처음 ReasonML을 접하게 되면 이런 타입 시스템의…","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","tags":[{"name":"ReasonML","slug":"reason-ml"},{"name":"object","slug":"object"},{"name":"variant","slug":"variant"},{"name":"raw","slug":"raw"},{"name":"dict","slug":"dict"},{"name":"gadt","slug":"gadt"},{"name":"unbox","slug":"unbox"}]},{"slug":"/reason-ml-the-good-parts","title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020년 12월 15일","body":"\n> [ReasonML](https://reasonml.github.io/)의 기본적인 정보는 그린랩스 기술 블로그의 [자바스크립트 개발자를 위한 ReasonML](/what-is-reason-ml)을 참고해주세요!\n\n저는 이전까지 자바스크립트와 타입스크립트 환경의 리액트 프론트엔드 프로젝트를 진행했었습니다. 그러나 그린랩스에선 프론트엔드 프로젝트에 ReasonML과 ReasonReact를 사용합니다. ReasonML은 강력한 정적 타입 시스템을 장착한 함수형 언어인 OCaml에 뿌리를 둔 ReScript 컴파일러에 의해 자바스크립트 코드로 변환되고, 이는 브라우저나 Node.js 기반에서 실행됩니다.\n\n이 포스팅에서는 **ReasonML** 로 프로젝트를 진행하며 느낀 **장점을** 이야기합니다. 아마 제가 기존까지 사용했던 자바스크립트와 타입스크립트 환경과의 비교 과정일 것입니다.\n\n### 1. 자바스크립트 import, export 구문과 ReasonML의 모듈 레졸루션\n\n첫째로 말하고 싶은 장점은 **모듈을 다루는 ReasonML/OCaml의 방식**입니다.\n\n프로젝트의 성장에 따라 새로 탄생하는 코드도 있고, 더이상 사용하지 않는 코드도 생깁니다. 만일 코드를 주기적으로 정리하지 않는다면, 어떤 모듈은 import 된 채 아무도 찾지 않는 유령처럼 프로덕션 코드 더미를 떠돕니다. 이렇게 되면 번들 사이즈가 불필요하게 증가합니다. 또한 사용처 없이 떠도는 import는 코드 히스토리를 잘 알지 못하면 지워야할지 남겨야할지, 나중에 그 코드를 확인하는 개발자는 혼동스러울 겁니다.\n\n제가 경험한 자바스크립트나 타입스크립트 프론트엔드 프로젝트 엔트리 파일의 구조는 회사나 프로젝트마다 달랐습니다. 그러나 초기 환경구성작업은 대부분 비슷한 일을 필요로 합니다. 브라우저 지원 범위나 서비스의 크기에 따라 브라우저 폴리필 삽입, 글로벌 스타일 삽입, 기능에 따라 라우팅 설정을합니다. 또 리액트 프로젝트라면 각종 프로바이더를 엔트리 컴포넌트에서 불러오는 경우도 있었습니다.\n\n환경 구성을 하기위해 모듈을 불러야 하고, 모듈은 **import, export** 구문을 사용하여 부릅니다. 물론 IDE 종류에 따라 import 구문이 자동 완성되는 경우도 있습니다.\n\n리덕스같은 상태관리 도구를 프로젝트에 추가하는 경우를 생각해보겠습니다. 리덕스의 액션과 리듀서, 비동기 처리를 위해 미들웨어를 추가하고 배포 가능한 수준까지 만들기위해 여러 패키지와 import 구문을 계속 추가해야합니다. 만일 타입스크립트를 사용하기로 했다면 작성해야 할 코드의 양은 더 늘어납니다. `immer-reducer`나 `typesafe-actions`처럼 타입 안정성을 해치지 않으면서 코드의 양을 줄여주는 라이브러리들이 있지만 역설적이게도 이에 따른 import 구문은 더 늘어납니다.\n\n<br />\n\n**끝나지 않는 export**\n![so-many-export](so-many-export.png)\n\n그래서 누군가는 import 구문을 행사(Ceremony) 코드로 분류하기도 합니다. 행사 코드는 프로그램의 핵심 동작에 직접적인 영향을 끼치지 않지만 언어와 프레임워크에 의해서 작성이 강제되는 코드를 뜻합니다.\n\n> [Ceremony vs. Essence Revisited](https://dev.to/yysun/ceremony-vs-essence-revisited-5e77) <br/> Plain JavaScript vs Svelte vs React vs Vue의 Ceremony 코드 비율 비교\n\n**ReasonML에서는 import 구문을 쓰지 않아도 컴파일러가 알아서 해당하는 모듈을 찾아줍니다.**\n\n> [ReasonML에서 모듈 레졸루션은 어떻게 동작하나요?](https://reasonml.github.io/docs/ko/faq#i-dont-see-any-import-or-require-in-my-file-how-does-module-resolution-work) <br/>\n> Reason/OCaml doesn't require you to write any import; modules being referred to in the file are automatically searched in the project. Specifically, a module Hello asks the compiler to look for the file hello.re or hello.ml (and their corresponding interface file, hello.rei or hello.mli, if available). <br/><br/>\n> Reason/OCaml은 import 구문이 필요없습니다. 모듈은 프로젝트 안에서 자동적으로 찾아집니다. `Hello` 라는 모듈은 컴파일러를 통해 Hello.re 또는 Hello.ml 파일을 찾습니다. (만약 그에 대응하는 인터페이스 파일인 Hello.rei, Hello.mli이 존재한다면 이것도 같이 찾습니다)\n\nReasonML을 사용해 `Farm.re` 컴포넌트를 만들어보겠습니다.\n\n```reason\n[@react.component]\nlet make = () => {\n  <>\n    <Farmer.Novice>\n      <Greenhouse> <Broccoli /> </Greenhouse>\n      <Greenhouse> <Pumpkin /> </Greenhouse>\n    </Farmer.Novice>\n    <Farmer.Expert>\n      <Greenhouse> <Potato /> </Greenhouse>\n      <Greenhouse> <Pumpkin /> </Greenhouse>\n      <Greenhouse.GableRoof> <Pumpkin /> </Greenhouse.GableRoof>\n      <Greenhouse.GableRoof> <Pumpkin /> </Greenhouse.GableRoof>\n      <Greenhouse.GothicArch> <Broccoli /> </Greenhouse.GothicArch>\n    </Farmer.Expert>\n  </>;\n};\n```\n\n어떠한 import 구문도 사용하지 않았지만 **정상 컴파일**됩니다. 결과적으로 import로 인한 Ceremony 코드를 줄일 수 있습니다. ReasonML로 된 파일을 열면, 긴 import 구문 대신, 타입 선언과 비즈니스 로직이 제일 위에 보입니다.\n\n### 2. es-lint, prettier 설정이 필요없는 자체 포매터\n\nReasonML 포매터(refmt)의 장점은 모듈 레졸루션이 가지는 장점처럼 Ceremony 코드를 줄이는 효과도 있고 다른 장점도 있습니다.\n\n자바스크립트와 타입스크립트로 프론트엔드 작업을 했을 때, 린팅 및 포매팅 자동화는 협업의 생산성을 높여줍니다. 하지만 유용하게 사용하기 위해서는 설치하는 패키지가 적지 않습니다.\n\n린팅 규칙 설정은 개인 성향이나 회사 성향따라 조금씩 다릅니다. 그래서 특정 벤더의 린팅 규칙을 모태로 확장하거나 축소합니다. 그리고 변경되는 개별 룰에 대해서는 팀의 동의도 얻어야 합니다. 여기다 타입스크립트 규칙이나 리액트만 적용되는 규칙을 추가하고 또 웹 접근성 관련 린팅 규칙을 추가하다보면 `.eslintrc` 파일이 결국 프로젝트 라이프사이클에 포함됩니다.\n\n**ReasonML 에서는 `refmt` 라는 컴파일러 차원에서 지원해주는 포매터**가 있습니다. 또한 ReasonML은 자바스크립트나 타입스크립트가 아니기 때문에 eslint 관련 패키지 설치와 관리가 전혀 필요 없습니다.\n\nReasonML의 핵심 기여자 중 한 명인 Cheng Lou는 `refmt`에 대해 몇가지 장점을 이야기합니다.\n\n> [Cool Things Reason Formatter Does - 리즌 포매터가 하는 멋진 일들](https://medium.com/@chenglou/cool-things-reason-formatter-does-9e1f79e25a82) <br/> Think of it as Prettier or Gofmt but for Reason. - 리즌을 위한 Prettier 또는 Gofmt(Golang 포매터)\n\n- 코드를 더 읽기 쉽게 시맨틱하게 변경\n- 변경 전과 후의 추상 구문 트리는 동일\n- 공짜 커리(Curring)를 🍛 얻을 수 있음\n- 자바스크립트 interop 때 코드를 알아서 구문 변환\n- 들여쓰기 자동 처리\n\n[여기서 **Refmt (Reformat)** 를 바로 테스트해볼 수 있습니다](https://reasonml.github.io/en/try?rrjsx=true&reason=C4TwDgpgBMBOHQLxQDIQIYDMoB8oDkB7AEwgAoBLAO2ABoZ4J64EBKAbgChOAbCYKPADGUAM4BXALZRklYBEmsZAPigBvTlDEB3CsCEALKHIVKNWvGiwqoABk24CJcgDd0PcUyh9MdQRQBzA2AlRFU3D2gAajEpMh8QqBiJSTJYQOCOBwBfTmyuXn4oSRAAFUYZByJSMgctAEZaOqcagCZ6avIAFnorTF6MTFYO5zIANgGsSaHh5s6yAGYRmoBWaenhlvIAdnXUQdZWByzOAClRADoeQgCyFLIS8rYOIA)\n\n### 3. 타입스크립트보다 읽기 쉬운 컴파일러 오류 메시지\n\n타입스크립트는 정적 타이핑을 가능하게 해줍니다. 덕분에 바닐라 자바스크립트보다 협업하기 좋습니다. 현재 타입스크립트 생태계는 활발하고 문서도 많고 예제도 많기 때문에 타입스크립트로 처음 프론트엔드 개발을 시작하는 것이 어렵지 않습니다.\n\n저도 이전까지 타입스크립트에 타입 추론과 타입 체킹에 감탄했고 그 생태계에 여전히 지지를 보냅니다만 아쉬운 점 하나를 말해보겠습니다.\n\n타입스크립트는 컴파일 오류 메시지가 읽기 어렵습니다. 친절한 거 같은데 너무 과도해서 무엇이 잘못됐는지 헛갈릴 때가 많습니다. 특히 `ts(2322)`, `ts(2345)` 등이 그랬습니다. 그럼 오류를 안나오는 코드를 만들면 될텐데 사실 그게 쉽지는 않습니다. 🥲\n\n특히 계층 구조 객체 특정 필드의 타입 지정 오류가 생겼을 때, 오류 메시지가 너무 장황하고 길어 정확하게 어떤 부분이 오류인지 찾기 힘들었습니다.\n\n<br />\n\n**자세하고 읽기 어려운 타입스크립트 오류 메시지**\n![typescript-error](ts-error.png)\n\n그러나 ReasonML 컴파일러는 오류 메시지는 타입스크립트 오류 메시지보다는 적당히 😅 구체적입니다. 때문에 오류를 찾을 때 더 짧은 시간이 걸렸습니다.\n\n### 4. 배리언트(Variant)와 패턴 매칭으로 논리적인 코드 생산\n\n잘 돌아가는 코드를 일부러 복잡하게 만드는 일은 누구도 원하지 않겠지만, 조건 렌더링이 필요한 상황은 종종 찾아옵니다.\n\n조건의 조건, 조건의 조건의 조건, 조건의 조건의 조건의 조건에 따라 각기 다른 컴포넌트가 렌더링 되어야 할 때도 있습니다. 이 경우 코드를 분리하거나 공통 부분을 추출해 리팩토링 하면 좋을 것입니다.\n\nReasonML은 배리언트를 이용해 논리 전개를 직관적으로 작성할 수 있습니다. 배리언트는 다른 언어의 enums과 비슷하지만 선택적으로 데이터를 포함시키는 것이 가능합니다. 아래는 **로딩, 로드 됨, 오류 3가지 상태**에 따라 렌더링하는 간단한 예제입니다.\n\n```reason {2-4,13-15}\ntype state =\n  | Loading\n  | Loaded(detail)\n  | Error(error);\n...\n  id->doSomething->Js.Promise.then_((result) => {\n    setData(_prevState => Loaded(result));\n  })\n  |> Js.Promise.catch((error) => {\n    setData(_prevState => Error(error));\n  });\n  switch (data) {\n    | Loading => <Loading />\n    | Loaded(contents) => <Detail contents>\n    | Error(error) => <Error error/>;\n  };\n```\n\nGraphQL 쿼리를 포함한 코드도 한 번 보겠습니다. 패턴 매칭을 통해 각 상태를 렌더링합니다.\n\n```reason\nlet farm = Query.MyFarm.use({id: int_of_string(id)});\nswitch (farm) {\n  | {loading: true, data: None} => <Spinner />\n  | {error: Some(error)} => <Error error=error/>\n  | {data: None, error: None, loading: false} => <Error />\n  | {data: Some({myFarm})} =>\n    <Farm key={string_of_int(myFarm.id)} farm=myFarm />\n}\n```\n\n각 패턴마다 **무엇을, 왜 렌더링**하는지 쉽게 읽힙니다. 배리언트와 패턴매칭은 상태 관련 렌더링 코드 쓰기에 효과적입니다.\n\n패턴매칭과 배리언트의 또한가지 장점은 서술되지 않은 케이스에 대해서는 Warning으로 알려줘서 모든 case에 대해 렌더링 코드를 작성하게끔 도와줍니다.\n\n처음 예시의 코드에서 `Loaded` 케이스를 제외해보겠습니다.\n\n```reason\ntype state =\n  | Loading\n  | Loaded(detail)\n  | Error(error);\n...\nswitch (data) {\n  | Loading => <Loading />\n  | Error(error) => <Error error/>;\n};\n```\n\n이러면 나머지 케이스(즉, 여기서는 `Loaded`) 대해 렌더링 코드를 작성하지 않았음을 명시적으로 알려줍니다.\n\n```sh\nWarning 8: You forgot to handle a possible case here, for example:\n  Loaded _\n```\n\n**배리언트와 패턴매칭은 코드로 쓰여진 논리가 허술하지 않도록 도와줍니다.**\n\n> [배리언트 공식 문서](https://rescript-lang.org/docs/manual/latest/variant) <br/> [패턴매칭/구조분해 공식 문서](https://rescript-lang.org/docs/manual/latest/pattern-matching-destructuring)\n\n### 5. 컴파일 시점에 CSS 타입 체크\n\n올바른 CSS를 작성했는지 확인하기 위해 스타일 관련 린팅 도구를 설치해본 적 있으신가요? [State of CSS 2020](https://2020.stateofcss.com/en-US/technologies/other-tools/) 에서는 설문에 참여한 `43.2%`중 `75%`의 개발자가 `Stylelint`를 사용한다고 답변했습니다.\n\n자바스크립트 생태계에서 CSS를 작성하는 방식은 여러가지가 있습니다. 그린랩스는 CSS-in-CSS와 CSS-in-JS를 상황에 따라 결정해 사용합니다. 여기서는 CSS-in-JS 자체에 대해서는 깊게 다루지 않겠습니다. (위의 State of CSS 2020을 참고해주세요!)\n\n저는 프론트엔드 개발자로서 **스타일링 버그도 프로젝트에 따라 서비스에 치명적인 상처**를 줄 수 있는 부분이라 생각합니다. 개발자가 단위를 혼동하거나 쓸 수 없는 속성을 넣을 경우, 기대했던 디자인이 나오지 않거나 어쩌면 기능이 오동작하기도 합니다. 때문에 간단한 스타일링 실수로도 나쁜 사용자 경험을 만들수 있습니다.\n\nReasonML에서는 [bs-css](https://github.com/reasonml-labs/bs-css) 패키지를 통해 컴파일 시점에 CSS 체크가 가능합니다. bs-css의 사용 방법은 CSS-in-JS 라이브러리로 유명한 `Emotion`인터페이스와 유사합니다. (Emotion을 ReasonML에서 쓸 수 있도록 바인딩했기 때문입니다. [바인딩](https://rescript-lang.org/docs/manual/latest/external)에 대해서는 다른 포스팅에서 다루겠습니다)\n\n```reason\nmodule Styles = {\n  open Css;\n  let card = style([\n    display(flexBox),\n    flexDirection(column),\n    alignItems(stretch),\n    backgroundColor(white),\n    boxShadow(Shadow.box(~y=px(3), ~blur=px(5), rgba(0, 0, 0, 0.3))),\n  ]);\n  let actionButton = disabled =>\n    style([\n      background(disabled ? darkgray : white),\n      color(black),\n      border(px(1), solid, black),\n      borderRadius(px(3)),\n    ])\n};\n<div className=Styles.card>\n  <h1 className=Styles.title> \"Hello\"->React.string </h1>\n  <button className=Styles.actionButton(false) />\n</div>\n```\n\n스타일링과 관계 된 패키지 중 또 하나 소개하고 싶은 라이브러리가 있습니다. ReasonML 문법 안에서 `styled-component` 형식으로 스타일 작성을 도와주는 **[styled-ppx](https://github.com/davesnx/styled-ppx)** 입니다.\n\n`styled`는 느낌적인 느낌으로 알겠는데 `ppx`는 뭘까요?\n\nReasonML의 부모인 OCaml에는 **[PPX(PreProcessor eXtensions)](https://ocamlverse.github.io/content/ppx.html)**라는 기능이 있습니다. PPX를 통해 문법적 확장이 가능합니다. 마치 새로운 문법이 만들어진 것처럼 구문을 작성할 수 있습니다.\n\n다음은 styled-ppx를 이용해 컴포넌트를 작성한 예시입니다.\n\n```reason\nmodule Title = [%styled.h1\n  {|\n    font-size: 1.5rem;\n    font-weight: 700;\n  |}\n];\nmodule Description = [%styled.p\n  {|\n    color: #76798A;\n  |}\n];\n<>\n  <Title> {j|Like-Styled-Component|j}->React.string </Title>\n  <Description> {j|How About This?|j}->React.string </Description>\n</>\n```\n\nPPX에 대한 설명은 쉽지 않기 때문에 다른 포스팅에서 더 깊게 다루겠습니다. 😅 궁금하신 분은 밑의 링크를 참고해주세요!\n\n> [What is PPX?](https://ppxlib.readthedocs.io/en/latest/what-is-ppx.html)\n\n중요한 것은 `bs-css`를 사용하든 `styled-ppx`를 사용하든 **컴파일 시점에 CSS 프로퍼티에대해 타입체킹** 받을 수 있다는 사실입니다. 각 프로퍼티에 맞지 않는 타입을 넣으면 컴파일이 안 됩니다! 👍 &nbsp;\n\n혹시 스타일까지 타입체킹을 받는 건 가혹하다 생각하시나요? 😉 이 부분은 팀마다 다른 결론이 나올 것 같습니다만 그린랩스 웹 개발팀에서는 `bs-css`의 사용비중을 높게 가져가고 있습니다!\n\n### 6. GraphQL 사용할 때 전방위적 타입 체크\n\n그린랩스 백엔드와 프론트엔드팀은 GraphQL 스키마를 공통으로 사용합니다. 프론트엔드에서는 GraphQL에 대한 타입체킹 및 ReasonML 문법 확장을 위해 [graphql-ppx](https://graphql-ppx.com/)를 사용합니다.\n\n이런 스키마가 있습니다.\n\n```graphql\n...\ntype MyFarm {\n  id: Int!\n  name: String!\n  area: Float!\n  crop: Crop!\n}\n...\n```\n\nReasonML 설정 파일인 `bsconfig.json`에 graphql-ppx 의존성을 추가하면 위 스키마로 **Fragment와 Query**를 ReasonML 문법으로 작성할 수 있습니다.\n\n```reason\n[%graphql\n{|\n  fragment Farm on MyFarm {\n    id\n    name\n    crop {\n      ...Crop\n    }\n  }\n|}\n];\nmodule MyFarm = [%graphql\n  {|\n    query myFarm($id:Int!){\n      myFarm(id:$id){\n        ...Farm\n      }\n    }\n  |}\n];\n```\n\n위 ReasonML 코드를 작성하면 graphql-ppx가 `MyFarm`에 대해 타입을 자동 생성합니다. (이 코드를 개발자가 작성할 필요 없습니다)\n\n```reason\ntype t = {\n  __typename: string,\n  id: int,\n  name: string,\n  crop: Crop.t\n}\n```\n\n그럼 컴파일러는 위 타입을 기준으로 타입검사를 해줍니다. IDE에서 자동완성과 타입힌트 역시 추가적으로 누릴 수 있습니다. 덕분에 쿼리 또는 뮤테이션을 올바르게 작성했는지 알려주고, 사용처에서 올바른 타입을 사용하는지 알려줍니다.\n\n프로덕션 스키마의 크기는 예제와 비교할 수 없을만큼 늘어날겁니다. 그럴 때 주의하지 않으면 놓칠 수 있는 부분을 **ReasonML + graphql-ppx의 도움으로 컴파일 시점에 방지**할 수 있습니다.\n\n### 7. 그밖에 장점이라 느낀 것\n\n- 비슷한 규모의 타입스크립트 프로젝트보다 빠른 빌드 속도를 체감했습니다. 현재 Github 액션을 통해 빌드 및 배포를하고 있습니다. ReasonML 빌드 시간은 11초가 걸립니다. Webpack 빌드를 포함하면 1분 30초 이내로 모든 빌드가 완료됩니다.[^1]\n- 타입스크립트로 프로젝트를 진행했을 때보다 타입정의를 덜 했지만, 더 타입추론이 잘 된다고 느꼈습니다. 때문에 인터페이스나 타입작성을 많이 할 필요가 없었습니다.[^2]\n\n## 정리\n\n위에 나열한 장점 말고도 다른 팀원 분이 올려주신 [포스팅](/what-is-reason-ml)에도 장점이 많이 설명 되어있습니다. 시간이 괜찮으시다면 읽어보시는 걸 추천드립니다. ReasonML의 매력을 좀 더 느낄 수 있습니다.\n\n물론 이 포스팅에서는 장점만 이야기했습니다. 그러나 **IDE 지원 미비, 불편한 유니코드 사용 방법, 아직 부족한 공식문서 등**은 단점입니다. 단점은 다른 포스팅에서 더 자세히 다룰 예정입니다.\n\n그리고 개발 환경구성을 타입스크립트로 구성할 때보다 금방할 수 있었습니다. 불필요한 패키지 설정과 트랜스파일 설정이 필요없기 때문입니다.\n\n불필요한 패키지 설치와 린팅 설정, import 구문 사용은 결국 Ceremony 코드에 가깝습니다. 그린랩스 웹 개발팀은 ReasonML을 사용해 프론트엔드 개발을 하며 많은 Ceremony 코드를 줄였고 **핵심 로직 개발에 더 집중**할 수 있었습니다.\n\n[저희와 ReasonML에 대해 같이 이야기 나누실 분을 애타게 기다리고 있습니다. 😃🐫](https://greenlabs.co.kr/채용정보/채용정보/)\n\n<Author\n  email=\"yousleepwhen@gmail.com\"\n  name=\"윤정식\"\n  description=\"프론트엔드 개발자\"\n  date=\"2020-12-15\"\n/>\n\n[^1]: [TypeScript-VS-ReasonML](https://blog.dubenko.dev/typescript-vs-reason/)\n[^2]: [5 examples with TypeScript, Flow and ReasonML](https://codeburst.io/inference-engines-5-examples-with-typescript-flow-and-reason-edef2f4cf2d3)\n\n<hr />\n\n#### Thanks to\n\n프리뷰 해주신 **change.my.uniform** 채널 분들께 감사드립니다.\n","excerpt":"ReasonML의 기본적인 정보는 그린랩스 기술 블로그의 자바스크립트 개발자를 위한 ReasonML을 참고해주세요! 저는 이전까지 자바스크립트와 타입스크립트 환경의 리액트 프론트엔드 프로젝트를 진행했었습니다. 그러나 그린랩스에선 프론트엔드…","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","tags":[{"name":"ReasonML","slug":"reason-ml"},{"name":"OCaml","slug":"o-caml"},{"name":"React","slug":"react"},{"name":"GraphQL","slug":"graph-ql"}]},{"slug":"/what-is-reason-ml","title":"자바스크립트 개발자를 위한 ReasonML","date":"2020년 12월 1일","body":"\n## 시작하며\n\n> ReasonML은 OCaml과 자바스크립트의 특징을 두루 가지고 있는 현대적 프로그래밍 언어입니다. 특히 리액트나 그래프큐엘과 같이 널리 쓰이는 기술과도 잘 맞아서 개발자의 생산성을 많이 올려줍니다.\n\n그린랩스에서는 [ReasonML](https://reasonml.github.io/)로 풀스택 웹 개발을 하고 있습니다. 수개월간 제품 개발에 사용해본 결과, 지금은 ReasonML 덕분에 전체적인 개발 생산성이 많이 올라갔습니다. 하지만 한국에서 ReasonML은 아직 생소한 언어인 것 같습니다.\n\n이 글은 웹 개발을 할 때 ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 이 글이 ReasonML에 관심있는 분에게 조금이라도 도움이 되길 바랍니다.\n\n## ReasonML 특징\n\n### 1. 자바스크립트와 좋은 관계\n\n<br />\n\n```reason\n/* 상품명 앞에 \"Name: \"을 붙여주는 함수 */\nlet formatName = product => \"Name: \" ++ product.name;\n```\n\n만약 자바스크립트 개발 경험이 있다면, 위의 코드가 쉽게 읽힐 것입니다. 그러나 자바스크립트처럼 생긴 위 코드는, 실은 ReasonML 코드입니다. ReasonML은 2016년에 만들어진 매우 현대적인 언어임에도 자바스크립트를 포함한 C 스타일의 언어에 익숙한 사람에게 친숙해지는 것을 목표로 설계되었습니다. 따라서 문법(Syntax)의 많은 모양새가 자바스크립트를 닮았습니다.\n\n또한 ReasonML 코드는 자바스크립트 코드로 컴파일되어 브라우저와 노드 환경 양쪽에서 실행 가능합니다. 따라서 우리가 기존에 웹 개발을 할 때 사용했던 리액트, 익스프레스 등 자바스크립트 생태계를 그대로 사용할 수 있습니다.\n\n### 2. 강력하고 안전한 타입 시스템\n\nReasonML은 강력한 타입 시스템을 가진 정적 언어입니다. 강력한 타입 시스템은 프로그래밍 할 때, 버그를 줄여주고 유지 보수를 용이하게 해줍니다. 개발자가 ReasonML의 강력한 타입 시스템을 통해 얻는 이점은 다음의 두 가지로 설명할 수 있습니다.\n\n첫 번째로, 런타임에 **null/undefined 타입 에러가 발생하지 않음을 보장합니다.** ReasonML은 안전한(_Sound_) 타입 시스템을 가졌기 때문에 컴파일러의 타입 검사를 통과한 코드는 위와 같은 에러가 발생하지 않습니다.\n\n두 번째로, 타입 추론 능력이 뛰어나기 때문에, **개발자가 불필요한 타입 어노테이션을 적을 필요가 없습니다.** 그래서 타입 힌트로 인해 코드가 장황해지는 부작용이 없습니다.\n\n```reason\n/* 상품 타입을 선언 */\ntype product = {\n  name: string,\n  id: int,\n};\n\n/* 별다른 타입 힌트를 주지 않아도, 상품 타입으로 옳게 추론함. */\nlet updateName = (product, name) => { ...product, name };\n```\n\n실례로 페이스북은 2017년, 페이스북 메신저의 웹 버전을 ReasonML로 [포팅한 결과를 포스팅했습니다.](https://reasonml.github.io/blog/2017/09/08/messenger-50-reason) 해당 포스팅에서 페이스북은 1년 동안 단 10개의 버그를 찾았다고 발표했고, 가장 큰 이유로 ReasonML의 강력한 타입 시스템을 언급했습니다.\n\nReasonML에서 이런 마법 같은 일이 가능한 이유는 OCaml 언어의 안전한(_Sound_) 타입 시스템을 이용하기 때문입니다. 사실 ReasonML은 OCaml에 중괄호 문법 등을 추가해 자바스크립트를 사용했던 사람도 익숙하게 사용할 수 있도록 문법적으로 확장한 것입니다.\n\n**[OCaml]**\n\n```ocaml\nlet _ =\n  let msg = \"Hello\" in\n  print_string msg;\n  let msg2 = \"Goodbye\" in\n  print_string msg2\n```\n\n**[중괄호를 이용한 ReasonML]**\n\n```reason\n{\n  let msg = \"Hello\";\n  print_string msg;\n  let msg2 = \"Goodbye\";\n  print_string msg2\n};\n```\n\n<br />\n\n### 3. 빠른 컴파일 속도\n\nReasonML은 빠른 컴파일 속도가 장점입니다. 페이스북의 통계를 다시 인용하자면 [페이스북 메신저 프로젝트](https://reasonml.github.io/blog/2017/09/08/messenger-50-reason)에서 **수백 개 파일을 빌드 하는데 걸린 시간이 2초 이내**였고, 그 이후에 수행되는 점진적인 빌드 시간 또한 100ms를 넘지 않았습니다. 저도 회사에서 ReasonML 코드를 작성할 때, 자바스크립트 코드로 컴파일되는 시간은 대부분 50ms 이내 끝났습니다. 마치 파일 수정과 동시에 빌드가 완료되는 것 같았습니다.\n\nReasonML은 빌드 속도를 위해서 간결하고 빠르다고 알려진 [닌자](https://ninja-build.org/)를 빌드 도구로 선택했습니다. 그리고 ReasonML 빌드에 사용되는 OCaml 프론트엔드 컴파일러는 프랑스 국립 연구기관인 [INRIA](https://www.inria.fr/en)에 의해 수십 년 동안 연구 및 최적화되어서 굉장히 빠릅니다.\n\n공식 사이트에서 진행한 [컴파일 속도 테스트의 내용](https://rescript-lang.org/docs/manual/latest/build-performance#extreme-test)은 다음과 같습니다.\n\n- 조건: 맥북 프로 2015년형 (3.1GHz Intel Core i7) 기준. 10,000개의 파일을 생성하고, 절반은 의존성을 추가해 줌.\n- 결과: 클린 빌드 시, 3분 이내. 점진적 빌드 시, 의존성이 없는 경우, 평균 1초 안에 완료.\n\n또한 한 개발자가 타입스크립트와 ReasonML의 컴파일 속도를 비교한 [포스팅](https://blog.dubenko.dev/typescript-vs-reason/)이 있는데, TodoMVC 애플리케이션 컴파일 시, 타입스크립트와 리액트 조합은 총 6.18초나 걸린 반면, ReasonML + 리액트 애플리케이션은 0.99초 밖에 걸리지 않았습니다.\n\n정리하자면 ReasonML은 OCaml이지만 자바스크립트로 컴파일됩니다. 그래서 **_OCaml의 강력한 타입 시스템과 빠른 컴파일 속도라는 장점을 취하면서도, 동시에 가장 대중적이고 활발한 자바스크립트 생태계 전체를 활용할 수 있는 현대적 언어_**입니다.\n\n## ReasonML의 기원\n\n### 1. 리액트의 탄생\n\n갑자기 리액트가 등장해서 의아하시겠지만, ReasonML은 리액트를 만든 [Jordan Walke](https://twitter.com/jordwalke)가 만들었습니다. 그래서 그가 ReasonML을 왜 만들었는지 알기 위해서는 리액트의 탄생부터 알아보아야 합니다.\n\nJordan Walke는 페이스북에서 일하면서 [Standard ML](https://www.smlnj.org/)이라는 언어의 매력에 푹 빠져있었습니다. 그래서 리액트의 프로토타입 또한 SML로 만들었습니다. (이러한 이유로 리액트의 근본이 되는 철학은 객체 지향 프로그래밍보다는 함수형 프로그래밍에 더 가깝습니다.) 하지만 그는 대중성을 위해 리액트 프로젝트를 자바스크립트로 포팅하기를 결심합니다. 그 결과 리액트는 매우 큰 성공을 거두었고, 현재 세계에서 가장 유명한 프론트엔드 기술이 되었습니다.\n\n### 2. 함수형 혹은 강력한 타입 시스템의 여러 프로젝트들\n\n리액트가 나온 이후 몇몇 사람들은 리액트라는 구현체보다 그 바탕에 있는 패러다임을 주목했습니다. 이후 리덕스, 엘름과 같은 프로젝트들이 탄생했습니다. 어떤 프로젝트는 리액트와 함께 사용하는 라이브러리로, 어떤 프로젝트는 리액트와 경쟁하는 라이브러리가 됐습니다. 하지만 양쪽의 경우 모두 개발자들로 하여금 함수형 패러다임과 강력한 타입 시스템에 대한 관심을 증폭시키는 계기가 되었습니다. 이러한 프로젝트의 성공을 보며 페이스북과 Jordan Walke도 웹 개발을 위한 새로운 언어가 필요하다고 생각하게 됩니다.\n\n### 3. 버클스크립트 컴파일러[^1]의 탄생\n\n비슷한 시기에 많은 회사들이 자바스크립트에 타입 시스템을 도입하는 방법에 대해서 연구했습니다. 그 시도는 자바스크립트에 점진적 타입 시스템(타입스크립트, 플로우 등)을 적용하는 접근도 있었고, 정적 타입 언어를 개발하여 자바스크립트로 컴파일(퓨어스크립트 등)하는 접근도 있었습니다. 그 시도 중 하나로 블룸버그 개발자였던 [Hongbo Zhang](https://www.linkedin.com/in/hongbo-zhang-a8574157/)이 OCaml 컴파일러의 백엔드를 자바스크립트로 포팅했습니다. 그는 OCaml 코드를 자바스크립트로 컴파일해서 브라우저에서 실행하는데 성공했고, 이 프로젝트를 버클스크립트라는 오픈소스로 공개했습니다.\n\n### 4. ReasonML의 탄생\n\nJordan Walke가 리액트를 만들 때 사용했던 SML과 OCaml은 뿌리가 같습니다. 둘 다 [ML 계열의 언어](<https://ko.wikipedia.org/wiki/ML_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)>)로, 굳이 비유하자면 SML은 미국 사투리, OCaml은 프랑스 사투리입니다. 따라서 Jordan Walke는 새로운 언어를 만들며 OCaml과 버클스크립트 컴파일러를 활용해야겠다고 생각했습니다. 또한 그는 리액트 프로젝트를 자바스크립트로 포팅해 성공한 경험으로 인해, 새로운 언어가 자바스크립트 문법과 친숙해야한다고 생각했습니다. 그렇게 그는 OCaml에 문법을 추가했고, 그 결과 **ML 계열의 강력한 타입 시스템을 가지고 있으면서, 기존 자바스크립트 생태계와도 자연스럽게 융화될 수 있는 ReasonML이 탄생**했습니다.\n\n**[자바스크립트 문법]**\n\n```javascript\nconst myFun = (x, y) => {\n  const doubleX = x + x;\n  const doubleY = y + y;\n  return doubleX + doubleY;\n};\n```\n\n**[자바스크립트와 닮아있는 ReasonML 문법]**\n\n```reason\nlet myFun = (x, y) => {\n  let doubleX = x + x\n  let doubleY = y + y\n  doubleX + doubleY\n}\n```\n\n최근 Jordan Walke는 ReasonML에 대해서 [다음과 같은 의견](https://news.ycombinator.com/item?id=23173151)을 가지고 있습니다.\n\n> ReasonML은 여러 가지 하위 프로젝트를 위한 생태계이자 스폰서다. 이 모든 프로젝트는 타입 안정성, 빠른 컴파일 및 빠른 실행 코드를 많은 개발자들에게 제공한다는 목표를 가지고 있다.\n\nReasonML이 새로운 문법을 추가하여 프로그래밍 언어적으로 발전하는 것도 물론 중요하지만, 보다 높은 수준에서의 진정한 목표는 **_타입 안정성, 빠른 컴파일 속도, 빠른 실행 속도_** 이 세 가지라는 것입니다. 이와 관련하여 보다 자세한 내용이 담겨있는 발표 자료가 있으니 참고하시면 좋을 것 같습니다.\n\n**[React to the Future - Jordan Walk]**\n\n<iframe\n  id=\"ytplayer\"\n  type=\"text/html\"\n  width=\"100%\"\n  height=\"400\"\n  src=\"https://www.youtube.com/embed/5fG_lyNuEAw\"\n  frameborder=\"0\"\n></iframe>\n\n## 타입스크립트와의 비교\n\nReasonML과 타입스크립트 모두 타입을 도입하여 자바스크립트를 보다 안전하게 사용하기 위한 목적으로 만들어졌습니다. 현재 타입스크립트는 가장 성공한 자바스크립트의 타입 시스템이 아닐까 싶습니다.\n\n1. 자바스크립트 문법과의 하위 호환\n2. 사용성\n3. 완벽한 타입 안정성\n\n여기서 두 가지만 선택해야 한다면 어떤 것들을 선택하시겠나요? 타입스크립트는 1,2번을 선택하였고, ReasonML은 2,3번을 선택하였습니다.[^2] 이것은 옳고 그름의 문제가 아닙니다. 언어별로 디자인의 철학이 다를 뿐입니다. ReasonML이 보다 완벽하게 타입 안정성을 제공하지만, [타입스크립트의 방향성 또한 옳습니다.](https://twitter.com/jordwalke/status/1212988231416811520)\n\n하지만 두 언어의 철학이 다른 것에서 오는 차이점도 분명히 존재합니다. 공식 웹사이트에 있는 [타입스크립트와의 차이점](https://rescript-lang.org/docs/manual/latest/introduction#difference-vs-typescript)의 내용을 바탕으로 정리해보겠습니다.\n\n**1. ReasonML은 엄선된 기능만을 제공하기 때문에 사용하기 쉽습니다.**\n\n- 타입스크립트는 다소 복잡하고 익혀야할 것이 많습니다. 왜냐하면 기존 자바스크립트 문법 전체를 포함하면서, 그 이상의 기능을 제공하여 개발자의 생산성을 높이는 것이 목표[^3]이기 때문입니다.\n- ReasonML은 자바스크립트 문법 중, 안전한 지점만 제한적으로 사용하도록 하여 프로그램 전체의 타입 안정성을 획득하는 것이 목표입니다. 엄선된 기능(curated set)만을 제공하기 때문에 상대적으로 문법이 쉽고 간단합니다.\n\n**2. ReasonML은 프로젝트의 타입 커버리지를 올바르게 측정할 수 있습니다.**\n\n- 기존 자바스크립트 프로젝트를 마이그레이션할 때, 타입스크립트를 이용해 타입을 추가하다보면 여러 파일에 파편적으로 타입 힌트를 추가하게 됩니다. 이런 방식으로는 과거와 비교해 얼마만큼 더 안전해졌는지 알기 어렵고, 또한 프로그램 전체의 타입 커버리지를 측정하기도 어렵습니다.\n- ReasonML은 안전한 코드(= 순수한 ReasonML 코드)와 그렇지 않은 코드(= 자바스크립트와 함께 동작하는 코드)가 명확히 구분됩니다. 따라서 파일 단위로 마이그레이션을 하면 점진적으로 타입 안정성을 획득하고 커버리지 또한 측정할 수 있습니다.\n\n**3. ReasonML은 타입이 있는 함수형 프로그래밍 스타일을 권장합니다.**\n\n- if나 가상 디스패치보다 패턴 매칭으로, 클래스보다 순수 데이터와 함수 조합으로 프로그래밍하도록 합니다. 또한 무분별하게 문자열을 사용하기보다는 타입을 통한 적절한 데이터 모델링을 하도록 강제합니다.\n\n## 마치며\n\nReasonML 컴파일러는 제 코드의 타입이 틀린 곳을 자세하고 집요하게 지적해 줍니다. 때문에 처음에는 컴파일러의 검사를 통과시키기가 힘들었습니다. 하지만 그 깐깐한 검사를 통과하면 굉장히 뿌듯하고 마음까지 편안해집니다. 적어도 실행 시점에 예상치 못한 타입 에러는 없을 것이기 때문입니다.\n\n저는 ReasonML의 이런 개발 경험을 **\"똑똑한 컴파일러와 페어 프로그래밍을 하는 것 같다\"**라고 표현합니다. 덕분에 런타임에 브라우저 에러 로그를 보고 실수를 바로잡는 일을 해본 지 정말 오래된 것 같습니다.\n\n현재 그린랩스에서는 크고 작은 여러 프로젝트에서 ReasonML을 사용하고 있습니다. ReasonML을 통해서 타입 시스템이라는 깊고 심오한 분야가 있다는 것을 알게 되었고, 올바른 타입 시스템을 사용해 프로그램을 작성하는 방법에 대해 꾸준히 공부하고 있습니다.\n\n제가 느꼈던 좋은 개발 경험에 대해 나누고 싶었습니다. 제 글이 ReasonML을 시작하는 분이나 자바스크립트에 타입 시스템을 도입하고 싶으신 분들께 작게나마 도움이 된다면 좋겠습니다. 이 글에서 미처 담지 못한 내용과 리액트, 그래프큐엘과 함께 사용할 때의 좋은 점 등은 나중에 주제별로 자세히 다루겠습니다.\n\n<br />\n<br />\n<Author\n  email=\"kimchhickey@gmail.com\"\n  name=\"양성민\"\n  description=\"백엔드 엔지니어\"\n  date=\"2020-12-01\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [https://reasonml.github.io/](https://reasonml.github.io/)\n- [https://rescript-lang.org/docs/manual/latest/introduction](https://rescript-lang.org/docs/manual/latest/introduction)\n- [https://2ality.com/2017/11/about-reasonml.html](https://2ality.com/2017/11/about-reasonml.html)\n- [https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/](https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/)\n- [https://tiny.cloud/blog/tinymce-reasonml/](https://tiny.cloud/blog/tinymce-reasonml/)\n- [https://blog.dubenko.dev/typescript-vs-reason/](https://blog.dubenko.dev/typescript-vs-reason/)\n\n[^1]: 버클스크립트가 2020년 8월 리스크립트로 리브랜딩 하여 활발히 개발되고 있습니다. [(참고)](https://rescript-lang.org/blog/bucklescript-is-rebranding) 혼란을 줄이기 위해서 본문에서는 버클스크립트로 통일하였습니다.\n[^2]: 이 질문은 Jordan Walke가 해커 뉴스에서 작성한 댓글에서 발췌하였습니다. [(링크)](https://news.ycombinator.com/item?id=23174007)\n[^3]: 또한 타입스크립트는 안전(_sound_)하지 않은 타입 시스템 언어입니다. 대신 안전하지 않을 수 있는 동작에 대해서 심도있게 고려하여, 그러한 상황이 발생할 수 있는 시나리오를 문서로 정리해서 제공하고 있습니다. [(참고)](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness)\n","excerpt":"시작하며 ReasonML은 OCaml과 자바스크립트의 특징을 두루 가지고 있는 현대적 프로그래밍 언어입니다. 특히 리액트나 그래프큐엘과 같이 널리 쓰이는 기술과도 잘 맞아서 개발자의 생산성을 많이 올려줍니다.\n\n그린랩스에서는 ReasonML로 풀스택…","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","tags":[{"name":"Reason","slug":"reason"},{"name":"ReasonML","slug":"reason-ml"},{"name":"OCaml","slug":"o-caml"},{"name":"Bucklescript","slug":"bucklescript"},{"name":"ReScript","slug":"re-script"}]},{"slug":"/what-is-polymorphic-variants","title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020년 12월 1일","body":"\n> 이 글은 ReasonML에 대한 약간의 이해가 필요합니다.  \n> ReasonML에 대한 소개는 [여기](/what-is-reason-ml)를,  \n> ReasonML 문법에 대한 소개는 [여기](https://rescript-lang.org/docs/manual/latest/overview)를 참고해주세요.\n\n---\n\nReasonML에서 가장 유용한 기능을 꼽으라면 단연 배리언트와 패턴매칭일 것입니다.\n여기에 더해 ReasonML에는 일반 배리언트보다 조금 특별한 폴리모픽 배리언트라는 것이 있습니다.\n\n폴리모픽 배리언트는 `bs-css` 같은 프로젝트나 바인딩 라이브러리를 다루다 보면 빈번하게 마주하게 됩니다.\n그래서 구체적으로 어떤 개념인지 잘 몰라도 일단 사용하는 것에는 큰 어려움이 없습니다.\n\n그렇지만 실제 동작 원리를 알아두면 더 좋을 것입니다.\n블로그를 작성하는 현시점까지 ReScript 공식 문서에는 폴리모픽 배리언트에 대한 설명이 나와있지 않기에,\n이 글에서는 폴리모픽 배리언트의 개념과 이것이 언제 필요한지에 대해 다루어보겠습니다.\n\n본문의 예시는 Real World OCaml[^1]과 OCaml 공식 문서[^2]를 참고하였으며, ReasonML 버전으로 재작성하였습니다.\n\n## 기본적인 문법\n\n폴리모픽 배리언트는 **타입 선언 없이** 바로 사용할 수 있는 것이 가장 큰 특징입니다.\n\n일반 배리언트와 다른게 반드시 대문자로 시작할 필요가 없지만, 태그에 백틱(`` ` ``)을 붙여주어야 합니다.\n참고로 ReasonML과는 사촌지간인 리스크립트(ReScript)에서는 해시(`#`)를 붙이는 것으로 문법이 바뀌었습니다.\n리스크립트는 최대한 자바스크립트와 비슷한 문법을 지향하는데, 자바스크립트의 문자열 인터폴레이션과 헷깔리기 때문에 바꾸었다고 합니다.\n\n아래는 폴리모픽 배리언트의 예입니다.\n\n```reason\nlet three = `Int(3);\n/* [> `Int(int) ] */\n\nlet four = `Float(4.0);\n/* [> `Float(float) ] */\n\nlet nan = `Not_a_number;\n/* [> `Not_a_number ] */\n\n[three, four, nan];\n/* list( [> `Float(float) | `Int(int) | `Not_a_number ] ) */\n```\n\n보다시피 별도의 타입 선언 없이 쓸 수 있으며, 배리언트의 태그들이 대괄호(`[]`)로 감싸져 있는 것이 특징입니다.\n그리고 리스트에 섞어 쓰면 그 결과에 대응되는 새로운 타입도 추론해 줍니다.\n\n참고로 배열에 대해서는 타입 추론이 되지 않고 컴파일 에러가 발생합니다.\n이는 OCaml🐫 구현의 영향을 받은 것인데, 배열은 성능을 위해 사용되는 자료구조이기 때문인 것으로 추측됩니다.\n\n당연하지만 아래와 같이 태그를 혼용하는 것은 안됩니다.\n\n```reason\nlet five = `Int(\"five\")\n/* [> `Int(string) ] */\n\n[three, four, five]\n\n/*\nThis has type: [> `Int(string) ]\nSomewhere wanted: [> `Float(float) | `Int(int) ]\nTypes for tag `Int are incompatible\n*/\n```\n\n<br />\n\n### 폴리모픽 배리언트의 범위(bounds)\n\n아까부터 자동 추론되는 타입 앞에는 `>` 문자가 보입니다.\n\n```reason\n[three, four];\n/* [> `Float(float) | `Int(int) ] */\n```\n\n이런 식으로요.\n\n`>`로 시작하는 타입의 의미는 다음과 같습니다.\n\n> 열거된 태그들을 포함하기만 하면 기타 다른 태그를 포함해도 됨\n\n위 예시는 \"`Float(float)`와 `Int(int)`를 포함, **그리고** 추가적으로 다른 태그도 포함할 수 있는 타입\"의 폴리모픽 배리언트를 의미합니다.\n이를 폴리모픽 배리언트의 하계(a lower bound)라고 합니다.\n\n반대로 컴파일러가 배리언트의 타입을 `<`로 추론하는 경우가 있습니다.\n아까와는 부등호 방향이 반대입니다.\n눈치채셨겠지만 이를 폴리모픽 배리언트의 상계(an upper bound)라고 합니다.\n`<`로 시작하는 타입의 의미는 다음과 같습니다.\n\n> 열거된 태그들로 선언되거나 **혹은** 그보다 부족하게만 선언되면 문제없음\n\n예시를 들어보겠습니다.\n\n```reason\nlet isPositive = x =>\n  switch (x) {\n  | `Int(i) => i > 0\n  | `Float(f) => f > 0.\n  };\n/* [< `Float(float) | `Int(int) ] => bool */\n```\n\n위 함수의 반환 타입이 `<` 인 이유는, `Float`, `Int` 이외의 태그가 들어가면 함수 내부의 스위치 문에서 대응이 안되기 때문입니다.\n이는 안전하지 못한 코드를 의미하므로 컴파일러가 통과시키지 않습니다.\n\n참고로 상계와 하계가 동일한 경우에는 `<`, `>` 표기가 없어집니다.\n\n```reason\nlet exact = Belt.List.keep([three, four], isPositive);\n/* Belt.List.t( [ `Float(float) | `Int(int) ] ) */\n```\n\n상계와 하계가 다른 경우도 만들어낼 수 있습니다.\n\n```reason\nlet isPositive = x =>\n  switch (x) {\n  | `Int(i) => Ok(i > 0)\n  | `Float(f) => Ok(f > 0.)\n  | `Not_a_number => Error(\"not a number\")\n  };\n\nlet exact =\n  Belt.List.keep([three, four], x => {\n    switch (isPositive(x)) {\n    | Error(_) => false\n    | Ok(v) => v\n    }\n  });\n/* Belt.List.t( [< `Float(float) | `Int(int) | `Not_a_number > `Float `Int ] )\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~   */\n```\n\n추론된 타입이 좀 복잡해 보이지만 천천히 살펴보면 그리 어렵지 않습니다.\n이 타입은 Float, Int, NaN 이외의 것을 받을 수는 없지만, 적어도 Float와 Int는 포함해야 함을 의미합니다.\n\n## 폴리모픽 배리언트가 필요한 순간\n\n실전에서 폴리모픽 배리언트가 일반 배리언트보다 유용한 사례를 알아보겠습니다.\n\n색상을 다루어야 하는 상황을 가정해 봅시다.\n\n```reason\n/* 익숙한 일반 배리언트를 사용하여 타이핑 */\ntype color =\n  | RGB(int, int, int) /* 6x6x6 color cube */\n  | Gray(int); /* 24 grayscale */\n\nlet colorToInt = c =>\n  switch (c) {\n  | RGB(r, g, b) => 16 + b + g * 6 + r * 36\n  | Gray(i) => 232 + i\n  };\n```\n\n색상은 RGB 또는 흑백으로 표현할 수 있고, 이를 정수로 변환할 수 있는 로직입니다.\n여기서 요구사항이 바뀌어 투명도를 포함한 색깔을 추가로 다루어야 한다고 해봅시다.\n\n```reason\ntype extColor =\n  | RGB(int, int, int)\n  | Gray(int)\n  | RGBA(int, int, int, int); /* 🆕 6x6x6x6 color space */\n```\n\n기존 로직에 영향을 주지 않기 위해 `color` 타입을 수정하지 않고 새롭게 선언했습니다.\n여기까지는 좋습니다.\n문제는 아까와 비슷하게 `extColorToInt`라는 함수를 작성하는 순간입니다.\n단순한 타입이 아니라 로직의 구현이기 때문에, 기존 `colorToInt` 로직을 재사용하고자 합니다.\n\n```reason\nlet extColorToInt = c =>\n  switch (c) {\n  | RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | (RGB(_) | Gray(_)) as c' => colorToInt(c')\n  };\n\n/*\nThis has type: extColor\nSomewhere wanted: color\n*/\n```\n\n하지만 위와 같이 작성한 코드는 동작하지 않습니다.\n\n사람이 보기에는 문제없는 코드 같지만, 컴파일러가 보기에는 `extColor`와 `color`가 서로 전혀 다른 타입이기 때문입니다.\n에러의 의미도 그것입니다.\n\n하지만 우리가 원하는 것은 저 여지껏 사용된 태그가 적절히 재사용되는 것입니다.\n\n### 폴리모픽 배리언트로\n\n단순히 일반 배리언트를 폴리모픽 배리언트로 바꿔보겠습니다.\n\n1. 기존 코드에서 `type` 으로 선언된 부분은 날려버리고\n2. 패턴매칭에서 백틱(`)만 찍어주면 됩니다.\n\n```reason\nlet colorToInt = c =>\n  switch (c) {\n  | `RGB(r, g, b) => 16 + b + g * 6 + r * 36\n  | `Gray(i) => 232 + i\n  };\n/* [< `Gray(int) | `RGB(int,int,int) ] => int */\n\nlet extColorToInt = c =>\n  switch (c) {\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | (`RGB(_) | `Gray(_)) as c' => colorToInt(c')\n  };\n/* [< `Gray(int) | `RGB(int,int,int) | `RGBA(int,int,int,int) ] => int */\n```\n\n이번에는 문제없이 `extColorToInt`가 컴파일됐습니다.\n그리고 컴파일이 되었으니 문제가 없는 것은 분명합니다.\n원했던 대로 `c'`의 타입이 절절히 축소되어(extColor -> color) `colorToInt`의 인자로 전달되었습니다.\n\n그런데 매칭 구문이 조금 지저분해 보이는데, 차라리 catch-all로 받아버리면 어떨까요?\n\n```reason\nlet extColorToInt = c =>\n  switch (c) {\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | c' => colorToInt(c')\n  };\n\n/*\nThis has type: [> `RGBA(int, int, int, int) ]\nSomewhere wanted: [< `Gray(int) | `RGB(int, int, int) ]\nThe second variant type does not allow tag(s) `RGBA\n*/\n```\n\n아쉽게도 컴파일은 되지 않습니다.\n에러가 친절히 알려주다시피 `c'`의 타입이 굉장히 느슨하게 추론되기 때문입니다.\n\n그 이유는 어렵지 않게 추측할 수 있습니다.\n타입을 별도로 선언하지 않았기 떄문에 `c'`는 어떤 태그도 될 수 있는 반면, `colorToInt`는 상계가 있기 때문입니다.\n\n<br />\n\n#### ⚠️ Catch-all 매칭 ⚠️\n\n앞서 `isPositive`에서 보았듯이, 함수 본문의 패턴매칭은 배리언트의 상계에 영향을 미칩니다.\n그렇지만 패턴매칭에 catch-all을 넣는 순간 반대로 아래와 같이 하계만 결정되고 위로는 제약이 풀려버립니다.\n\n```reason\nlet isPositivePermissive = x =>\n  switch (x) {\n  | `Int(i) => Ok(i > 0)\n  | `Float(f) => Ok(f > 0.)\n  | _ => Error(\"Unknown number type\")\n  };\n/* [> `Float(float) | `Int(int) ] => ... */\n\nisPositivePermissive(`Int(0));\n/* Ok(false) */\nisPositivePermissive(`Ratio(3, 4));\n/* Error(\"Unknown number type\") */\n```\n\nCatch-all 케이스는 일반 배리언트에서도 에러를 일으키지 쉽지만, 폴리모픽 배리언트에서는 더 심합니다.\n왜냐하면 위 예시처럼 코드가 작성된 경우 실수로 오타를 입력해도 컴파일러가 어떤 불평도 하지 않기 때문입니다.\n\n```reason\nisPositivePermissive(`Floot(3.05));\n/* Error(\"Unknown number type\") */\n```\n\n만약 일반 배리언트였다면 이러한 문제는 없었을 것입니다.\n그러니 폴리모픽 배리언트를 쓸 때에는 catch-all 사용에 주의해야 합니다.\n\n## 일반 배리언트 vs. 폴리모픽 배리언트\n\n지금까지의 설명으로는 폴리모픽 배리언트가 일반 배리언트의 상위 호환처럼 느껴집니다.\n약간만 주의하면 일반처럼 쓸 수도 있고, 더 유연하면서 간결하고요.\n\n그렇지만 대부분의 설계에서는 **일반 배리언트가** 더 좋은 선택이라고 합니다.\n폴리모픽 배리언트는 그 유연함의 대가로 아래와 같은 단점을 가집니다.\n\n- 더 높은 복잡도\n  - 동작 방식이 일반 배리언트보다 복잡하기 때문에, 이것을 마구 쓰다가 컴파일이 잘 안되는 상황이 발생했을 때 컴파일러가 뱉어내는 에러메세지가 굉장히 난해해지곤 합니다.\n    일반적으로 **값 수준에서 구현을 단순하게 할수록 타입 수준에서 구현 복잡도가 증가**하는 경향이 있습니다.\n- 더 어려운 디버깅\n  - 타입 시스템이 유연할수록 프로그램의 버그를 찾기 어렵다고 합니다.\n    폴리모픽 배리 역시 타입 안전하긴 하지만, 그 유연함 때문에 에러를 찾기가 좀 더 어려워지는 경향이 있습니다.\n- 낮은 성능\n  - 크게 심각한 것은 아니지만 폴리모픽 배리언트는 일반보다 구현이 좀 복잡합니다.\n    또한 컴파일러가 패턴매칭을 일반 배리언트만큼 효율적으로 처리하는 코드를 생성할 수 없습니다.\n\n이런 단점에도 폴리모픽 배리언트는 여전히 매우 강력하고 유용합니다.\n장점을 다시 정리해보자면,\n\n- 재사용성\n  - 생성자가 매우 다양한 경우에 유용합니다.\n    예를 들어 문자열 인코딩을 종류별로 다뤄야 한다고 했을 때, 이를 미리 선언하지 않고 사용할 수 있어 편리합니다.\n    ```reason\n    type encoding = [ |`base64 | `ascii | `latin1 | `utf8 | `hex ... ]\n    /* 수 많은 인코딩을 일일히 나열하고 싶지 않습니다. 😕 */\n    ```\n- 디커플링\n  - 명시적인 타입 선언을 해야 한다면 이를 사용하는 모든 곳에서 의존성을 갖게 되므로 모듈 관리 비용이 들어갑니다.\n    하지만 타입 선언이 필요치 않기 때문에 태그에 대한 약속은 공유하되 완전히 디커플링된 설계를 할 수 있습니다.\n- 확장성\n\n  - 배리언트가 추후 확장되도록 설계할 수 있습니다. 위의 `extColorToInt`가 그 간단한 예입니다.\n    현실적인 예는 [graphql-ppx](http://graphql-ppx.com/)에서도 찾아볼 수 있습니다.\n    graphql-ppx는 스키마의 enum에 대해 폴리모픽 배리언트를 자동 생성하는데, 생성되는 타입은 암묵적으로 `` `FutureAddedValue(_)``라는 태그를 포함하게 됩니다.\n\n    ```reason\n    type t_someQuery_enumField = [\n      | `FutureAddedValue(string)\n      | `FIRST\n      | `SECOND\n    ];\n    ```\n\n    따라서 클라이언트에서는 위와 같이 `` `FutureAddedValue`` 매칭 코드 작성이 강제되는데, 덕분에 서버 스키마가 조용히 변경되어 새로운 enum 값이 전달되더라도 클라이언트 런타임에러가 발생하지 않도록 해줍니다.\n\n- 간결함\n  - 생성자가 전역 네임스페이스에 있기 때문에 별도로 모듈을 open할 필요가 없습니다.\n    또, 별로 중요하지 않은 곳에서 적당히 태그를 만들어 사용하고 버리기에 편리합니다.\n\n## 맺음말\n\n지금까지 살펴본 내용만으로도 폴리모픽 배리언트를 사용하는 것에는 큰 지장이 없습니다.\n하지만 타입의 상계와 하계가 어떻게 결정되는지 그 동작 방식에 대해 이해하는 것도 좋을 것입니다.\n다음 글에서는 폴리모픽 타입의 추론 과정(unification)이 어떻게 동작하는지 다루어보겠습니다.\n\n<br />\n<br />\n<Author\n  email=\"hw.nam@greenlabs.co.kr\"\n  name=\"남현우\"\n  description=\"소프트웨어 엔지니어\"\n  date=\"2020-12-01\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [2ality - ReasonML: polymorphic variant types](https://2ality.com/2018/01/polymorphic-variants-reasonml.html)\n- [OCaml Book, Hongbo Zhang](https://github.com/bobzhang/ocaml-book/blob/master/lang/features.org#polymorphic-variants)\n\n[^1]: [Real World OCaml](https://dev.realworldocaml.org/variants.html)\n[^2]: [Polymorphic Variants](https://ocaml.org/manual/lablexamples.html#s%3Apolymorphic-variants)\n","excerpt":"이 글은 ReasonML에 대한 약간의 이해가 필요합니다. ReasonML에 대한 소개는 여기를,\nReasonML 문법에 대한 소개는 여기를 참고해주세요.\n\nReasonML에서 가장 유용한 기능을 꼽으라면 단연 배리언트와 패턴매칭일 것입니다…","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","tags":[{"name":"Polymorphic Variants","slug":"polymorphic-variants"},{"name":"ReasonML","slug":"reason-ml"}]}]},"allMdx":{"nodes":[{"frontmatter":{"date":"2022-10-30T00:00:00.000Z","slug":"/rescript-compiler-jsx-ppx","author":"문운기","email":"woonki.moon@gmail.com"}},{"frontmatter":{"date":"2022-10-26T00:00:00.000Z","slug":"/feature-flags-1","author":"김정우, 양정윤, 이낙원","email":"kjw0323@gmail.com"}},{"frontmatter":{"date":"2022-08-25T00:00:00.000Z","slug":"/pair-programming","author":"조효정","email":"hyojeongcho1019@gmail.com"}},{"frontmatter":{"date":"2022-07-27T00:00:00.000Z","slug":"/lazy-sequence-from-scratch","author":"남영환","email":"ssisksl77@gmail.com"}},{"frontmatter":{"date":"2022-07-21T00:00:00.000Z","slug":"/with-greenlabs-for-1yr","author":"차민철","email":"mccha0407@gmail.com"}},{"frontmatter":{"date":"2022-06-17T00:00:00.000Z","slug":"/is-clojure-hard-to-read","author":"박연오","email":"bakyeono@gmail.com"}},{"frontmatter":{"date":"2022-01-11T00:00:00.000Z","slug":"/greenlabs-clojurians-2022","author":"남현우","email":"hw.nam@greenlabs.co.kr"}},{"frontmatter":{"date":"2021-11-22T00:00:00.000Z","slug":"/the-macro","author":"남영환","email":"ssisksl77@gmail.com"}},{"frontmatter":{"date":"2021-10-29T00:00:00.000Z","slug":"/rescript-bootcamp","author":"김효은","email":"hyosaritech@gmail.com"}},{"frontmatter":{"date":"2021-09-24T00:00:00.000Z","slug":"/programmers-naming","author":"박연오","email":"bakyeono@gmail.com"}},{"frontmatter":{"date":"2021-09-17T00:00:00.000Z","slug":"/introduce-a-ring","author":"김동욱","email":"dw.kim@greenlabs.co.kr"}},{"frontmatter":{"date":"2021-09-13T00:00:00.000Z","slug":"/clojure-bootcamp","author":"권정인","email":"jungin.kwon1@gmail.com"}},{"frontmatter":{"date":"2021-08-31T00:00:00.000Z","slug":"/algebraic-data-type","author":"문운기","email":"woonki.moon@gmail.com"}},{"frontmatter":{"date":"2021-06-01T00:00:00.000Z","slug":"/start-your-clojure-project-now-2","author":"김상현","email":"tlonist.sang@gmail.com"}},{"frontmatter":{"date":"2021-05-30T00:00:00.000Z","slug":"/start-your-clojure-project-now-1","author":"김상현","email":"tlonist.sang@gmail.com"}},{"frontmatter":{"date":"2021-04-27T00:00:00.000Z","slug":"/apply-and-compose","author":"김춘구","email":"ck.kim@greenlabs.co.kr"}},{"frontmatter":{"date":"2021-01-29T00:00:00.000Z","slug":"/why-rescript","author":"양성민","email":"kimchhickey@gmail.com"}},{"frontmatter":{"date":"2020-12-21T00:00:00.000Z","slug":"/reasonml-ways-with-types","author":"김상현","email":"tlonist.sang@gmail.com"}},{"frontmatter":{"date":"2020-12-15T00:00:00.000Z","slug":"/reason-ml-the-good-parts","author":"윤정식","email":"yousleepwhen@gmail.com"}},{"frontmatter":{"date":"2020-12-01T00:00:00.000Z","slug":"/what-is-reason-ml","author":"양성민","email":"kimchhickey@gmail.com"}},{"frontmatter":{"date":"2020-12-01T00:00:00.000Z","slug":"/what-is-polymorphic-variants","author":"남현우","email":"hw.nam@greenlabs.co.kr"}}]}},"pageContext":{"formatString":"YYYY년 M월 D일"}},"staticQueryHashes":["3090400250","318001574"]}