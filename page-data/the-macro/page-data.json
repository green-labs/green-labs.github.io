{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-the-macro-index-mdx","path":"/the-macro","result":{"data":{"post":{"slug":"/the-macro","title":"클로저 매크로에 대해 알아보자","date":"2021년 11월 22일","tags":[{"name":"Clojure","slug":"clojure"},{"name":"Macro","slug":"macro"},{"name":"Lisp","slug":"lisp"}],"description":"그만 알아보자","canonicalUrl":null,"body":"\n## 매크로에 대한 기억\n\n어린 시절 즐기던 게임에서는 레벨 업을 위해 지루한 반복 사냥을 해야 할 때가 많았습니다. 제 친구 중 몇 명은 매크로 프로그램을 이용해 반복 사냥을 컴퓨터가 대신하게 했습니다. 매크로를 이용하면 캐릭터가 어떤 방향으로 공격을 하게 하거나, 몇 분에 한 번씩 아이템을 사용하도록 하는 등 일련의 작업을 자동으로 실행할 수 있었습니다. 이처럼, '매크로'란 미리 정해놓은 명령을 자동으로 실행하여 단순 반복 작업을 줄이는 기능입니다. 그런데 프로그래밍에서도 따분한 반복 작업을 해야 하는 경우가 있습니다. 프로그래밍 언어에는 일정한 문법과 규칙이 있기 때문입니다. 예를 들어, 자바에서 새 객체를 만들려면 다음과 같은 절차를 반드시 따라야 합니다.\n\n1. `class` 키워드로 클래스를 정의한다.\n2. `new` 키워드로 객체를 생성한다.\n\n이 두 문장은 뒤바뀔 수 없습니다. 둘 중 하나의 행위만으로는 객체를 만들 수 없죠. 프로그래밍 언어의 문법의 틀을 당연시한다면 생각은 그와 유사한 방식으로만 상상할 수밖에 없다고 생각합니다. 클로저(Clojure)의 매크로는 주어진 규칙을 허무는 데 도움을 줄 것입니다.\n\n## 프로그래밍 언어의 매크로\n\n### C 언어의 매크로\n\n클로저의 매크로에 관해 알아보기 전에, 더 많은 분들이 알고 계실 C 언어의 매크로를 잠시 살펴봅시다.\n\n```c\n#include <stdio.h>\n\n#define CUBE_MACRO(n) n*n*n\n\nint main()\n{\n  printf(\"%d\", CUBE_MACRO(1+2));  // 1+2*1+2*1+2 -> 7\n  return 0;\n}\n```\n\n위 코드에서는 `#define` 전처리 명령으로 n을 세제곱하는 `CUBE_MACRO`라는 매크로 함수를 정의했습니다. `CUBE_MACRO` 매크로는 일반 함수를 호출하는 것처럼 사용할 수 있습니다. 한편, 아래의 코드에서는 `CUBE_MACRO` 매크로의 `n*n*n`과 동일한 식을 일반 함수 `cube_func()`로 정의했습니다.\n\n```c\n#include <stdio.h>\n\nint cube_func(int n)\n{\n  return n*n*n;\n}\n\nint main()\n{\n  printf(\"%d\", cube_func(1+2));  // 3*3*3 -> 27\n  return 0;\n}\n```\n\n이 두 코드는 동일한 일을 하는 것 같지만, 결과 값이 다릅니다.[[2]](#ref-2)[[3]](#ref-3) `CUBE_MACRO`는 `7`이 출력되며, `cube_func`는 `27`이 출력되었습니다. C언어 매크로는 기호(여기서는 `1+2`)를 다른 기호로 치환한 뒤, 코드를 컴파일하고 실행합니다. 함수는 이미 코드가 컴파일 된 상태에서, 기호를 값으로 평가한 후에(`2+1 -> 3`) 실행합니다. 컴파일 전에는 `1+2`라는 코드가 `3`이라는 값으로 평가되지 않으므로, `n*n*n`은 `3*3*3`이 아니라 `1+2*1+2*1+2`로 치환됩니다. 따라서 매크로 함수와 일반 함수의 실행 결과에 차이가 생기는 것입니다. C 언어의 매크로는 이처럼 코드 자체를 변경하며, 이를 이용하면 제한적으로나마 기존 언어에서 정한 규칙의 선을 넘을 수 있습니다.\n\n## 클로저 매크로\n\n클로저 매크로도 C언어 매크로와 비슷하지만, 단순히 문자열 치환이 아닙니다. 코드를 프로그래밍하는 것에 가깝습니다. 코드를 치환한다는 점에서 클로저의 매크로는 C언어 매크로와 비슷하지만, 리스프 계열 언어의 특징인 동형성으로 특별해집니다. [[4]](#ref-4)[[5]](#ref-5)[[6]](#ref-6)\n\n### 동형성\n\n클로저는 리스프 계열 언어입니다. 리스프(LISP)라는 이름은 \"리스트 처리(LISt Processing)\"에서 딴 것입니다. 그 이름에서도 짐작할 수 있듯이, 연결 리스트(linked list)가 리스프의 핵심 자료구조입니다. 심지어 코드 자체도 리스트로 구성할 정도이죠. 그래서 클로저에서는 코드가 리스트 자료구조와 같은 방식으로 표현·저장됩니다. 코드를 변경하는 것이 리스트를 변경하는 것과 똑같은 일입니다. 클로저에서는 소괄호 안에 요소들을 나열하는 방식으로 리스트를 표기합니다. 다음 두 코드는 각각 자바와 클로저로 리스트를 표현한 것입니다.\n\n```java\nList.of(1,2,3,4)\n```\n\n```clojure\n(list 1 2 3 4)  ;; (1 2 3 4)\n```\n\n클로저에서는 식을 계산하거나 함수를 호출할 때 코드를 리스트로 작성합니다.\n\n```clojure\n(+ 1 2)\n(* 2 3)\n(/ 3 4)\n\n(println \"Hello, Clojure\")\n```\n\n함수 정의도 마찬가지입니다.\n\n```clojure\n(defn hello-world [name]\n  (println (str \"Hello, \" name)))\n\n(defn add1 [number]\n  (+ 1 number))\n```\n\n코드가 리스트 자료구조로 구성되어 있으므로, 코드를 다른 리스트를 조작할 때와 똑같이 조작할 수 있습니다.\n\n```clojure\n(count (list * 3 3 3)) ;; 4\n(first (list * 3 3 3)) ;; *\n(rest (list * 3 3 3))  ;; (3 3 3)\n(concat (list * 3 3 3) '(5)) ;; (3 3 3 5)\n```\n\n클로저 코드는 소괄호를 적극적으로 활용하여 문법을 최소화하였습니다. 일반적으로 리스트의 첫 번째 요소를 연산자(함수)로, 나머지 요소들을 피연산자(인자)로 취급합니다. 동형성은 매크로를 사용할 때 아주 강력한 힘이 됩니다. 우리는 '코드를 생산하는 코드'를 만들 능력을 얻은 것입니다.\n\n## 클로저 매크로로 문법을 뛰어넘기\n\n> 비아웹(Viaweb) 편집기의 전체 소스 코드 중 약 20%에서 25% 정도가 매크로였다. (중략) 그 프로그램에 포함된 모든 매크로는 꼭 필요해서 넣은 것이다. 이는 이 프로그램 중 최소 20%에서 25%가량의 코드는 다른 언어로는 하기 어려운 일을 하고 있음을 의미한다.\n>\n> - 평균을 넘어서기, 폴 그레이엄(Paul Graham)\n\n다른 언어에서는 구현하기가 몹시 까다로운 문제들을, 클로저의 매크로를 이용하면 평상시의 코딩과 다름없이 간단히 처리할 수 있는 경우가 많습니다. 몇 가지 사례를 소개해 드리겠습니다. 자세한 문법 설명은 생략하겠습니다. 그저 이런 것이 가능하다는 것만 즐겨주시면 좋겠습니다.\n\n### 매크로 맛보기\n\nC언어 매크로 소개 예시와 비슷한 일을 하는 코드를 소개합니다.\n\n```clojure\n;; 매크로 정의\n(defmacro cube-macro [n]\n  (list '* n n n))\n\n(cube-macro 3) ;; 27\n\n;; 함수 정의\n(defn cube-fn [n]\n  (* n n n))\n\n(cube-fn 3) ;; 27\n```\n\nC언어 매크로와는 다르게 함수 정의와 이질감이 없습니다. 그리고 결괏값이 함수 호출과 동일하게 나오는 것도 다릅니다.\n\n### 예제 1 - anaphoric macro\n\nanaphoric은 '앞서 나온 어구'를 지칭할 때 사용합니다. 대명사라고 이해하면 쉬울 것 같습니다. [[9]](#ref-9) if문에서 검사한 값을 그대로 사용하고 싶지는 않으신가요? 자바를 예로 들면 `null`을 관리하기 위해 종종 아래와 같은 코드를 만들 것입니다.\n\n```java\nSomeObject someObject = someMethod(arg1, arg2);\nif (someObject != null) {\n  doSomeThing(someObject);\n}\n// 또는\nOptional<SomeObject> someObjectOption = Optional.ofNullable(someMethod(arg1, arg2));\nif (!someObjectOption.isEmpty()) {\n  doSomething(someObjectOption.get());\n}\n// 또는\nOptional<SomeObject> someObjectOption = Optional.ofNullable(someMethod(arg1, arg2));\nsomeObjectOption.ifPresent(someObject -> {\n  doSomething(someObject);\n}\n```\n\n그렇다면 혹시 이런 것은 가능할까요? `someMethod(arg1, arg2)` 의 결괏값이 `null`이 아니라면 `someMethod(arg1, arg2)`의 리턴문을 `it`이라는 키워드로 직접 사용할 수는 없을까요? 가능한지는 차치하고 새로운 문법을 상상해봅시다. `ifexists`는 값이 `null`이거나 `false`가 아니라면 중괄호 안의 statement를 수행한다고 상상해보죠.\n\n```java\nifexists (someMethod(arg1, arg2)) {\n  doSomething(it);  // it을 someMethod의 리턴값에 바인딩이 가능할까?\n}\n```\n\n이런 코드를 자바에서 만들 수 있을까요? 아뇨, 우리는 이런 코드를 만들 수 없습니다. 예약어들은 정해져있습니다. 우리가 마음대로 추가할 수 없지요. `it`처럼 정의되지도 않은 이름을 바로 쓸 수도 없습니다. 누군가는 '당연히 정의부터 해야지. 순서라는 것이 있잖아.' 라고 생각할지도 모르죠. 하지만 클로저에서는 가능합니다. `aif`, `aand` 라는 매크로를 만들어 보겠습니다.(코드를 이해하실 필요는 없습니다. 가능하다는 것만 느껴주시면 좋겠습니다.)\n\n```clojure\n(defmacro aif [test then else]\n  `(let [~'it ~test]\n     (if `'it ~then ~else)))\n\n(defmacro aand [& body]\n  (cond (nil? body) true\n        (nil? (next body)) (first body)\n        :else `(aif ~(first body)\n                     (aand ~@(rest body))\n                     false)))\n\n(aif 1\n  (inc it)\n  \"Nope\")\n;; 2\n\n(aand 1\n  (inc it)\n  (* 100 it)\n  (= 200 it))\n;; true\n\n(aand 1\n  (inc it)\n  (* 2 it)\n  (= 5 it))\n;; false\n```\n\n`aif`는 첫번째 인자가 `false`, `nil`(자바의 `null`과 비슷)이 아닌경우 `it`에 바인딩되어 사용할 수 있습니다. `aand`는 더 나아가서 함수들을 체이닝해서 수행할 수 있지요. `it`은 이전 함수의 리턴값으로 체이닝됩니다.\n\n### 예제 2 - for-loop문 만들기\n\nClojure에는 for-loop가 없습니다. 하지만 사용하고 싶다면 만들면 됩니다.[[10]](#ref-10)\n\n```clojure\n(defmacro for-loop [[sym init check change :as params] & steps]\n `(loop [~sym ~init value# nil]\n    (if ~check\n      (let [new-value# (do ~@steps)]\n        (recur ~change new-value#))\n      value#)))\n\n(for-loop [i 0 (< i 10) (inc i)]\n  (println i))\n```\n\n마치 새로운 문법이 추가된 것처럼 보이네요!\n\n- 리스트의 첫번째 요소 이름을 두번째 요소의 값으로 정의\n- 리스트의 3번째 요소의 함수가 true 일때까지 재귀를 돈다.\n- 리스트의 4번째 요소는 첫번째 요소에 적용한 값으로 재귀호출한다.\n\n이런 규칙을 단 6줄로 만들 수 있습니다.\n\n### 예제 3 - 간단한 패턴매칭 만들기\n\n위 예제는 매크로가 할 수 있는 일을 보여드리긴 했지만, 너무 작은 변화이기에 쓸모를 못 느낄 수도 있으신 분들을 위한 소개입니다. 클로저는 기본적으로 패턴매칭기능이 없습니다. 하지만 패턴매칭도 필요하면 만들 수 있습니다. 아래의 코드는 다음에 우리가 만들어볼 `my-match`를 사용하는 예시입니다.[[11]](#ref-11)[[12]](#ref-12)[[14]](#ref-14)\n\n```clojure\n(doseq [n (range 1 101)]\n  (println\n   (my-match [(mod n 3) (mod n 5)]\n             [0 0] (str \"FizzBuzz\")\n             [0 _] (str \"Fizz\")\n             [_ 0] (str \"Buzz\")\n             :else n)))\n;; 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ,,,\n```\n\n위 코드는 간단한 FizzBuzz 문제를 우리가 만들 `my-match`를 사용하여 푼 모습입니다. 3의 배수이면 Fizz를 5의 배수이면 Buzz를 3의 배수이며 5의 배수는 FizzBuzz를 출력합니다. 그리고 아무런 배수가 아니면 해당 숫자를 출력합니다. 여기서 특이한 점은 `_` 입니다. 이 값은 하스켈 패턴매칭의 와일드카드처럼 어떤 값이 와도 상관없도록 만듭니다.[[13]](#ref-13) 그리고 심볼 바인딩도 가능하도록 할 것입니다. 아래 예제를 소개합니다.\n\n```clojure\n(doseq [n (range 1 101)]\n  (println\n   (my-match [(mod n 3) (mod n 5)]\n             [0 0] (str \"FizzBuzz with n=\" n)\n             [0 a] (str \"Fizz with a=\" a \", n=\" n)\n             [b 0] (str \"Buzz with b=\" b \", n=\" n)\n             :else n)))\n;; 1\n;; 2\n;; Fizz with a=3, n=3\n;; 4\n;; Buzz with b=2, n=5\n;; Fizz with a=1, n=6 ...\n```\n\n같은 FizzBuzz 문제이지만 이번에는 와일드카드 대신 심볼을 바인딩하였습니다. 각 심볼에 해당하는 값이 바인딩 됩니다. `n`이 3의 배수일 때, 5의 mod 값을 `a`에 바인딩하여 사용할 수 있게 됩니다.\n\n이를 구현한 코드는 아래와 같습니다. (굳이 이해하실 필요는 없습니다. 몇 개의 함수와 매크로로 매턴매칭이 가능하다는 것을 느끼시면 좋겠습니다.)\n\n```clojure\n;; https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8\n(ns pattern-match.diy)\n\n(defn process-vars\n  [vars]\n  (letfn [(process-var [var]\n            (if-not (symbol? var)\n              (gensym \"ocr-\")\n              var))]\n    (vec (map process-var vars))))\n\n(defn make-default-match [vars cs]\n  (let [cs (partition 2 cs)\n        [p a] (last cs) ;; 심볼의 경우 p를 a에 바인딩하는 기능 추가 필요.\n        last-match (vec (repeat (count vars) '_))]\n    (if (= p :else)\n        (conj (vec (butlast cs)) [last-match a])\n        (throw (RuntimeException. \"last match must be :else\")))))\n\n(defn make-pattern-let-binding\n  \"let 바인딩을 위한 자료구조 생성\"\n  [vs vars]\n  (interleave vs vars))\n\n(defn make-cond\n  \"cond predicate을 만들기 위한 비교문\"\n  [vs cls]\n  (map (fn [v c]\n         `(= ~v ~c)) vs cls))\n\n(def backtrack-exception (Exception. \"BackTrack!\"))\n\n(defn catch-error\n  \"예외를 잡는 자료구조 추가\"\n  [& body]\n  `(catch Exception e#\n     (if (identical? e# ~'backtrack-exception)\n       (do\n         ~@body)\n       (throw e#))))\n\n(defn compile-rec\n  \"재귀적으로 try문 안에 있는 비교문을 생성.\"\n  [cnds return]\n  (let [cnd (first cnds)\n        [v c] (vec (rest cnd))] ;; c가 심볼인 경우 v를 바인딩하도록 해야함.\n    (if (seq cnd)\n      (cond\n        (symbol? c)\n        `(let [~c ~v] (do ~(compile-rec (rest cnds) return)))\n\n        (= '_ c)\n        `(do ~(compile-rec (rest cnds) return))\n\n        :else\n        `(do (cond ~cnd ~(compile-rec (rest cnds) return)\n                   :else ~'(throw backtrack-exception))))\n      return)))\n\n(defn match-compile\n  [conds+return]\n  (let [[cnds return] (first conds+return)\n        cnd (first cnds)\n        [v c] (vec (rest cnd))] ;; c가 심볼인 경우 v를 바인딩하도록 해야함.\n    (if (seq cnd)\n      (cond\n        (symbol? c)\n        `(let [~c ~v]\n           (try ~(compile-rec (rest cnds) return)\n             ~(catch-error (match-compile (rest conds+return)))))\n\n        (= '_ c)\n        `(try ~(compile-rec (rest cnds) return)\n           ~(catch-error (match-compile (rest conds+return))))\n\n        :else\n        `(try (cond ~cnd ~(compile-rec (rest cnds) return)\n                    :else ~'(throw backtrack-exception))\n           ~(catch-error (match-compile (rest conds+return)))))\n      return)))\n\n(defmacro my-match\n  [vars & clauses]\n  (let [vs (process-vars vars)\n        cs (make-default-match vars clauses)\n        pattern-let-binding (vec (make-pattern-let-binding vs vars))\n        conds (map (fn [c] [(make-cond vs (first c)) (second c)]) cs)]\n    `(let ~pattern-let-binding\n       ~(match-compile conds))))\n```\n\n기존 함수 정의 및 호출과 동일한 형태의 코드임을 알 수 있습니다. 생성하는 결괏값이 소스 코드인 것만 다릅니다.\n\n만약에 여러분이 사용하는 언어에서 패턴매칭이 없을 때, 여러분은 임의로 이 기능을 추가할 수 있으신가요 아니면 새로운 버전이 나오기를 기다리실 수밖에 없으신가요? 리스프의 매크로라면 여러분이 원하는 것을 무엇이든 손쉽게 만들 수 있습니다. 여러분은 문법에 구애받지 않고 작성할 힘을 갖게 됩니다. [[7]](#ref-7)[[8]](#ref-8)\n\n언어가 여러분을 제약하지 않도록 하세요. 여러분이 언어를 제약하세요.\n\n## 참고문헌\n\n1. 언어는 어떻게 생각하는 방식을 형성하는가\n   - [1] : [how language shapes the way we think](https://www.ted.com/talks/lera_boroditsky_how_language_shapes_the_way_we_think) <a name=\"ref-1\"/>\n2. C 언어 매크로\n   - [2] : [https://www.geeksforgeeks.org/macros-vs-functions/](https://www.geeksforgeeks.org/macros-vs-functions/) <a name=\"ref-2\" />\n   - [3] : [https://stackoverflow.com/questions/9104568/macro-vs-function-in-c](https://stackoverflow.com/questions/9104568/macro-vs-function-in-c) <a name=\"ref-3\" />\n3. 리스프의 이상한 문법\n   - [4] : [http://www.paulgraham.com/weird.html](http://www.paulgraham.com/weird.html) <a name=\"ref-4\" />\n   - [5] : [https://www.defmacro.org/ramblings/lisp.html](https://www.defmacro.org/ramblings/lisp.html) <a name=\"ref-5\" />\n   - [6] : [https://helloworld.kurly.com/blog/y-combinator/](https://helloworld.kurly.com/blog/y-combinator/) <a name=\"ref-6\" />\n4. 리스프 매크로에 대한 논의\n   - [7] : [http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html](http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html) <a name=\"ref-7\" />\n   - [8] : [https://arxiv.org/pdf/1608.02621.pdf](https://arxiv.org/pdf/1608.02621.pdf) <a name=\"ref-8\" />\n5. anaphoric macro\n   - [9] : [onlisp p.189](http://www.paulgraham.com/onlisptext.html) <a name=\"ref-9\" />\n6. for-loop\n   - [https://stackoverflow.com/questions/9981943/how-to-implement-a-for-loop-in-clojure](https://stackoverflow.com/questions/9981943/how-to-implement-a-for-loop-in-clojure) <a name=\"ref-10\" />\n7. 패턴매칭\n   - 패턴매칭 알고리즘 소개 : [https://www.ccs.neu.edu/~types/resources/a-fpca-1985.pdf](https://www.ccs.neu.edu/~types/resources/a-fpca-1985.pdf) <a name=\"ref-11\" />\n   - clojure core.match 라이브러리 : [https://github.com/clojure/core.match](https://github.com/clojure/core.match) <a name=\"ref-12\" />\n   - 하스켈 wildcard 설명 : [https://www.haskell.org/tutorial/patterns.html](https://www.haskell.org/tutorial/patterns.html) <a name=\"ref-13\" />\n   - 직접 구현한 패턴매칭 소스코드 링크 : [https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8](https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8) <a name=\"ref-14\" />\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"ssisksl77@gmail.com\"\n  name=\"남영환\"\n  description=\"백엔드 개발자\"\n  date=\"2021-11-22\"\n/>\n","excerpt":"매크로에 대한 기억 어린 시절 즐기던 게임에서는 레벨 업을 위해 지루한 반복 사냥을 해야 할 때가 많았습니다. 제 친구 중 몇 명은 매크로 프로그램을 이용해 반복 사냥을 컴퓨터가 대신하게 했습니다. 매크로를 이용하면 캐릭터가 어떤 방향으로 공격을 하게…","banner":null,"id":"8fb62198-b9c2-5632-89fc-8ff5d69d3328","email":"ssisksl77@gmail.com"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"}}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"}},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"}},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"}},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"}},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"}},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"}},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"}},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"}},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"}},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"}},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"}},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"}},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"}},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"}},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"}},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"}},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"}}]}},"pageContext":{"slug":"/the-macro","title":"클로저 매크로에 대해 알아보자","category":"engineering","email":"ssisksl77@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","description":"그만 알아보자","author":"남영환","email":"ssisksl77@gmail.com","slug":"/the-macro","tags":["Clojure","Macro","Lisp"],"category":"engineering"}}},"staticQueryHashes":["3090400250","318001574"]}