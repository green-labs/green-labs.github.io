{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-lazy-sequence-from-scratch-index-mdx","path":"/lazy-sequence-from-scratch","result":{"data":{"mdx":{"internal":{"content":null,"description":null,"ignoreType":null,"mediaType":null,"contentFilePath":"/Users/hyejin/Documents/tech-blog/content/posts/lazy-sequence-from-scratch/index.mdx"},"frontmatter":{"slug":"/lazy-sequence-from-scratch","email":"ssisksl77@gmail.com","tags":["Javascript","Laziness","Lambda Calculus","clojure"],"title":"함수만으로 지연성까지","description":"그만 알아보자","date":"2022년 7월 27일","category":"engineering","author":"남영환"},"body":"\n## 소개\n\n제가 함수형 프로그래밍으로 개발한다고 말하면, 때때로 저에게 함수만으로 무엇을 할 수 있는지 물어보는 분들이 있습니다.\n저는 그분들에게 무엇이든 할 수 있다고 답합니다. 하지만 이 말로는 부족할 때가 많습니다.\n오늘은 그 질문에 대한 저만의 답변이 될 만한 이야기들을 간단하게 적어보려고 합니다.\n\n## 자연수 만들기\n\n함수만으로 우리는 자연수를 표현할 수 있습니다.\n저는 처치 인코딩(Church numerals)을 이용하려고 합니다. 자세한 설명은 다음 링크를 참고해주시기 바랍니다. [[1]](#ref-1)[[5]](#ref-5)\n개발자는 코드로 말하므로 이론적인 설명은 치우고 곧바로 코드를 만들도록 하겠습니다.\n\n숫자 0, 1, 2, 3 만들어 보겠습니다. 숫자의 크기는 함수`f`가 얼마나 감싸고 있느냐로 표현합니다.\n언어는 자바스크립트를 사용합니다.[[4]](#ref-4)\n\n```js\nvar zero = (f) => (x) => x;\nvar one = (f) => (x) => f(x);\nvar two = (f) => (x) => f(f(x));\nvar three = (f) => (x) => f(f(f(x)));\n```\n\n다음 수, 더하기, 곱하기 함수를 만들어보겠습니다. (빼기, 나누기, 지수 등 추가적으로 관심이 있으시다면 [[5]](#ref-5)를 참고해주세요)\n\n```js\n// f를 1개 추가합니다.\nvar SUCC = (n) => (f) => (x) => f(n(f)(x));\n// f를 n개 추가합니다.\nvar PLUS = (m) => (n) => m(SUCC)(n);\nvar MULT = (m) => (n) => m(PLUS(n))(zero);\n```\n\n하지만 람다표현식이 정말로 제대로 동작하는지 확인하기는 쉽지 않습니다. 모두 함수로 감싸져있기 때문입니다.\n임의로 출력하는 함수는 만들어보았습니다. 함수로 문자를 표현하는 것은 생각하겠습니다.\n\n```js\nvar printNumber = (f) => f((n) => n + '+1')('0');\n```\n\n실제로 출력을 해보겠습니다.\n\n```js\nconsole.log(printNumber(zero)); // 0\nconsole.log(printNumber(one)); // 0+1\nconsole.log(printNumber(two)); // 0+1+1\nconsole.log(printNumber(three)); // 0+1+1+1\n```\n\n계승, 더하기, 곱하기는 잘 작동하는지 보겠습니다.\n\n```js\nconsole.log(printNumber(SUCC(three))); // 0+1+1+1+1\nconsole.log(printNumber(MULT(two(one)))); // 0+1+1\nconsole.log(printNumber(MULT(two)(three))); // 0+1+1+1+1+1+1\n```\n\n## 함수로 만드는 자료구조\n\n우리는 자료구조 중에 두 개의 요소를 저장할 수 있는 `pair`를 만들어 볼 것입니다.\n이제부터 숫자는 자바스크립트 타입을 그대로 사용하겠습니다.\n\n```js\nvar pair = (a) => (b) => (f) => f(a)(b);\nvar first = (a) => (b) => a;\nvar second = (a) => (b) => b;\n\npair(1)(2)(first); // 1\npair(1)(2)(second); // 2\n```\n\n이렇게 구현한 pair를 이용하여 우리는 N개의 요소를 나열하는 자료구조를 만들 수 있습니다.\n\n```js\npair(1)(pair(2)(3))(first); // 1\npair(1)(pair(2)(3))(second)(first); // 2\n```\n\n## 함수로 만드는 조건절\n\n조건절을 만드려면 참과 거짓이 있어야합니다.\n\n```js\nvar TRUE = (a) => (b) => a;\nvar FALSE = (a) => (b) => b;\n```\n\n이 함수가 참과 거짓을 잘 나타내는지 확인해보기위해 `AND`, `OR` 를 만들어보겠습니다.\n\n```js\nvar AND = (a) => (b) => a(b)(FALSE);\nvar OR = (a) => (b) => a(TRUE)(b);\n```\n\n진리표에 부합하는 값이 나오는지 테스트해보겠습니다.\n\n```js\nAND(TRUE)(TRUE); // [Function: TRUE]\nAND(TRUE)(FALSE); // [Function: FALSE]\nAND(FALSE)(TRUE); // [Function: FALSE]\nAND(FALSE)(FALSE); // [Function: FALSE]\n\nOR(TRUE)(TRUE); // [Function: TRUE]\nOR(TRUE)(FALSE); // [Function: TRUE]\nOR(FALSE)(TRUE); // [Function: TRUE]\nOR(FALSE)(FALSE); // [Function: FALSE]\n```\n\n조건절은 아래처럼 만들 수 있습니다.\n\n```js\nvar COND = (p) => (a) => (b) => p(a)(b);\n```\n\n`TRUE`, `FALSE` 가 잘 작동하는지 보겠습니다.\n\n```js\nCOND(TRUE)(1)(2); // 1\nCOND(FALSE)(1)(2); // 2\n```\n\n실제로 사용을 하려면 `TRUE`, `FALSE` 람다를 리턴하는 함수가 필요합니다.\n위에서 생성한 숫자를 테스트하는 `ISZERO` 를 만들어 보겠습니다.\n\n```js\nvar ISZERO = (f) => f((a) => FALSE)(TRUE);\nISZERO(zero); // [Function: TRUE]\nISZERO(one); // [Function: FALSE]\n```\n\n`COND` 에 대입하면 작동하는 것을 볼 수 있습니다.\n\n```js\nCOND(ISZERO(zero))(10)(20); // 10\nCOND(ISZERO(one))(10)(20); // 20\n```\n\n## 함수로 만드는 반복문\n\n함수로 반복문을 만들 때는 재귀를 이용합니다.\n하지만 만약 이름이 없는 익명함수(람다)인 경우는 어떻게 할 수 있을까요?\n\n오로지 익명함수만으로 재귀를 호출할 수 있는 '와이콤비네이터'라는 것이 있습니다.\n이것은 일전에 제가 블로그로 소개하는 것이 있으니 그것을 참고해주시면 감사하겠습니다. [[2]](#ref-2)\n\n## 함수로 만드는 지연성\n\n대부분의 프로그래밍 언어는 함수가 실행되기 전에 인자를 먼저 평가합니다. [[3]](#ref-3)\n아래 코드에서 우리는 `1 + 1` 표현식의 평가를 지연시켜야 합니다.\n\n```js\nsomeFunction(1 + 1);\n```\n\n그러기 위해서 우리는 함수로 감싸서 평가를 지연시킬 것입니다.\n\n```js\nvar delayedTwo = () => 1 + 1;\n```\n\n다시 실행하려면 인자가 없이 함수를 실행시키면 됩니다.\n\n```js\ndelayedTwo();\n2;\n```\n\n이제 우리는 아주 쉽게 평가가 지연된 배열을 만들 수 있습니다.\n\n```js\n// 가독성을 위해 인자 2개를 한번에 받도록 하였습니다.\nvar l = pair(1)(() => 2);\nl(second)();\n```\n\n하지만 중간중간마다 `()` 을 이용하여 지연(delay)된 값을 강제로 평가해서 가져와야 합니다.\n우리는 이것을 `force`라는 함수로 대신하도록 할 것입니다.\n\n```js\nvar force = (a) => a();\n```\n\n이제 `second`의 경우 수행될 때마다 한번은 강제로 평가를 수행하는 `force`를 추가로 수행해야 합니다.\n\n```js\nvar force = (a) => a();\nvar secondForce = (a) => (b) => b(force);\n```\n\n이제 다음처럼 호출할 수 있습니다.\n\n```js\nl(secondForce);\n2;\n```\n\n우리는 이제 특정 범위의 숫자를 지연된 리스트로 만들어낼 수 있습니다.\n\n```js\nvar range = (start) => (end) => {\n  if (start > end) {\n    return null;\n  } else {\n    return pair(start)(() => range(start + 1)(end));\n  }\n};\n```\n\n테스트를 해보겠습니다.\n\n```js\nvar a = range(1)(3);\na(first); // 1\na(secondForce)(first); // 2\na(secondForce)(secondForce)(first); // 3\n```\n\n테스트하기 위해 좀 지연된 리스트를 모두 리턴하는 함수를 만들어 보겠습니다.\n\n```js\nvar printAll = (list) => {\n  while (list != null) {\n    console.log(list(first));\n    list = list(secondForce);\n  }\n};\n\nprintAll(range(1)(10));\n```\n\n무한으로 반복하는 `repeat`이라는 함수도 만들 수 있습니다.\n\n```js\nvar repeat = (n) => pair(n)(() => repeat(n));\n\nvar ones = repeat(1);\nones(first); // 1\nones(secondForce)(first); // 1\nones(secondForce)(secondForce)(first); // 1\n// printAll() // 브라우저가 멈출 수 있습니다.\n```\n\n우린 방금 무한으로 만들어지는 자료구조를 생성하였습니다.\n이제 `take`라는 함수를 이용해서 무한 자료구조에서 N개만을 가져올 수 있도록 해볼 것입니다.\n\n```js\nvar take = (n) => (list) => {\n  if (n <= 0) return null;\n  return pair(list(first))(() => take(n - 1)(list(secondForce)));\n};\n\nprintAll(take(100)(repeat(1))); // 1이 100번 출력됩니다.\nprintAll(take(1)(range(1)(10000000000000000000000000000000000))); // 1\n```\n\n아래는 지금까지 소개한 코드를 모두 모아놓은 것입니다.\n\n```js\nvar zero = (f) => (x) => x;\nvar one = (f) => (x) => f(x);\nvar two = (f) => (x) => f(f(x));\nvar three = (f) => (x) => f(f(f(x)));\n\nvar SUCC = (n) => (f) => (x) => f(n(f)(x));\nvar PLUS = (m) => (n) => m(SUCC)(n);\nvar MULT = (m) => (n) => m(PLUS(n))(zero);\n\nvar printNumber = (f) => f((n) => n + '+1')('0');\n\nvar pair = (a) => (b) => (f) => f(a)(b);\nvar first = (a) => (b) => a;\nvar second = (a) => (b) => b;\n\nvar TRUE = (a) => (b) => a;\nvar FALSE = (a) => (b) => b;\n\nvar AND = (a) => (b) => a(b)(FALSE);\nvar OR = (a) => (b) => a(TRUE)(b);\n\nvar COND = (p) => (a) => (b) => p(a)(b);\n\nvar ISZERO = (f) => f((a) => FALSE)(TRUE);\n\nvar force = (a) => a();\nvar secondForce = (a) => (b) => b(force);\n\nvar range = (start) => (end) => {\n  if (start > end) {\n    return null;\n  } else {\n    return pair(start)(() => range(start + 1)(end));\n  }\n};\n\nvar repeat = (n) => pair(n)(() => repeat(n));\n\nvar take = (n) => (list) => {\n  if (n <= 0) return null;\n  return pair(list(first))(() => take(n - 1)(list(secondForce)));\n};\n\nvar printAll = (list) => {\n  while (list != null) {\n    console.log(list(first));\n    list = list(secondForce);\n  }\n};\n```\n\n## Clojure Macro로 Javascript의 한계를 넘어보기\n\n이번장은 람다표현식에 대한 장이 아닙니다. 함수를 넘어서 매크로를 설명하는 번외편입니다.\n\n우리는 지금까지 자바스크립트를 사용하여 함수의 강력함을 알아보았습니다.\n자바스크립트의 함수는 가능한 모든 것을 만들기에 충분합니다.\n하지만 저에게는 한 가지 아쉬운 점이 남아있습니다.\n\n바로 지연하기 위한 코드를 함수로 만들 수 없다는 점입니다.\n\n```js\nvar delay = (a) => () => a;\n```\n\n이 코드는 지연이 되는 것 같지만 우리가 원하는 대로 수행되지 않습니다.\n\n```js\ndelay(console.log('지연되지 않는다'));\n```\n\n왜냐하면 `delay` 가 수행되기 전에 인자가 먼저 평가되기 때문입니다. [[3]](#ref-3)\n우리는 아래처럼 직접 익명함수로 감싸줘야합니다.\n\n```js\n// 이렇게 말이지요\n() => console.log('지연되었습니다.');\n```\n\n하지만 지연성이 필요할 때마다 `() =>` 를 직접 넣고 싶지는 않습니다.\n저는 코드가 좀 더 가독성 있고 자연스러웠으면 좋겠습니다.\n저는 이름을 붙이고 싶습니다.\n\n우리는 자바스크립트로 이것을 해결하기 위해 `eval`, `new Function`을 이용한다면 코드를 문자열로 변경해야 할 것입니다.\n혹은 바벨이나 직접 트랜스파일링을 할 수도 있겠죠. 그렇다면 일이 엄청나게 커질 것입니다.\n\n하지만 이번에는 그린랩스에서 사용하는 Clojure코드를 이용하여 `delay`가 얼마나 쉽게 생성되는지 소개하겠습니다.\n우리는 `delay`라는 매크로를 사용하여 아래 코드를 지연시킬 것입니다.\n\n```clojure\n(delay (println \"지연이 되어야 합니다.\"))\n```\n\n생성된 코드는 다음과 같습니다.\n\n```clojure\n(defmacro delay [expr]\n  `(fn [] ~expr))\n\n(def delayed-print (delay (println \"지연되어야 합니다.\"))) ;; 이곳에서는 아무것도 출력되지 않습니다.\n(delayed-print)  ;; \"지연되어야 합니다.\" 가 출력됩니다.\n```\n\nClojure의 매크로는 아주 자연스럽게 언어를 확장합니다. 원래 그랬던 것처럼요.\n\n감사합니다.\n\n## 참고문헌\n\n1. lambda calculus에 대한 개요\n\n- [1] : [Lambda Calculus에 대해 알아보자](https://helloworld.kurly.com/blog/lambda-calculus-1/) <a name=\"ref-1\"/>\n\n2. Y-Combinator\n\n- [2] : [https://helloworld.kurly.com/blog/y-combinator/](https://helloworld.kurly.com/blog/y-combinator/) <a name=\"ref-2\" />\n\n3. applicative order eveluation\n\n- [3] : [언어의 평가 순서](https://en.wikipedia.org/wiki/Evaluation_strategy) <a name=\"ref-3\"/>\n\n4. 설명하는 언어로 자바스크립트를 사용한 이유\n\n- [4] : [https://www.crockford.com/javascript/javascript.html](https://www.crockford.com/javascript/javascript.html) <a name=\"ref-4\"/>\n\n5. 처치 인코딩\n\n- [5] : [https://en.wikipedia.org/wiki/Church_encoding](https://en.wikipedia.org/wiki/Church_encoding) <a name=\"ref-5\"/>\n","id":"adc71c37-e00e-58e7-83dc-df70f5e6331a"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"},"id":"b6744efa-9cd1-5ad8-9b12-0a38954ffb4b"}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"},"id":"f154cb27-cd10-58b6-8b1e-d58973d0f411"},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"},"id":"5eacd25c-be7f-5bbb-b53e-8bbb8bc8bcfd"},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"},"id":"f13162a1-9c05-5a1e-bf85-655b5aace0ae"},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"},"id":"9ce74193-f3f1-5daf-ac68-4d9b62712ba5"},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"},"id":"cdd0571d-71f3-509e-ad9c-e294c7567d55"},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"},"id":"503f1b09-b133-5f63-8898-ac5eba7cc0d6"},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"},"id":"68a29bba-1b97-586d-a0de-cb6d67c0927f"},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"},"id":"b738b947-e79e-551b-8534-787ebf6e2d9f"},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"},"id":"4a637fde-9c6e-5ace-a010-822ca614e883"},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"},"id":"537a368e-3237-58a2-8691-44450d566d52"},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"},"id":"7b8b38cf-4f0b-5c9d-9bc8-da7dc5b7af6c"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"},"id":"4aa716bb-c5ff-57ae-967e-ee9d2faa9456"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"},"id":"ee2a79b0-460b-57ad-ad6d-afb831aa3d05"},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"},"id":"ff29574f-ad14-52ca-9aa2-63deb07b8ebc"},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"},"id":"1242c8cd-8847-51c9-84b3-00e8ac025cc0"},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"},"id":"fcd89036-f4c3-53c8-b8b8-cf204e6e2218"},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"},"id":"d2b3e0d3-2d3c-5ddd-9190-a649bd9232d8"},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"},"id":"50b95dc8-1681-5633-a035-cabafbe1fb0a"},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"},"id":"c1f6f719-a083-5eb8-94ec-1f94632ba106"}]},"allMdx":{"edges":[{"node":{"id":"23649293-d0ae-5878-809e-e459f2a33862","frontmatter":{"date":"2022-11-28T00:00:00.000Z"}}},{"node":{"id":"a35f56fb-dec5-51dc-8f87-ce415db90df4","frontmatter":{"date":"2022-11-11T00:00:00.000Z"}}},{"node":{"id":"f154cb27-cd10-58b6-8b1e-d58973d0f411","frontmatter":{"date":"2022-10-30T00:00:00.000Z"}}},{"node":{"id":"5eacd25c-be7f-5bbb-b53e-8bbb8bc8bcfd","frontmatter":{"date":"2022-10-26T00:00:00.000Z"}}},{"node":{"id":"f3366c54-e983-5cc1-9ac0-b099ad824dd8","frontmatter":{"date":"2022-10-14T00:00:00.000Z"}}},{"node":{"id":"f13162a1-9c05-5a1e-bf85-655b5aace0ae","frontmatter":{"date":"2022-08-25T00:00:00.000Z"}}},{"node":{"id":"6824dc6c-daa7-5e2b-8b25-283f61471036","frontmatter":{"date":"2022-08-16T00:00:00.000Z"}}},{"node":{"id":"adc71c37-e00e-58e7-83dc-df70f5e6331a","frontmatter":{"date":"2022-07-27T00:00:00.000Z"}}},{"node":{"id":"9ce74193-f3f1-5daf-ac68-4d9b62712ba5","frontmatter":{"date":"2022-07-21T00:00:00.000Z"}}},{"node":{"id":"0cd79f66-41cd-5f02-ac23-99a6b4cfcb3e","frontmatter":{"date":"2022-07-05T00:00:00.000Z"}}},{"node":{"id":"7691ceb5-c5de-5d80-b603-20dc8d12c0c9","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"cdd0571d-71f3-509e-ad9c-e294c7567d55","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"89bcab3e-450c-57df-88a2-6dfedc86db73","frontmatter":{"date":"2022-04-06T00:00:00.000Z"}}},{"node":{"id":"503f1b09-b133-5f63-8898-ac5eba7cc0d6","frontmatter":{"date":"2022-01-11T00:00:00.000Z"}}},{"node":{"id":"aa5a422f-8945-52b8-8969-9531f433c561","frontmatter":{"date":"2021-12-29T00:00:00.000Z"}}},{"node":{"id":"b6744efa-9cd1-5ad8-9b12-0a38954ffb4b","frontmatter":{"date":"2021-11-22T00:00:00.000Z"}}},{"node":{"id":"68a29bba-1b97-586d-a0de-cb6d67c0927f","frontmatter":{"date":"2021-10-29T00:00:00.000Z"}}},{"node":{"id":"b738b947-e79e-551b-8534-787ebf6e2d9f","frontmatter":{"date":"2021-09-24T00:00:00.000Z"}}},{"node":{"id":"4a637fde-9c6e-5ace-a010-822ca614e883","frontmatter":{"date":"2021-09-17T00:00:00.000Z"}}},{"node":{"id":"537a368e-3237-58a2-8691-44450d566d52","frontmatter":{"date":"2021-09-13T00:00:00.000Z"}}},{"node":{"id":"7b8b38cf-4f0b-5c9d-9bc8-da7dc5b7af6c","frontmatter":{"date":"2021-08-31T00:00:00.000Z"}}},{"node":{"id":"4aa716bb-c5ff-57ae-967e-ee9d2faa9456","frontmatter":{"date":"2021-06-01T00:00:00.000Z"}}},{"node":{"id":"ee2a79b0-460b-57ad-ad6d-afb831aa3d05","frontmatter":{"date":"2021-05-30T00:00:00.000Z"}}},{"node":{"id":"ff29574f-ad14-52ca-9aa2-63deb07b8ebc","frontmatter":{"date":"2021-04-27T00:00:00.000Z"}}},{"node":{"id":"1242c8cd-8847-51c9-84b3-00e8ac025cc0","frontmatter":{"date":"2021-01-29T00:00:00.000Z"}}},{"node":{"id":"fcd89036-f4c3-53c8-b8b8-cf204e6e2218","frontmatter":{"date":"2020-12-21T00:00:00.000Z"}}},{"node":{"id":"d2b3e0d3-2d3c-5ddd-9190-a649bd9232d8","frontmatter":{"date":"2020-12-15T00:00:00.000Z"}}},{"node":{"id":"50b95dc8-1681-5633-a035-cabafbe1fb0a","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}},{"node":{"id":"c1f6f719-a083-5eb8-94ec-1f94632ba106","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}}]}},"pageContext":{"slug":"/lazy-sequence-from-scratch","title":"함수만으로 지연성까지","category":"engineering","email":"ssisksl77@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","description":"그만 알아보자","author":"남영환","email":"ssisksl77@gmail.com","slug":"/lazy-sequence-from-scratch","tags":["Javascript","Laziness","Lambda Calculus","clojure"],"category":"engineering"}}},"staticQueryHashes":["318001574"]}