{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-what-is-reasonml-index-mdx","path":"/what-is-reason-ml","result":{"data":{"post":{"slug":"/what-is-reason-ml","title":"자바스크립트 개발자를 위한 ReasonML","date":"2020년 12월 1일","tags":[{"name":"Reason","slug":"reason"},{"name":"ReasonML","slug":"reason-ml"},{"name":"OCaml","slug":"o-caml"},{"name":"Bucklescript","slug":"bucklescript"},{"name":"ReScript","slug":"re-script"}],"description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","canonicalUrl":null,"body":"\n## 시작하며\n\n> ReasonML은 OCaml과 자바스크립트의 특징을 두루 가지고 있는 현대적 프로그래밍 언어입니다. 특히 리액트나 그래프큐엘과 같이 널리 쓰이는 기술과도 잘 맞아서 개발자의 생산성을 많이 올려줍니다.\n\n그린랩스에서는 [ReasonML](https://reasonml.github.io/)로 풀스택 웹 개발을 하고 있습니다. 수개월간 제품 개발에 사용해본 결과, 지금은 ReasonML 덕분에 전체적인 개발 생산성이 많이 올라갔습니다. 하지만 한국에서 ReasonML은 아직 생소한 언어인 것 같습니다.\n\n이 글은 웹 개발을 할 때 ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 이 글이 ReasonML에 관심있는 분에게 조금이라도 도움이 되길 바랍니다.\n\n## ReasonML 특징\n\n### 1. 자바스크립트와 좋은 관계\n\n<br />\n\n```reason\n/* 상품명 앞에 \"Name: \"을 붙여주는 함수 */\nlet formatName = product => \"Name: \" ++ product.name;\n```\n\n만약 자바스크립트 개발 경험이 있다면, 위의 코드가 쉽게 읽힐 것입니다. 그러나 자바스크립트처럼 생긴 위 코드는, 실은 ReasonML 코드입니다. ReasonML은 2016년에 만들어진 매우 현대적인 언어임에도 자바스크립트를 포함한 C 스타일의 언어에 익숙한 사람에게 친숙해지는 것을 목표로 설계되었습니다. 따라서 문법(Syntax)의 많은 모양새가 자바스크립트를 닮았습니다.\n\n또한 ReasonML 코드는 자바스크립트 코드로 컴파일되어 브라우저와 노드 환경 양쪽에서 실행 가능합니다. 따라서 우리가 기존에 웹 개발을 할 때 사용했던 리액트, 익스프레스 등 자바스크립트 생태계를 그대로 사용할 수 있습니다.\n\n### 2. 강력하고 안전한 타입 시스템\n\nReasonML은 강력한 타입 시스템을 가진 정적 언어입니다. 강력한 타입 시스템은 프로그래밍 할 때, 버그를 줄여주고 유지 보수를 용이하게 해줍니다. 개발자가 ReasonML의 강력한 타입 시스템을 통해 얻는 이점은 다음의 두 가지로 설명할 수 있습니다.\n\n첫 번째로, 런타임에 **null/undefined 타입 에러가 발생하지 않음을 보장합니다.** ReasonML은 안전한(_Sound_) 타입 시스템을 가졌기 때문에 컴파일러의 타입 검사를 통과한 코드는 위와 같은 에러가 발생하지 않습니다.\n\n두 번째로, 타입 추론 능력이 뛰어나기 때문에, **개발자가 불필요한 타입 어노테이션을 적을 필요가 없습니다.** 그래서 타입 힌트로 인해 코드가 장황해지는 부작용이 없습니다.\n\n```reason\n/* 상품 타입을 선언 */\ntype product = {\n  name: string,\n  id: int,\n};\n\n/* 별다른 타입 힌트를 주지 않아도, 상품 타입으로 옳게 추론함. */\nlet updateName = (product, name) => { ...product, name };\n```\n\n실례로 페이스북은 2017년, 페이스북 메신저의 웹 버전을 ReasonML로 [포팅한 결과를 포스팅했습니다.](https://reasonml.github.io/blog/2017/09/08/messenger-50-reason) 해당 포스팅에서 페이스북은 1년 동안 단 10개의 버그를 찾았다고 발표했고, 가장 큰 이유로 ReasonML의 강력한 타입 시스템을 언급했습니다.\n\nReasonML에서 이런 마법 같은 일이 가능한 이유는 OCaml 언어의 안전한(_Sound_) 타입 시스템을 이용하기 때문입니다. 사실 ReasonML은 OCaml에 중괄호 문법 등을 추가해 자바스크립트를 사용했던 사람도 익숙하게 사용할 수 있도록 문법적으로 확장한 것입니다.\n\n**[OCaml]**\n\n```ocaml\nlet _ =\n  let msg = \"Hello\" in\n  print_string msg;\n  let msg2 = \"Goodbye\" in\n  print_string msg2\n```\n\n**[중괄호를 이용한 ReasonML]**\n\n```reason\n{\n  let msg = \"Hello\";\n  print_string msg;\n  let msg2 = \"Goodbye\";\n  print_string msg2\n};\n```\n\n<br />\n\n### 3. 빠른 컴파일 속도\n\nReasonML은 빠른 컴파일 속도가 장점입니다. 페이스북의 통계를 다시 인용하자면 [페이스북 메신저 프로젝트](https://reasonml.github.io/blog/2017/09/08/messenger-50-reason)에서 **수백 개 파일을 빌드 하는데 걸린 시간이 2초 이내**였고, 그 이후에 수행되는 점진적인 빌드 시간 또한 100ms를 넘지 않았습니다. 저도 회사에서 ReasonML 코드를 작성할 때, 자바스크립트 코드로 컴파일되는 시간은 대부분 50ms 이내 끝났습니다. 마치 파일 수정과 동시에 빌드가 완료되는 것 같았습니다.\n\nReasonML은 빌드 속도를 위해서 간결하고 빠르다고 알려진 [닌자](https://ninja-build.org/)를 빌드 도구로 선택했습니다. 그리고 ReasonML 빌드에 사용되는 OCaml 프론트엔드 컴파일러는 프랑스 국립 연구기관인 [INRIA](https://www.inria.fr/en)에 의해 수십 년 동안 연구 및 최적화되어서 굉장히 빠릅니다.\n\n공식 사이트에서 진행한 [컴파일 속도 테스트의 내용](https://rescript-lang.org/docs/manual/latest/build-performance#extreme-test)은 다음과 같습니다.\n\n- 조건: 맥북 프로 2015년형 (3.1GHz Intel Core i7) 기준. 10,000개의 파일을 생성하고, 절반은 의존성을 추가해 줌.\n- 결과: 클린 빌드 시, 3분 이내. 점진적 빌드 시, 의존성이 없는 경우, 평균 1초 안에 완료.\n\n또한 한 개발자가 타입스크립트와 ReasonML의 컴파일 속도를 비교한 [포스팅](https://blog.dubenko.dev/typescript-vs-reason/)이 있는데, TodoMVC 애플리케이션 컴파일 시, 타입스크립트와 리액트 조합은 총 6.18초나 걸린 반면, ReasonML + 리액트 애플리케이션은 0.99초 밖에 걸리지 않았습니다.\n\n정리하자면 ReasonML은 OCaml이지만 자바스크립트로 컴파일됩니다. 그래서 **_OCaml의 강력한 타입 시스템과 빠른 컴파일 속도라는 장점을 취하면서도, 동시에 가장 대중적이고 활발한 자바스크립트 생태계 전체를 활용할 수 있는 현대적 언어_**입니다.\n\n## ReasonML의 기원\n\n### 1. 리액트의 탄생\n\n갑자기 리액트가 등장해서 의아하시겠지만, ReasonML은 리액트를 만든 [Jordan Walke](https://twitter.com/jordwalke)가 만들었습니다. 그래서 그가 ReasonML을 왜 만들었는지 알기 위해서는 리액트의 탄생부터 알아보아야 합니다.\n\nJordan Walke는 페이스북에서 일하면서 [Standard ML](https://www.smlnj.org/)이라는 언어의 매력에 푹 빠져있었습니다. 그래서 리액트의 프로토타입 또한 SML로 만들었습니다. (이러한 이유로 리액트의 근본이 되는 철학은 객체 지향 프로그래밍보다는 함수형 프로그래밍에 더 가깝습니다.) 하지만 그는 대중성을 위해 리액트 프로젝트를 자바스크립트로 포팅하기를 결심합니다. 그 결과 리액트는 매우 큰 성공을 거두었고, 현재 세계에서 가장 유명한 프론트엔드 기술이 되었습니다.\n\n### 2. 함수형 혹은 강력한 타입 시스템의 여러 프로젝트들\n\n리액트가 나온 이후 몇몇 사람들은 리액트라는 구현체보다 그 바탕에 있는 패러다임을 주목했습니다. 이후 리덕스, 엘름과 같은 프로젝트들이 탄생했습니다. 어떤 프로젝트는 리액트와 함께 사용하는 라이브러리로, 어떤 프로젝트는 리액트와 경쟁하는 라이브러리가 됐습니다. 하지만 양쪽의 경우 모두 개발자들로 하여금 함수형 패러다임과 강력한 타입 시스템에 대한 관심을 증폭시키는 계기가 되었습니다. 이러한 프로젝트의 성공을 보며 페이스북과 Jordan Walke도 웹 개발을 위한 새로운 언어가 필요하다고 생각하게 됩니다.\n\n### 3. 버클스크립트 컴파일러[^1]의 탄생\n\n비슷한 시기에 많은 회사들이 자바스크립트에 타입 시스템을 도입하는 방법에 대해서 연구했습니다. 그 시도는 자바스크립트에 점진적 타입 시스템(타입스크립트, 플로우 등)을 적용하는 접근도 있었고, 정적 타입 언어를 개발하여 자바스크립트로 컴파일(퓨어스크립트 등)하는 접근도 있었습니다. 그 시도 중 하나로 블룸버그 개발자였던 [Hongbo Zhang](https://www.linkedin.com/in/hongbo-zhang-a8574157/)이 OCaml 컴파일러의 백엔드를 자바스크립트로 포팅했습니다. 그는 OCaml 코드를 자바스크립트로 컴파일해서 브라우저에서 실행하는데 성공했고, 이 프로젝트를 버클스크립트라는 오픈소스로 공개했습니다.\n\n### 4. ReasonML의 탄생\n\nJordan Walke가 리액트를 만들 때 사용했던 SML과 OCaml은 뿌리가 같습니다. 둘 다 [ML 계열의 언어](<https://ko.wikipedia.org/wiki/ML_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)>)로, 굳이 비유하자면 SML은 미국 사투리, OCaml은 프랑스 사투리입니다. 따라서 Jordan Walke는 새로운 언어를 만들며 OCaml과 버클스크립트 컴파일러를 활용해야겠다고 생각했습니다. 또한 그는 리액트 프로젝트를 자바스크립트로 포팅해 성공한 경험으로 인해, 새로운 언어가 자바스크립트 문법과 친숙해야한다고 생각했습니다. 그렇게 그는 OCaml에 문법을 추가했고, 그 결과 **ML 계열의 강력한 타입 시스템을 가지고 있으면서, 기존 자바스크립트 생태계와도 자연스럽게 융화될 수 있는 ReasonML이 탄생**했습니다.\n\n**[자바스크립트 문법]**\n\n```javascript\nconst myFun = (x, y) => {\n  const doubleX = x + x;\n  const doubleY = y + y;\n  return doubleX + doubleY;\n};\n```\n\n**[자바스크립트와 닮아있는 ReasonML 문법]**\n\n```reason\nlet myFun = (x, y) => {\n  let doubleX = x + x\n  let doubleY = y + y\n  doubleX + doubleY\n}\n```\n\n최근 Jordan Walke는 ReasonML에 대해서 [다음과 같은 의견](https://news.ycombinator.com/item?id=23173151)을 가지고 있습니다.\n\n> ReasonML은 여러 가지 하위 프로젝트를 위한 생태계이자 스폰서다. 이 모든 프로젝트는 타입 안정성, 빠른 컴파일 및 빠른 실행 코드를 많은 개발자들에게 제공한다는 목표를 가지고 있다.\n\nReasonML이 새로운 문법을 추가하여 프로그래밍 언어적으로 발전하는 것도 물론 중요하지만, 보다 높은 수준에서의 진정한 목표는 **_타입 안정성, 빠른 컴파일 속도, 빠른 실행 속도_** 이 세 가지라는 것입니다. 이와 관련하여 보다 자세한 내용이 담겨있는 발표 자료가 있으니 참고하시면 좋을 것 같습니다.\n\n**[React to the Future - Jordan Walk]**\n\n<iframe\n  id=\"ytplayer\"\n  type=\"text/html\"\n  width=\"100%\"\n  height=\"400\"\n  src=\"https://www.youtube.com/embed/5fG_lyNuEAw\"\n  frameborder=\"0\"\n></iframe>\n\n## 타입스크립트와의 비교\n\nReasonML과 타입스크립트 모두 타입을 도입하여 자바스크립트를 보다 안전하게 사용하기 위한 목적으로 만들어졌습니다. 현재 타입스크립트는 가장 성공한 자바스크립트의 타입 시스템이 아닐까 싶습니다.\n\n1. 자바스크립트 문법과의 하위 호환\n2. 사용성\n3. 완벽한 타입 안정성\n\n여기서 두 가지만 선택해야 한다면 어떤 것들을 선택하시겠나요? 타입스크립트는 1,2번을 선택하였고, ReasonML은 2,3번을 선택하였습니다.[^2] 이것은 옳고 그름의 문제가 아닙니다. 언어별로 디자인의 철학이 다를 뿐입니다. ReasonML이 보다 완벽하게 타입 안정성을 제공하지만, [타입스크립트의 방향성 또한 옳습니다.](https://twitter.com/jordwalke/status/1212988231416811520)\n\n하지만 두 언어의 철학이 다른 것에서 오는 차이점도 분명히 존재합니다. 공식 웹사이트에 있는 [타입스크립트와의 차이점](https://rescript-lang.org/docs/manual/latest/introduction#difference-vs-typescript)의 내용을 바탕으로 정리해보겠습니다.\n\n**1. ReasonML은 엄선된 기능만을 제공하기 때문에 사용하기 쉽습니다.**\n\n- 타입스크립트는 다소 복잡하고 익혀야할 것이 많습니다. 왜냐하면 기존 자바스크립트 문법 전체를 포함하면서, 그 이상의 기능을 제공하여 개발자의 생산성을 높이는 것이 목표[^3]이기 때문입니다.\n- ReasonML은 자바스크립트 문법 중, 안전한 지점만 제한적으로 사용하도록 하여 프로그램 전체의 타입 안정성을 획득하는 것이 목표입니다. 엄선된 기능(curated set)만을 제공하기 때문에 상대적으로 문법이 쉽고 간단합니다.\n\n**2. ReasonML은 프로젝트의 타입 커버리지를 올바르게 측정할 수 있습니다.**\n\n- 기존 자바스크립트 프로젝트를 마이그레이션할 때, 타입스크립트를 이용해 타입을 추가하다보면 여러 파일에 파편적으로 타입 힌트를 추가하게 됩니다. 이런 방식으로는 과거와 비교해 얼마만큼 더 안전해졌는지 알기 어렵고, 또한 프로그램 전체의 타입 커버리지를 측정하기도 어렵습니다.\n- ReasonML은 안전한 코드(= 순수한 ReasonML 코드)와 그렇지 않은 코드(= 자바스크립트와 함께 동작하는 코드)가 명확히 구분됩니다. 따라서 파일 단위로 마이그레이션을 하면 점진적으로 타입 안정성을 획득하고 커버리지 또한 측정할 수 있습니다.\n\n**3. ReasonML은 타입이 있는 함수형 프로그래밍 스타일을 권장합니다.**\n\n- if나 가상 디스패치보다 패턴 매칭으로, 클래스보다 순수 데이터와 함수 조합으로 프로그래밍하도록 합니다. 또한 무분별하게 문자열을 사용하기보다는 타입을 통한 적절한 데이터 모델링을 하도록 강제합니다.\n\n## 마치며\n\nReasonML 컴파일러는 제 코드의 타입이 틀린 곳을 자세하고 집요하게 지적해 줍니다. 때문에 처음에는 컴파일러의 검사를 통과시키기가 힘들었습니다. 하지만 그 깐깐한 검사를 통과하면 굉장히 뿌듯하고 마음까지 편안해집니다. 적어도 실행 시점에 예상치 못한 타입 에러는 없을 것이기 때문입니다.\n\n저는 ReasonML의 이런 개발 경험을 **\"똑똑한 컴파일러와 페어 프로그래밍을 하는 것 같다\"**라고 표현합니다. 덕분에 런타임에 브라우저 에러 로그를 보고 실수를 바로잡는 일을 해본 지 정말 오래된 것 같습니다.\n\n현재 그린랩스에서는 크고 작은 여러 프로젝트에서 ReasonML을 사용하고 있습니다. ReasonML을 통해서 타입 시스템이라는 깊고 심오한 분야가 있다는 것을 알게 되었고, 올바른 타입 시스템을 사용해 프로그램을 작성하는 방법에 대해 꾸준히 공부하고 있습니다.\n\n제가 느꼈던 좋은 개발 경험에 대해 나누고 싶었습니다. 제 글이 ReasonML을 시작하는 분이나 자바스크립트에 타입 시스템을 도입하고 싶으신 분들께 작게나마 도움이 된다면 좋겠습니다. 이 글에서 미처 담지 못한 내용과 리액트, 그래프큐엘과 함께 사용할 때의 좋은 점 등은 나중에 주제별로 자세히 다루겠습니다.\n\n<br />\n<br />\n<Author\n  email=\"kimchhickey@gmail.com\"\n  name=\"양성민\"\n  description=\"백엔드 엔지니어\"\n  date=\"2020-12-01\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [https://reasonml.github.io/](https://reasonml.github.io/)\n- [https://rescript-lang.org/docs/manual/latest/introduction](https://rescript-lang.org/docs/manual/latest/introduction)\n- [https://2ality.com/2017/11/about-reasonml.html](https://2ality.com/2017/11/about-reasonml.html)\n- [https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/](https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/)\n- [https://tiny.cloud/blog/tinymce-reasonml/](https://tiny.cloud/blog/tinymce-reasonml/)\n- [https://blog.dubenko.dev/typescript-vs-reason/](https://blog.dubenko.dev/typescript-vs-reason/)\n\n[^1]: 버클스크립트가 2020년 8월 리스크립트로 리브랜딩 하여 활발히 개발되고 있습니다. [(참고)](https://rescript-lang.org/blog/bucklescript-is-rebranding) 혼란을 줄이기 위해서 본문에서는 버클스크립트로 통일하였습니다.\n[^2]: 이 질문은 Jordan Walke가 해커 뉴스에서 작성한 댓글에서 발췌하였습니다. [(링크)](https://news.ycombinator.com/item?id=23174007)\n[^3]: 또한 타입스크립트는 안전(_sound_)하지 않은 타입 시스템 언어입니다. 대신 안전하지 않을 수 있는 동작에 대해서 심도있게 고려하여, 그러한 상황이 발생할 수 있는 시나리오를 문서로 정리해서 제공하고 있습니다. [(참고)](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness)\n","excerpt":"시작하며 ReasonML은 OCaml과 자바스크립트의 특징을 두루 가지고 있는 현대적 프로그래밍 언어입니다. 특히 리액트나 그래프큐엘과 같이 널리 쓰이는 기술과도 잘 맞아서 개발자의 생산성을 많이 올려줍니다.\n\n그린랩스에서는 ReasonML로 풀스택…","banner":null,"id":"fc3a6c4f-39be-5f0a-ae90-bdcf692f265f","email":"kimchhickey@gmail.com"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"}}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"}},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"}},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"}},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"}},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"}},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"}},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"}},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"}},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"}},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"}},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"}},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"}},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"}},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"}},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"}},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"}},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"}}]}},"pageContext":{"slug":"/what-is-reason-ml","title":"자바스크립트 개발자를 위한 ReasonML","category":"engineering","email":"kimchhickey@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml","author":"양성민","email":"kimchhickey@gmail.com","date":"2020-12-01T00:00:00.000Z","tags":["Reason","ReasonML","OCaml","Bucklescript","ReScript"],"category":"engineering"}}},"staticQueryHashes":["3090400250","318001574"]}