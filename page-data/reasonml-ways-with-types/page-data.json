{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-namenu-green-tech-blog-content-posts-unbox-the-variant-index-mdx","path":"/reasonml-ways-with-types","result":{"data":{"mdx":{"internal":{"content":null,"description":null,"ignoreType":null,"mediaType":null,"contentFilePath":"/Users/namenu/green/tech-blog/content/posts/unbox-the-variant/index.mdx"},"frontmatter":{"slug":"/reasonml-ways-with-types","email":"tlonist.sang@gmail.com","tags":["ReasonML","object","variant","raw","dict","gadt","unbox"],"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","date":"2020년 12월 21일","category":"engineering","author":"김상현"},"body":"\n자바스크립트나 다른 동적 타입을 가진 언어에서는, 함수나 분기문에서 타입이 다른 데이터를 리턴하는 것이 자연스럽습니다.\n하지만 ReasonML에서는 항상 같은 데이터 타입이 리턴되어야 합니다. 처음 ReasonML을 접하게 되면 이런 타입 시스템의 특성 때문에 당황하실 수 있습니다. 코드 예시를 통해 바로 확인해보겠습니다.\n\n## 자바스크립트 vs. ReasonML\n\n아래의 test 함수는 인자가 숫자(number)일 때는 숫자를, 문자열일때는 문자열을, 그 외에는 `{foo: \"bar\"}`라는 객체를 반환합니다.\n\n```javascript\nlet test = (input) => {\n  if (typeof input === \"number\") return input;\n  else if (typeof input === \"string\") return input;\n  else return { foo: \"bar\" };\n};\n\ntest(1); /*  1  */\ntest(\"hello world!\"); /*  hello world!  */\ntest([1 2 3 4]); /*  {foo: \"bar\"}  */\n```\n\n혹은 각 분기문마다 같은 타입의 다른 필드를 가진 객체를 리턴 할 수도 있습니다.\n아래의 함수는 인자가 참일 때는 `{foo: \"bar\"}`를, 거짓일 때는 `{hello: \"world\"}`를 반환합니다.\n\n```javascript\nif (input === true) {\n  return { foo: 'bar' };\n} else {\n  return { hello: 'world' };\n}\n/*  OK  */\n```\n\n하지만 ReasonML에선 안전한(sound) 타입 시스템을 위해 모든 분기문의 리턴값은 반드시 한 타입으로 정해져 있습니다.\n위의 `{foo: \"bar\"}`와 `{hello: \"world\"}`는 다른 타입으로 간주되어 컴파일이 실패합니다.\n하나의 예시를 더 보겠습니다.\n\n```reason\nif (input === true) {\n  2;  /*  ReasonML에선 마지막 표현식이 리턴으로 간주됩니다.*/\n} else {\n  \"hello\";\n}\n```\n\n결과는 아래와 같습니다.\n\n```console\nThis has type: string\nSomewhere wanted: int\n\nYou can convert string to int with Belt.Int.fromString.\n```\n\n타입이 객체인 경우 세부 모든 세부 필드의 값이 일치해야(구조적 타입) 오류가 나지 않습니다.\n\n```reason\nswitch ((input: bool)) {\n| true => {\"foo\": \"bar\"}\n| false => {\"hello\": \"world\"}\n}\n```\n\n결과는 마찬가지로 컴파일 오류입니다.\n\n```console\n  This has type: {. \"hello\": string}\n  Somewhere wanted: {. \"foo\": string}\n  The second object type has no method hello\n```\n\n하지만 개발을 하다보면 다른 객체를 반환하는 것이 꼭 필요한 경우가 생깁니다. 아래의 예시처럼요.\n\n## 현업에서 마주친 상황\n\n그린랩스에선 프리즈마(Prisma)[^1] 라는 DB 클라이언트를 사용하여 백엔드 개발을 하고 있습니다.\n프리즈마는 ORM처럼 고유의 문법을 사용하며, 중첩된 객체들로 관계형 쿼리를 표현할 수 있습니다. [^2] 아래는 간략화된 실제 코드입니다.\nisHeavy 라는 bool 변수의 값에 따라 참일 경우 20kg보다 무거운 수박을, 거짓일 경우 20kg과 같거나 가벼운 수박을 조회하는 함수입니다.\n\n```javascript\n/*\n  수박 중에서, 조건(isHeavy)에 따라\n  20kg보다 무겁거나, 20kg과 같거나 작은 모든 데이터를 리턴해라\n*/\nawait prisma.watermelon.findMany({\n  where: isHeavy\n    ? { weight: { gt: 20 } }\n    : { weight: { lte: 20 } };\n  });\n```\n\n위 코드를 ReasonML로 옮기면 아래와 같습니다.\n\n```reason\nprisma.watermelon\n->Prisma.findMany({\n  \"where\": {\n    isHeavy\n      ? {\n        \"weight\": {\n          \"gt\": 20,\n        },\n      }\n      : {\n        \"weight\": {\n          \"lte\": 20,\n        },\n      };\n  },\n});\n```\n\n하지만 위의 ReasonML 코드는 컴파일이 실패하고 아래의 오류가 뜹니다.\n\n```console\nError:\nThis expression has type {. \"weight\": {. \"lte\": int}}\nbut an expression was expected of type {. \"weight\": {. \"gt\": int}}\nThe second object type has no method lte\n```\n\nReasonML의 객체 타입 추론은 재귀적으로 작동하여 중첩된 필드까지 전부 검사합니다.\n얼핏 보면 똑같은 `{\"weight\":...}` 객체처럼 보일 수 있지만, 그 안에 하나는 gt라는 키를, 다른 하나는 lte라는 키를 가진 서로 다른 객체이기에 컴파일이 안되는 것이죠.\n그럼 이 문제를 어떻게 해결할까요?\n\n### 해결 방안 1 - [%raw]로 JS코드 직접 넣기\n\n[%raw]를 쓰면 **JS 코드를 직접 삽입**하고 타입 검사를 피할 수 있습니다.\n\n```reason\n[%raw {| console.log(\"hello world!\") |}] /* Js.log(\"hello world!) 와 동일*/\n```\n\n아래는 [%raw]를 적용해본 예시입니다.\n\n```reason\nprisma.watermelon -> Prisma.findMany{\n%raw {|\n  where: isHeavy\n   ? {\"weight\": {\"gt\": 20},}\n   : {\"weight\": {\"lte\": 20},}\n  |};\n};\n```\n\n위의 코드가 컴파일되면 %raw 안의 구문이 그대로 Js 코드가 되어 나옵니다.\n\n```javascript\nisHeavy ? { weight: { gt: 20 } } : { weight: { lte: 20 } };\n```\n\n### 해결 방안 2 - Obj.magic 컴파일러 속이기\n\n`Obj.magic`은 ReasonML 내장함수 중 하나로, 마술(magic)이라는 이름처럼 교묘한 트릭으로 코드를 왜곡합니다. 아래처럼 사용할 수 있습니다.\n\n```reason {3-5}\nisHeavy\n  ? {weight: {gt: 20}}\n  : Obj.magic( /* 컴파일러가 체크하지 않음! */\n      {weight: {lte: 20}}\n    );\n```\n\nObj.magic는 OCaml의 %identity의 바인딩인데요, %identity는 컴파일러에게 '값이 동일하더라도 타입을 다르게 인식해라'라고 말하는 역할을 합니다.\n\n```reason\nexternal magic : 'a -> 'b = \"%identity\";\n```\n\n따라서 `{lte ...}` 는 사실상 `{gt ...}`와 같은 타입으로 인식되어 위의 문제를 회피할 수 있습니다.\n그러나 위 두 방법은 안전하게(sound) 느껴지지 않습니다. 다른 언어를 직접 사용하거나 컴파일러를 속이지 않고, ReasonML 안전한 방법으로 해결할 수는 없을까요?\n\n### 해결 방안 3 - Js.Dict\n\n조금 더 나은 방법으로는 Js.Dict를 사용해 볼 수 있습니다.\n\nJs.Dict는 ReasonML에서 사용할 수 있는 Dictionary 모듈입니다.\n\n```reason\nlet test = Js.Dict.empty();\ntest->Js.Dict.set(\"foo\", \"bar\");\n\ntest->Js.log; /* => {foo: \"bar\"} */\n```\n\n[공식문서](https://rescript-lang.org/docs/manual/latest/api/js/dict)에 다양한 쓰임이 나와 있으니 참고하세요.\n\nJs.Dict를 사용하여 조건에 따라 gt 혹은 lte를 리턴하는 conditionFunc를 만들었습니다.\n\n```reason\nlet result = Js.Dict.empty();\nlet conditionFunc = (isHeavy: bool) => {\n  isHeavy\n    ? result->Js.Dict.set(\"gt\", 20)\n    : result->Js.Dict.set(\"lte\", 20);\n  result;\n};\n```\n\nconditionFunc를 호출하여 콘솔에 찍어보면, 우리가 원했던 객체가 나옵니다.\n\n```console\n{ gt: '20' } //conditionFunc(true)\n{ lte: '20' } //conditionFunc(false)\n```\n\n위 표현이 가능한 이유는 아래와 같습니다.\n![ReasonML-Dict-Example](./reasonml-dict.png)\n\nJs.Dict로 감싼 두 표현은 Js.Dict.t 타입으로 인식되기 때문에 컴파일상 아무 문제가 없습니다. 마치 \"foo\"와 \"bar\"가 값은 다르지만 같은 string 타입인 것처럼요.\nraw나 obj.magic을 썼을 때 보다는 조금 더 타입 안정성이 확보된 것 같습니다. 하지만 **Js.Dict.t 타입이면 다 받을 수 있기 때문에 gt, lte와 같은 키만 들어갈 수 있는지는 보장되지 않습니다.**\n만약 `gt`가 들어갈 자리에 `gd`를 치면 런타임에서 에러가 나겠죠?\n\n### 해결 방안 4 - 배리언트(Variant)\n\n배리언트를 사용해 타입 안정성을 더 높힐 수 있습니다.\n배리언트는 다른 언어의 **enum** 과 비슷한 기능인데, 임의의 데이터를 배리언트로 감싸 표현할 수 있습니다. 또한 패턴 매칭 되기 때문에 다양한 방법으로 활용 가능한 자료형입니다. 간단한 예로 account라는 타입을 보겠습니다.\n\n```reason\ntype account =\n  | None\n  | Instagram(string)\n  | Facebook(string, int)\n```\n\naccount는 None, Instagram, Facebook 중 하나의 타입이 될 수 있는 배리언트입니다. 패턴매칭으로 안의 값을 가져 올 수 있습니다.\n\n```reason\nlet myAccount = Facebook(\"Josh\", 26);\nlet friendAccount = Instagram(\"Jenny\");\n\nswitch (myAccount) {\n| Facebook(name, age) => \"my name is \" ++ name ++ \" and, \" ++ string_of_int(age) ++ \" years old.\"\n| Instagram(name) => \"my name is \" ++ name ++ \".\"\n};\n/* my name is Josh and I am 26 years old. 출력!! */\n```\n\n[공식문서](https://reasonml.github.io/docs/en/variant)에 다양한 쓰임새가 나와있습니다.\n실제로는 아래처럼 쓰일 수 있습니다.\n\n```reason {21}\n/*  allType 배리언트 선언  */\ntype allType =\n  | GT(int)\n  | LTE(int);\n\n/*  배리언트로 감싸진 객체 반환 */\nlet conditionFunc = (isHeavy: bool) => {\n  isHeavy ? GT(20) : LTE(20);\n};\n\n\nconditionFunc(true)->Js.log; /*  { TAG: 0, _0: 20 }  */\n```\n\nconditionFunc를 실행하면 원하는 객체가 아닌 **{'{'} TAG: 0, \\_0: 20 {'}'}**와 같은 배리언트로 둘러싼 값이 나오기 때문에, 원하는 값으로 만들기 위해 앞서 설명한 Js.Dict를 활용하겠습니다.\n\n```reason\nlet toData = (input: allType) => {\n  let ret = Js.Dict.empty();\n  switch (input) {\n  | GT(v) => ret->Js.Dict.set(\"gt\", v)\n  | LTE(v) => ret->Js.Dict.set(\"lte\", v)\n  };\n  ret;\n};\n\nconditionFunc(true)->toData->Js.log; /*  { gt: '20' }  */\n```\n\n이렇게 해서 배리언트를 사용하여 서로 다른 객체를 반환하는데 성공했습니다! 그림으로 다시 보겠습니다.\n\n![ReasonML-Variant-Example](./reasonml-variant1.png)\n\n이렇게 allType 배리언트를 선언하고, 안에 20을 넣었습니다.\n\n![ReasonML-Variant-Example](./reasonml-variant2.png)\n그 후 배리언트 안의 값을 꺼내어, toData 함수를 사용하여 객체를 재구성했습니다.\n\n배리언트를 통한 작업은 Js.Dict만 사용한 이전의 해법보다 더 엄밀한 타이핑이 적용되었습니다. 이제 conditionFunc는 GT, LTE만 리턴하며 allType에 정의되지 않은 타입을 절대 리턴하지 않습니다.\nJs.Dict가 key-value 쌍이 있는 모든 객체를 리턴했던것과 차별되는 부분입니다. 하지만 코드가 길고 배리언트 안의 값을 뽑아서 Js.Dict로 재구성하는 등의 부수적인 절차가 필요했습니다.\n\n### 해결 방안 5 - 배리언트와 언박싱 GADT(심화)\n\n마지막으로, GADT(General Algebraic Data Types)와 언박싱 태그(@unboxed)를 이용한 좀 더 고차원적인 해법도 있습니다.\n그 중에서도 GADT는 난이도가 높은 개념이라 다른 포스팅에서 추가로 다루도록 하고, 간략히 언박싱에 대해서만 먼저 다루겠습니다. 설명은 BuckleScript를 개발한 Hongbo님이 작성한 [리스크립트 블로그 글](https://rescript-lang.org/blog/bucklescript-release-7-0-2)을 참고했습니다.\n\n```reason\n/*  언박싱  */\n[@unboxed]\n/*  GADT 정의  */\ntype t =\n  | Any ('a) : t;\n\n/*  GADT 배리언트의 배열 정의  */\nlet array = [|Any(3), Any(\"a\")|];\n```\n\n<br />\n\n```javascript\n/*  컴파일 결과  */\nvar array = [3, 'a'];\n```\n\n3, \"a\"처럼 서로 타입이 다른 데이터를 Any 로 감싸 한 배열에 넣었습니다. 컴파일 결과 배열 안에는 Any의 실 값 3과 \"a\"가 잘 들어 있습니다. 여기서 만약 언박싱 태그가 없었다면 컴파일 결과는 어땠을까요? 아래와 같습니다.\n\n```javascript\n/*  @unboxed가 없을 때  */\nvar array = [\n  /*  Any  */ {\n    _0: 'hello',\n  },\n  /*  Any  */ {\n    _0: 3,\n  },\n];\n```\n\n이렇듯 \\_0 같은 메타 정보가 붙어 안의 값을 직접 불러오는 것이 번거로워집니다. 하지만 언박싱을 이용하면 값을 바로 가져오기 때문에 서로 다른 타입의 데이터를 한 배열에서 직접 사용할 수 있습니다. 이제 실제 코드에서 사용해보겠습니다.\n\n```reason\n[@unboxed]\ntype t =\n  | Any(Js.t({..})): t;\n  /*\n    - t는 GADT의 개념으로 사용되었습니다.\n    - Any 안의 값을 JSON으로 제한합니다.\n  */\n\n[...]\n\"weight\":\n  if (isHeavy) {\n    Any({\"gt\": 20}); /*  Any에 @unboxed가 있으므로 실 값이 바로 리턴됩니다.  */\n  } else {\n    Any({\"lte\": 20});\n  }\n```\n\n<br />\n\n```reason\ntype t =\n  | Any(Js.t({..})): t;\n```\n\n위의 코드는 Any 안의 데이터를 JS 객체로 한정하는 역할을 합니다. 다른 원시타입(int, string 등)은 올 수 없습니다.\n아래는 JS로 컴파일된 결과입니다.\n\n```javascript\n\"where\": {\n  \"weight\":\n    if (isHeavy) {\n      return {\"gt\": 20};\n    } else {\n      return {\"lte\": 20};\n    }\n},\n```\n\n무엇을 한 것인지 다시 한번 짚어보겠습니다.\n\n![ReasonML-Not-Compile-Example](./reasonml-any1.png)\n\n- 하나의 분기문에서 리턴하는 객체의 구조가 다르면, 컴파일이 되지 않습니다.\n- 따라서 GADT를 활용하여 JSON이 올 수 있는 Any타입을 만들었습니다.\n\n![ReasonML-Compile-Example](./reasonml-any2.png)\n\n- 이후 언박싱 태그를 붙여 Any 안의 값을 바로 꺼내올 수 있도록 했습니다.\n\n## 비교\n\nReasonML의 타입 시스템을 상대하는 다섯가지 방법에 대해 알아보았습니다. 흥미롭게도, 타입 안정성과 코드의 간결함은 반비례 관계에 있습니다.\n모든 데이터에 타입을 적용하면 안정성은 높아지는 대신 코드가 길어지고, 반대로 타입 시스템을 무시하고 코드를 작성하면 코드는 짧지만 안전하지 않습니다. 그림으로 이 느낌을 표현해보았습니다.\n\n![ReasonML-Comparison-Graph](./reasonml-graph.png)\n\n이처럼 트레이드 오프가 명확한 상황에선 **어떤 부분의 안정성을 중요시 할 것인가**가 중요한 질문입니다.\n그랜랩스는 **비즈니스 데이터는 완전한 타이핑**으로 오류 없는 코드를, **라이브러리 혹은 기존의 API를 사용할 때는 선택적인 타이핑**으로 개발의 효율을 추구하고 있습니다.\n위의 프리즈마 쿼리를 작성하는 예시는 후자에 해당하므로 5번(언박싱과 GADT) 방식을 사용하였습니다.\n\n## 맺으며\n\n이번 글에서는 ReasonML의 타입시스템을 적용하며 만날 수 있는 기본적인 문제에 대한 대처방안을 알아보았습니다.\n\n1. `[%raw]` 를 통해 직접 JS 코드 넣기\n2. `Obj.magic`을 이용한 컴파일러 속이기\n3. `Js.Dict` 로 감싸서 리턴하기\n4. 배리언트를 이용한 해법\n5. 언박싱과 GADT을 이용한 해법\n\n이번에 설명하지 못했던 GADT의 개념과 배리언트의 더 자세한 사용법은 앞으로의 포스팅에서 다루도록 하겠습니다.\n또 다른 글에서 만나길 기대하며, Merry ReasonML, Happy new year!\n\n<br />\n<br />\n<br />\n<br />\n\n#### 참고자료\n\n- [https://reasonml.github.io/](https://reasonml.github.io/)\n- [https://rescript-lang.org/blog/bucklescript-release-7-0-2](https://rescript-lang.org/blog/bucklescript-release-7-0-2)\n- [https://rescript-lang.org/docs/manual/latest/api/js/dict](https://rescript-lang.org/docs/manual/latest/api/js/dict)\n- [https://rescript-lang.org/docs/manual/latest/object](https://rescript-lang.org/docs/manual/latest/object)\n\n[^1]: [https://www.prisma.io/](https://www.prisma.io/)\n[^2]: [https://www.prisma.io/docs/concepts/components/prisma-client/filtering](https://www.prisma.io/docs/concepts/components/prisma-client/filtering)\n\n<Author\n  email=\"tlonist.sang@gmail.com\"\n  name=\"김상현\"\n  description=\"백엔드 개발자\"\n  date=\"2020-12-21\"\n/>\n","id":"127d7aab-cdef-5e35-950d-397bb65e3ae4"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"},"id":"13e3bc56-c56f-514d-be53-6566467c13b4"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"},"id":"b9a9d532-8635-5bea-8287-c0c09465bf76"}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"모노레포 - 마이크로 아키텍처를 지향하며","date":"2023-01-16T00:00:00.000Z","author":"최경식","category":"engineering","description":"모노레포에 대해서 들어보셨나요? 프론트엔드에서 마이크로 아키텍처를 지향하려면 어떻게 해야할까요?","slug":"/monorepo-microfrontend"},"id":"7a6ee670-bba5-5f18-baa1-6fcdda49f8c7"},{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"},"id":"fc5716a7-cb14-5887-bbbc-2868900d4753"},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"},"id":"fbb180f1-e03d-580e-b6b2-72a51db8a3ea"},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"},"id":"31b30552-417d-5cb3-a385-2ba938474bbf"},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"},"id":"ec180bef-ef40-521d-ac6b-9f30abcfef53"},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"},"id":"df129ef4-5001-5c2e-84bf-ee90e41af227"},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"},"id":"7fc5c006-6605-5432-9f94-0789645d355d"},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"},"id":"98914553-efc2-515a-b2d4-7eba07c0bfc5"},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"},"id":"6b9986fe-c5e8-5c79-b3db-31e120ddd392"},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"},"id":"748c611f-6eff-5719-abd8-7779f462e6dd"},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"},"id":"69bae138-e848-5a0c-a59d-deb23964f885"},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"},"id":"d99334fe-3434-552b-8a61-e0eb30248003"},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"},"id":"55c088b8-388b-5217-8021-fb99f880d1e1"},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"},"id":"377d0253-0edd-5b64-b2f5-fd713111de89"},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"},"id":"2952a571-bd4e-560e-a887-aa6402832b41"},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"},"id":"6d9760d4-7672-538e-b741-8a30e4c0f115"},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"},"id":"0d135879-f937-5410-9f1f-8ee2ec32e3e0"},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"},"id":"8235f87d-16a5-58aa-b28d-887a3ece02f4"},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"},"id":"7a028bb2-5044-59b8-bf6b-27ffdef4bdf0"}]},"allMdx":{"edges":[{"node":{"id":"7a6ee670-bba5-5f18-baa1-6fcdda49f8c7","frontmatter":{"date":"2023-01-16T00:00:00.000Z"}}},{"node":{"id":"e552c767-7d9e-52bd-9d3e-4c6ca527e24a","frontmatter":{"date":"2023-01-02T00:00:00.000Z"}}},{"node":{"id":"288568ed-1bb5-50c9-bae2-7c544f7dd4b3","frontmatter":{"date":"2022-11-28T00:00:00.000Z"}}},{"node":{"id":"c3a9d0c7-d9c1-503a-97bb-06217c70b470","frontmatter":{"date":"2022-11-11T00:00:00.000Z"}}},{"node":{"id":"fc5716a7-cb14-5887-bbbc-2868900d4753","frontmatter":{"date":"2022-10-30T00:00:00.000Z"}}},{"node":{"id":"fbb180f1-e03d-580e-b6b2-72a51db8a3ea","frontmatter":{"date":"2022-10-26T00:00:00.000Z"}}},{"node":{"id":"e17bb8a2-8b48-5bb2-8c7d-47c8ec7e1aec","frontmatter":{"date":"2022-10-14T00:00:00.000Z"}}},{"node":{"id":"31b30552-417d-5cb3-a385-2ba938474bbf","frontmatter":{"date":"2022-08-25T00:00:00.000Z"}}},{"node":{"id":"4060e5a3-6533-50ce-b421-7a109c3c55c4","frontmatter":{"date":"2022-08-16T00:00:00.000Z"}}},{"node":{"id":"ec180bef-ef40-521d-ac6b-9f30abcfef53","frontmatter":{"date":"2022-07-27T00:00:00.000Z"}}},{"node":{"id":"df129ef4-5001-5c2e-84bf-ee90e41af227","frontmatter":{"date":"2022-07-21T00:00:00.000Z"}}},{"node":{"id":"64529c38-681b-553c-9538-f1be3fb41416","frontmatter":{"date":"2022-07-05T00:00:00.000Z"}}},{"node":{"id":"8a93582a-1654-5408-adb1-2547cb585a28","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"7fc5c006-6605-5432-9f94-0789645d355d","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"1c549fa1-f8d2-59be-98a9-7277f4e2367e","frontmatter":{"date":"2022-04-06T00:00:00.000Z"}}},{"node":{"id":"98914553-efc2-515a-b2d4-7eba07c0bfc5","frontmatter":{"date":"2022-01-11T00:00:00.000Z"}}},{"node":{"id":"26fe963e-c04c-59cd-af74-b2e510987154","frontmatter":{"date":"2021-12-29T00:00:00.000Z"}}},{"node":{"id":"6b9986fe-c5e8-5c79-b3db-31e120ddd392","frontmatter":{"date":"2021-11-22T00:00:00.000Z"}}},{"node":{"id":"748c611f-6eff-5719-abd8-7779f462e6dd","frontmatter":{"date":"2021-10-29T00:00:00.000Z"}}},{"node":{"id":"69bae138-e848-5a0c-a59d-deb23964f885","frontmatter":{"date":"2021-09-24T00:00:00.000Z"}}},{"node":{"id":"d99334fe-3434-552b-8a61-e0eb30248003","frontmatter":{"date":"2021-09-17T00:00:00.000Z"}}},{"node":{"id":"55c088b8-388b-5217-8021-fb99f880d1e1","frontmatter":{"date":"2021-09-13T00:00:00.000Z"}}},{"node":{"id":"377d0253-0edd-5b64-b2f5-fd713111de89","frontmatter":{"date":"2021-08-31T00:00:00.000Z"}}},{"node":{"id":"13e3bc56-c56f-514d-be53-6566467c13b4","frontmatter":{"date":"2021-06-01T00:00:00.000Z"}}},{"node":{"id":"b9a9d532-8635-5bea-8287-c0c09465bf76","frontmatter":{"date":"2021-05-30T00:00:00.000Z"}}},{"node":{"id":"2952a571-bd4e-560e-a887-aa6402832b41","frontmatter":{"date":"2021-04-27T00:00:00.000Z"}}},{"node":{"id":"6d9760d4-7672-538e-b741-8a30e4c0f115","frontmatter":{"date":"2021-01-29T00:00:00.000Z"}}},{"node":{"id":"127d7aab-cdef-5e35-950d-397bb65e3ae4","frontmatter":{"date":"2020-12-21T00:00:00.000Z"}}},{"node":{"id":"0d135879-f937-5410-9f1f-8ee2ec32e3e0","frontmatter":{"date":"2020-12-15T00:00:00.000Z"}}},{"node":{"id":"8235f87d-16a5-58aa-b28d-887a3ece02f4","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}},{"node":{"id":"7a028bb2-5044-59b8-bf6b-27ffdef4bdf0","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}}]}},"pageContext":{"slug":"/reasonml-ways-with-types","title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","category":"engineering","email":"tlonist.sang@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","author":"김상현","email":"tlonist.sang@gmail.com","slug":"/reasonml-ways-with-types","tags":["ReasonML","object","variant","raw","dict","gadt","unbox"],"category":"engineering"}}},"staticQueryHashes":["318001574"]}