{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-feature-flags-v-1-index-mdx","path":"/feature-flags-1","result":{"data":{"post":{"slug":"/feature-flags-1","title":"Feature flags 적용 (1)","date":"2022년 10월 26일","tags":[{"name":"Greenlabs","slug":"greenlabs"},{"name":"feature-flags","slug":"feature-flags"}],"description":"Release Toggles 적용","canonicalUrl":null,"body":"\n<Author\n  email=\"kjw0323@gmail.com\"\n  name=\"김정우, 양정윤, 이낙원\"\n  description=\"재밌게 개발하자🍅\"\n  date=\"2022-10-26\"\n/>\n\n## 목차\n\n- [들어가며](#intro)\n- [소개](#what-is-feature-flags)\n  - [분류](#category-of-feature-flags)\n    - [출시 토글(Release Toggles)](#release-toggles)\n    - [실험 토글(Experiment Toggles)](#experiment-toggles)\n    - [운영 토글(Ops Toggles)](#ops-toggles)\n    - [승인 토글(Permission Toggles)](#permission-toggles)\n- [적용](#v1-release-toggles)\n- [설계](#design)\n- [구현](#impl)\n  - [프론트엔드](#impl-fe)\n  - [백엔드](#impl-be)\n- [효과](#impact)\n- [참조](#ref)\n\n## <a name=\"intro\"/>들어가며\n\n최근 수십명 규모로 빠르게 늘어난 팜모닝 조직에서는 개발 생산성에 문제가 생기고 있었습니다.\n\n- 여러가지 기능이 동시에 개발되면서 의존성이 생겼습니다. 이로 인해 브랜치 사이에서 의존성이 증가하고 코드 충돌이 길어졌습니다.\n- 큰 기능을 개발하면서 수명이 긴 브랜치들이 생기기 시작했습니다. 이는 코드 리뷰의 어려움을 가져왔고 코드 병합시 알 수 없는 두려움을 가지게 했습니다.\n\n추가로 아래와 운영적 문제점도 있었습니다.\n\n- 신규 기능을 출시할 때 코드 배포와 출시가 동시에 진행되다보니 업무 내 시간에 배포하고 업무 외 시간에 출시를 하는게 힘들었습니다.\n- 신규 기능 출시에 문제가 있을 때 이를 되돌리려면 재배포를 해야해서 약 10분정도의 시간이 소요되었습니다.\n\n개발자의 생산성 문제를 해결하기 위해서 최근에 [Trunk Based Developement](tbd)(이하 TBD)를 도입하였습니다. TBD는 트렁크(메인) 브랜치를 단일 소스로 하여 완벽하지 않은 기능을 부담없이 지속적으로 병합을 가능하게 합니다. 다만, 이 완벽하지 않은 기능을 비활성화하기 위해서 `Feature flags`(기능 플래그)의 필요합니다. 그래서 팜모닝팀에서는 이를 연구하고 적용하기로 했습니다.\n\n## <a name=\"what-is-feature-flags\"/>소개\n\n기능 플래그(혹은 기능 토글)는 코드의 변경 없이 설정만으로 시스템을 바꿀 수 있는 강력한 도구입니다. 아주 다양한 사용방법이 있고 이는 팀이 풀고자 하는 문제에 맞게 다양하게 분류할 수 있고 구현할 수 있습니다.\n\n예시를 들어보겠습니다.\n\n- 팀에서 신규 기능A를 개발하고 출시를 했습니다.\n- 이를 출시 했는데 레이턴시가 너무 높고 치명적인 버그가 발견되었습니다.\n- 이 때, 서버를 롤백하는 것이 아닌 플래그(출시 토글)를 이용해서 기능A를 바로 비활성화 시킬 수 있습니다.\n\n또 다른 예시입니다.\n\n- 팀에서 신규 기능B를 베타 서비스로 출시를 하려고 하는데, 실험적으로 베타 유저에게만 노출하고 싶습니다.\n- 이 때도 플래그(승인 토글)를 이용하면 베타 유저에게만 먼저 베타 기능B를 노출시킬 수 있습니다.\n\n어떤가요? 현재의 팜모닝팀에 알맞은 필요성이라 생각을 했습니다. 그럼 기능 플래그에 대하여 조금 더 자세히 알아보겠습니다.\n\n### <a name=\"category-of-feature-flags\"/>분류\n\n대략 기능 플래그가 무엇인지는 알겠습니다. 여러 시나리오에 맞게 다양한 방식으로 플래그들을 구현할 수 있는데요. [마틴 파울러의 블로그](feature_flags)에서는 피처 플래그를 4가지로 분류하였습니다. 그의 분류법에 따라서 각각에 대하여 간단히 살펴보겠습니다.\n\n#### <a name=\"release-toggles\"/>출시 토글(Release Toggles)\n\nContinuous Delivery를 실행하고자 하는 팀을 위해 TBD를 가능하게 해주는 기능 플래그입니다. main 브랜치에 작업 중인 피처를 가질 수 있도록 해주고 언제든지 운영 환경에 배포할 수 있도록 도와줍니다. 출시 토글은 완전하지 않고, 테스트되지 않은 코드를 켜지지 않은 상태로 프로덕션 코드에 가지고 있을 수 있게 해줍니다.\n\n#### <a name=\"experiment-toggles\"/>실험 토글(Experiment Toggles)\n\n실험 토글은 여러가지 변수 혹은 `A/B testing` 등에 활용될 수 있습니다. 시스템(응용 프로그램)의 사용자는 어떠한 집단에 위치되고, toggle router는 해당 유저가 속한 특정 코드에 속하게 됩니다. 각기 다르게 적용된 코드에 따른 유저 행동을 추적하여 팀에게 `데이터에 기반한 의사결정`을 할 수 있도록 합니다.\n\n#### <a name=\"ops-toggles\"/>운영 토글(Ops Toggles)\n\n운영 토글은 시스템 동작의 운영적 측면을 제어하는데 사용됩니다. 시스템 운영자가 필요에 따라 해당 기능을 비활성화하고 싶을 때 사용할 수 있고 새로운 기능을 출시할 때에도 사용하 할 수 있습니다. 대부분의 운영 토글은 수명이 짧고, 운영에 확신이 생기면 플래그는 폐기되는게 좋습니다.\n\n#### <a name=\"permission-toggles\"/>승인 토글(Permission Toggles)\n\n특정 사용자가 받는 기능이나 제품 경험을 변경하는데 사용되는 플래그입니다. 예를 들어 승인 토글을 이용하여 프리미엄 고객에게만 제공되는 프리미엄 기능 혹은 알파 기능, 베타 기능에 대하여 내부 유저나 베타 유저에게만 노출되도록 할 수 있습니다. 이는 몇가지 측면에서 [Canary Release](canary)와 비슷하지만, 카나리 배포는 무작위 유저에게 노출되는 반면에 승인 토글은 특정 유저에게 노출이 됩니다.\n\n## <a name=\"v1-release-toggles\"/>적용\n\n그린랩스의 팜모닝팀에서 당장 필요성이 있는 출시 토글부터 먼저 적용해보고자 했습니다. 이를 통해 배포와 출시를 분리하고 운영에 도움을 주고자 합니다.\n\n## <a name=\"design\"/>설계\n\n클라이언트에서 서버로 기능 플래그의 상태를 요청하고 활성화 상태에 따라해당 서비스를 노출할지 결정합니다. 그린랩스에서는 [GraphQL](graphql)을 사용하며 아래와 같이 스키마를 구성합니다.\n\n```graphql\ndirective @feature(type: FeatureType!) on FIELD_DEFINITION\n\nenum FeatureType {\n  CHATTING\n  ...\n}\n\ntype Feature {\n  type: FeatureType!\n  description: String!\n  active: Boolean!\n}\n\ntype Query {\n  features: [Feature!]!\n}\n```\n\n설정값은 데이터베이스에 key-value 값으로 저장할 수 있으며 JSON 형식으로 아래처럼 값을 저장하고 GraphQL `features` 요청이 들어왔을 때 이를 그대로 응답합니다.\n\n```json\n[\n   {\n      \"type\": \"CHATTING\",\n      \"active\": false,\n      \"description\": \"채팅\"\n   },\n   ...\n]\n```\n\n## <a name=\"impl\"/>구현\n\n### <a name=\"impl-fe\"/>프론트엔드\n\n```graphql\nquery Features {\n  features {\n    type\n    description\n    active\n  }\n}\n```\n\n프론트엔드에서는 `Provider` 를 작성하여 query 한 `features` field를 context에 담아주고, hook을 사용하여 원하는 기능 플래그의 Boolean값을 호출할 수 있도록 구현합니다.\n\n```rescript\nuseFeatureFlag : RelaySchemaAssets_graphql.enum_FeatureType ⇒ bool\n```\n\n<details>\n<summary>Provider 구현 예시</summary>\n<div markdown=\"1\">\n\n```rescript\ntype features = FeatureHelper_Query_graphql.Types.response_features\n\ntype t = {features: array<features>}\n\nmodule Query = %relay(`\n query FeatureHelper_Query {\n   features {\n     featureType: type\n     active\n     description\n   }\n }\n`)\n\nlet context = React.createContext(None)\nlet useContext = () => React.useContext(context)->Option.getExn\n\nmodule Provider = {\n  let provider = React.Context.provider(context)\n\n  module CreateElement = {\n    @react.component\n    let make = (~children, ~queryRef) => {\n      let {features} = Query.usePreloaded(~queryRef, ())\n\n      let contextValue = React.useMemo0(() => {\n        features: features,\n      })\n\n      React.createElement(provider, {\"value\": Some(contextValue), \"children\": children})\n    }\n  }\n\n  @react.component\n  let make = (~children) => {\n    let (queryRef, loadQuery, _) = Query.useLoader()\n\n    React.useEffect0(() => {\n      loadQuery(~variables=(), ())\n      None\n    })\n\n    {\n      queryRef->Option.mapWithDefault(React.null, queryRef' =>\n        <CreateElement queryRef=queryRef'> {children} </CreateElement>\n      )\n    }\n  }\n}\n\nlet useFeatureFlag = flagType => {\n  let commonContext = useContext()\n  commonContext.features\n  ->Array.getBy(feature => feature.featureType == flagType)\n  ->Option.mapWithDefault(false, feature' => feature'.active)\n}\n\n```\n\n</div>\n</details>\n\n기능 플래그가 달려 있는 기능의 경우, hook을 호출한 후 분기 처리를 통해 해당 기능이 노출될지 말지를 결정할 수 있습니다.\n\n```rescript\n@react.component\nlet make = () => {\n  let chatFeatureFlag = FeatureHelper.useFeatureFlag(#CHATTING)\n\n  chatFeatureFlag\n    ? <Container/>\n    : React.null\n}\n```\n\n### <a name=\"impl-be\"/>백엔드\n\n프론트엔드에서 화면을 노출하는 것과 별개로 악의적 공격이나 타이밍 이슈에 의한 API 호출에 대비하여 플래그가 비활성화 상태일 때 잘못된 요청임을 알려줘야합니다. 어플리케이션 레벨에서 선언적으로 필터링 로직을 추가하기 위해 GraphQL의 커스텀 [directives](graphql_directives)를 이용하여 이를 정의하고자 했고 위의 스키마는 아래처럼 디렉티브를 달아주었습니다.\n\n```graphql\ntype Query {\n  \"@feature type이 active인 경우에만 정상 동작하고 아닌 경우 에러 응답\"\n  chatChannels(postId: ID!, first: Int, after: String): ChatChannelConnection @feature(type: FeatureType.CHATTING)\n  ...\n}\n```\n\nGraphQL 필드에 `@feature` 디렉티브가 있으면 서버에서 플래그 상태를 검사하고 에러를 반환하도록 하였습니다.\n\n```json\n{\n  \"data\": null,\n  \"errors\": [\n    {\n      \"message\": \"The FeatureType.CHATTING flag was inasctivated\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ],\n      \"path\": [\"chatChannels\"]\n    }\n  ]\n}\n```\n\n## <a name=\"impact\"/>효과\n\n팜모닝팀에서는 빠르게 기능 플래그를 도입하였고 세가지의 효과를 가졌습니다.\n\n1. 배포와 출시를 분리하였습니다. 코드 배포는 되었지만 출시는 원하는 날짜와 시간에 할 수 있게 되었습니다.\n2. 버그 대응이 빨라졌습니다. 플래그가 달린 기능에 대하여 버그가 있을 때 1초 이내에 해당 기능을 비활성화 시킬 수 있게 되었습니다.\n3. 버전 관리가 더 간편해졌습니다. 기존에는 큰 기능을 개발할 때 git에서 수명이 긴 브랜치가 생길 때도 있었는데, 현재는 빠르게 병합할 수 있는 환경이 되었습니다.\n\n팜모닝의 사용자수는 점점 늘어나고 있어 유저 유형의 세분화가 필요해지고 있습니다. 그에 따라 사용자의 행동 패턴에 따른 맞춤 서비스를 제공할 예정입니다. 그래서 팜모닝팀의 다음 계획은 승인 토글을 도입하는 것입니다. 이를 위한 방법 중 하나로 알파, 베타, 혹은 프리미엄 서비스들을 선택적으로 특정 집단에만 제공하고 선택적으로 운영이 가능하게 하려고 합니다. 이에 대한 내용은 Feature flags 2부에서 뵙겠습니다 :)\n\n## <a name=\"ref\"/>참조\n\n- [마틴파울러의 기능 플래그 설명](feature_flags)\n- [아틀라시안의 기능 플래그 설명](https://www.atlassian.com/continuous-delivery/principles/feature-flags)\n\n[feature_flags]: https://martinfowler.com/articles/feature-toggles.html\n[graphql]: https://graphql.org/\n[graphql_directives]: https://www.apollographql.com/docs/apollo-server/schema/directives/\n[tbd]: https://trunkbaseddevelopment.com/\n[canary]: https://martinfowler.com/bliki/CanaryRelease.html\n","excerpt":"목차 들어가며소개\n분류\n출시 토글(Release Toggles)실험 토글(Experiment Toggles)운영 토글(Ops Toggles)승인 토글(Permission Toggles)\n적용설계구현\n프론트엔드백엔드\n효과…","banner":null,"id":"1b119820-ee60-5830-bdc8-eeecb5c1a27f","email":"kjw0323@gmail.com"},"userFilterAllMdx":{"nodes":[]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"}},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"}},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"}},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"}},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"}},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"}},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"}},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"}},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"}},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"}},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"}},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"}},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"}},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"}},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"}},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"}},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"}},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"}}]}},"pageContext":{"slug":"/feature-flags-1","title":"Feature flags 적용 (1)","category":"engineering","email":"kjw0323@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","description":"Release Toggles 적용","author":"김정우, 양정윤, 이낙원","email":"kjw0323@gmail.com","slug":"/feature-flags-1","tags":["Greenlabs","feature-flags"],"category":"engineering"}}},"staticQueryHashes":["3090400250","318001574"]}