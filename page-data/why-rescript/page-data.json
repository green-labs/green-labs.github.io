{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-namenu-green-tech-blog-content-posts-reasonml-and-rescript-index-mdx","path":"/why-rescript","result":{"data":{"mdx":{"internal":{"content":null,"description":null,"ignoreType":null,"mediaType":null,"contentFilePath":"/Users/namenu/green/tech-blog/content/posts/reasonml-and-rescript/index.mdx"},"frontmatter":{"slug":"/why-rescript","email":"kimchhickey@gmail.com","tags":["ReasonML","ReScript","Bucklescript"],"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","date":"2021년 1월 29일","category":"engineering","author":"양성민"},"body":"\n## 시작하며\n\n> **_그린랩스에서 리스크립트(ReScript) 공식 문서를 한글로 번역해서 공개합니다._**\n>\n> **_[(https://green-labs.github.io/rescript-in-korean/)](https://green-labs.github.io/rescript-in-korean/)_**\n\n현재 그린랩스에서는 ReasonML로 웹 개발을 하고 있습니다. 하지만 미래에 리스크립트로 넘어가려고 합니다. 웹 개발에 사용하는 경우 ReasonML보다 리스크립트가 더 적합하다고 생각하기 때문입니다. 이번 포스트에서는 리스크립트가 무엇이며, ReasonML 과의 차이점은 어떤 것이 있는지 살펴봅니다. 그리고 그린랩스가 리스크립트로 전환하려는 의사 결정을 하게 된 과정에 대해서 설명하려고 합니다.\n\n## ReasonML? 버클스크립트? 리스크립트?\n\nReasonML로 웹 개발을 하는 과정은 다음과 같습니다.\n\n1. ReasonML 문법으로 코드 작성\n2. 작성한 ReasonML 코드를 자바스크립트로 변환\n3. 변환된 자바스크립트 코드를 브라우저나 노드 환경에서 실행\n\n위의 과정에서 버클스크립트는 ReasonML 코드를 자바스크립트 코드로 변환하는 핵심 역할을 합니다.\n\n작년 8월, 공식적으로 [버클스크립트(BuckleScript)는 리스크립트(ReScript)로 이름을 바꿨습니다.](https://rescript-lang.org/blog/bucklescript-is-rebranding) 지난 수 년간 버클스크립트는 분명한 성과가 있었지만, 가지고 있는 문제 또한 명확했는데, 버클스크립트 개발진들은 버클스크립트가 가지고 있는 문제를 해결하고자 이름을 바꾸고 새로운 프로젝트의 시작을 선언했습니다.\n\n## 버클스크립트의 성과\n\n버클스크립트는 OCaml을 컴파일해서, 빠르고 읽기 좋은 자바스크립트 코드를 생성해보자는 아이디어에서 출발했습니다. 그 이후, 버클스크립트 생태계 위에서 ReasonML이 탄생했습니다. 수년이 지난 지금, 버클스크립트는 웹 생태계가 겪고 있는 다양한 문제들의 해결하고 있습니다. 다음은 버클스크립트가 이룬 성과들입니다.\n\n- 프론트엔드 개발을 위한 빠르고 믿을만한 빌드 시스템\n- 타입 안정성을 가진 라이브러리(bs-\\*)를 위한 생태계\n- 믿고 쓸 수 있는(production-ready) 표준 라이브러리 밸트(Belt)\n\n위는 분명히 ReasonML과 버클스크립트를 선택한 개발자들만이 누릴 수 있는 큰 장점인 반면 한계 또한 명확했습니다.\n\n## 버클스크립트와 ReasonML의 문제\n\n많은 사람들이 버클스크립트에 매력을 느끼고 사용을 시작했지만 문제가 하나 있었습니다. 바로 처음 시작하는 사람들이 너무나 많은 것을 배워야 한다는 점입니다. 그에 따라 중도에 포기하는 사람이 많았습니다.\n\n버클스크립트를 사용하기 위해서는 OCaml의 기본 철학을 개념적으로 이해해야 하고, ReasonML 문법을 알아야 합니다. 또한 자바스크립트 코드를 생성할 때 필요한 버클스크립트 고유의 특징 또한 배워야 합니다. 예를 들어 한 개발자가 ReasonReact 애플리케이션을 만들기 위해서는 다음의 나열된 것들을 두루두루 알고 있어야 합니다.\n\n- 자바스크립트와 리액트\n- OCaml 언어의 기본 철학\n- ReasonML 문법\n- 버클스크립트의 자바스크립트 호환 문법\n- 버클스크립트의 빌드 시스템\n- ReasonReact만의 특별한 문법\n\n커뮤니티에서도 ReasonML의 진입 장벽이 높다는 이야기가 여러 차례 나왔습니다. [Ahrefs](https://ahrefs.com/)에서 Reason 및 ReasonReact로 포팅을 한 후에 [1년 반 동안 제품에 ReasonML을 사용한 소감](https://tech.ahrefs.com/one-and-a-half-years-of-reasonml-in-production-2250cf5ba63b)을 팀원들을 대상으로 인터뷰한 적이 있는데, 복수의 팀원들이 *ReasonML과 버클스크립트는 정말 훌륭하지만, 배우기가 쉽지 않았다*고 언급했습니다.\n\n이런 지적을 수용해 ReasonML과 버클스크립트 팀은 더욱더 문서화를 열심히 했습니다. 심지어 공식 웹사이트에 *새롭게 시작하는 사람들을 위한 예제[^1]*까지 생겼습니다. 이런 노력은 분명히 칭찬받을만한 것이었지만 문제는 쉽게 해결되지 않았습니다. 이런 상황에 대해 버클스크립트 팀은 \"이상하게도 문서화를 하면 할수록 사람들은 더욱 힘들어하는 역설적인 상황이 반복되었다\"라고 회고했습니다.\n\n## 리브랜딩: 리스크립트(ReScript)\n\n버클스크립트 팀은 위와 같은 진입 장벽을 인정했고, 문서화로 해결할 수 없는 이 상황을 받아들이기로 했습니다. 그리고 문제를 해결하기로 했습니다. 그 결과 리스크립트가 탄생했습니다. 파편화된 생태계와 문서들을 하나로 통합하여 혼란을 줄이고, 보다 친절한 가이드를 제공하고자 했습니다. 결정적으로 그들이 생각했던 가장 중요한 목표는 바로 개발자가 리스크립트 하나만 알면 되게 하자는 것입니다.\n\n리스크립트 팀에서 공식적으로 언급한 목표는 다음과 같습니다.\n\n- 컴파일러와 빌드시스템\n- 독자적인 문법(dedicated syntax)\n- 에디터 지원\n- 하나의 문서([https://rescript-lang.org](https://rescript-lang.org))\n- 하나의 통합된 포럼\n\n여기서 주목해야 할 점은 ReasonML과 다른 독자적인 문법(dedicated syntax)이 생긴다는 것입니다. 이것은 기존에 ReasonML을 사용해 웹 개발을 했던 많은 회사들과 개발자들에게 당황스러운 발표였습니다. 아마도 버클스크립트 팀에 대한 신뢰와는 별개로 새로운 언어 문법을 만든다는 것이 주는 무게감이 남다르기 때문인 것 같습니다. 이 발표 이후 TinyMCE라는 유명한 위지윅 에디터를 만드는 팀에서도 이 부분을 언급했는데, 그들은 리스크립트가 안정적이게 될 때까지, [ReasonML로 개발하는 것을 유지하고, 리스크립트의 발전을 지켜보겠다고 이야기했습니다.](https://www.tiny.cloud/blog/tinymce-reasonml/)\n\n사실 리브랜딩 이전에도 버클스크립트는 [독자적인 문법을 추가한 적이 있었는데,](https://rescript-lang.org/blog/bucklescript-8-1-new-syntax) 아마도 이러한 시도들이 리스크립트의 탄생에 대한 복선이었던 것 같습니다.\n\n<div>\n  <img src=\"./to_rescript.jpg\" alt=\"to_rescript\" />\n</div>\n*출처: https://rescript-lang.org/blog/new-rescript-logo\n\n## 리스크립트와 ReasonML을 비교했을 때 다른 점\n\n리스크립트와 ReasonML을 비교했을 때 다른 점은 그린랩스에서 번역한 [리스크립트 문법으로 변경하기](https://green-labs.github.io/rescript-in-korean/Overview/04-Migrate-to-ReScript-Syntax) 페이지를 읽어보면 좋습니다. 주요한 변경 사항만 간단히 살펴보면 다음과 같습니다.\n\n- 세미 콜론을 찍지 않아도 됩니다.\n- `if`, `switch`, `try`에 괄호가 필요 없습니다.\n- 타입 인자 문법이 `option(int)`에서 `option<int>`와 같이 바뀌었습니다.\n- 백틱을 사용하는 문자열이 생겼습니다. 줄바꿈과 유니코드를 지원합니다.\n- 배열 문법이 `[|1, 2, 3|]`에서 `[1, 2, 3]`로 바뀌었는데, 자바스크립트에서는 배열이 가장 기본적인 자료 구조이기 때문입니다.\n- 리스트 문법이 `[1, 2, 3]`에서 `list{1, 2, 3}`으로 바뀌었습니다.\n- 일급 모듈의 문법이 `(module S: Student)` 에서 `module(S: Student)`로 바뀌었습니다.\n- 객체에 접근하는 방법이 `settings##visible #= true`에서 `settings[\"visible\"] = true`로 바뀌었습니다.\n- 재귀적인 타입을 선언하려면 이제 명시적으로 작성해주어야 합니다. 타입 선언이 기본적으로 재귀적일 수 없도록 되어있습니다.\n\n원래 ReasonML은 네이티브 환경과 자바스크립트 환경, 두 가지를 모두 지원하는 언어입니다. 각각의 컴파일러가 공유하는 지점이 있고, 백엔드에 따라서 네이티브 빌드 결과물이 나오기도 하고, 자바스크립트 코드가 나오기도 하는 것입니다. 두 개의 플랫폼을 지원한다는 것은 매우 좋은 일이지만 그에 따른 단점도 있었습니다. 두 개의 플랫폼을 고려하다 보면 문법(Syntax)을 보다 중립적으로 선택해야 했고, 호스트에 최적화된 기능을 언어 자체에 녹이기도 힘들었습니다.\n\n반면에 리스크립트는 자바스크립트에서 배열이 가장 기본적인 자료 구조이기 때문에 배열의 문법을 리스트의 문법보다 편하게 만들었고, 객체에 접근하는 방법을 자바스크립트 객체에 접근하는 방법과 비슷하게 바꿨습니다. 이제 더 이상 네이티브 환경을 생각하지 않아도 되기 때문에 보다 적극적으로 자바스크립트 개발자들에게 헌신적인 문법을 제공할 수 있게 된 것입니다.\n\n또한 기존에 불편한 점으로 지적되었던 유니코드를 지원하는 점 등은 개발자들이 매우 환영할만한 일입니다.\n\n**[Reason 문법 예]**\n\n```reason\nmodule Button = {\n  [@react.component]\n  let make = (~count: int, ~user) =>\n    {\n      let times =\n        switch (count) {\n        | 1 => \"once\"\n        | n => Belt.Int.toString(n) ++ \" times\"\n        };\n      let username = user##name;\n      let msg = (username ++ {js|님, 클릭해주세요. |js}) ++ times;\n\n      <button> msg->React.string </button>;\n    };\n};\n```\n\n**[리스크립트 문법 예]**\n\n```rescript\nmodule Button = {\n  @react.component\n  let make = (~count: int, ~user) => {\n    let times = switch count {\n    | 1 => \"once\"\n    | n => Belt.Int.toString(n) ++ \" times\"\n    }\n    let username = user[\"name\"]\n    let msg = username ++ `님, 클릭해주세요. ` ++ times\n\n    <button> {msg->React.string} </button>\n  }\n}\n```\n\n## ReasonML의 미래\n\n그럼 ReasonML은 리스크립트의 독자적인 노선을 어떻게 생각할까요? 그리고 ReasonML의 미래는 어떻게 되는 것일까요? 이에 대한 [Jordan Walke를 포함한 ReasonML 팀의 답변을 정리해보면 다음과 같습니다.](https://github.com/reasonml/reason/issues/2634)\n\n1. 만약 네이티브 애플리케이션을 개발한다면, ReasonML은 좋은 선택지가 될 것입니다. 현재 Jordan Walke를 비롯한 많은 개발자들이 ReasonML이 네이티브 환경에서 실행되는 환경을 개선하는 프로젝트에 집중[^2]하고 있습니다.\n2. 만약 네이티브와 브라우저를 동시에 지원해야 하는 상황이라면, ReasonML은 좋은 선택지가 될 것입니다. 리스크립트가 호환을 약속했고, 또 리스크립트가 없더라도, [js_of_ocaml](https://ocsigen.org/js_of_ocaml/3.7.0/manual/overview)이라는 프로젝트가 있기 때문에, 여러분의 프로젝트가 네이티브와 자바스크립트를 모두 고려한다면, 여전히 ReasonML은 좋은 선택지입니다.\n3. 만약 네이티브 빌드가 필요가 없고, 자바스크립트 환경만 고려한다면 버클스크립트를 사용했듯, 리스크립트를 계속 사용하면 됩니다.\n\n## 그린랩스의 선택 과정\n\n작년 8월에 팀이 막 꾸려지고 프로젝트를 시작할 때, 리스크립트가 나왔습니다. 그 당시 리스크립트는 에디터 지원이 많이 미숙했고, 특히 언어가 막 나온 상태였기 때문에 레퍼런스가 전무했습니다. 그에 따라 오로지 공식 문서를 참고할 수밖에 없었는데, 그때의 공식 문서는 내용이 많이 부실했습니다.\n\n그래서 우선 ReasonML로 프로젝트를 시작하기로 결정했습니다. 최신 리스크립트 컴파일러를 썼지만 ReasonML 문법을 사용했습니다. ReasonML은 상대적으로 레퍼런스가 많았고, 리스크립트 컴파일러가 ReasonML 문법에 대한 호환이 완벽하게 지켜졌기 때문에 문제가 없었습니다.\n\n6개월 정도가 지난 지금, 리스크립트는 에디터 지원도 충분해졌고, 특히 공식 문서가 굉장히 탄탄해졌습니다. 그래서 최근에 합류하신 분들은 리스크립트로 온보딩을 합니다. 또한 얼마 전에 작은 프로젝트 하나를 리스크립트로 구현하고 배포했습니다. 회사 서비스에 반영했던 첫 번째 리스크립트 프로젝트였습니다.\n\n현재 ReasonML/리스크립트를 모두 사용하고 있습니다. 강조하고 싶은 점은 리스크립트로 온보딩하신 분들이 기존 ReasonML 프로젝트에 기여하시는 것도 큰 장벽이 없었다는 것입니다. 위에 나열한 차이점만 존재할 뿐, 두 언어의 뿌리는 같기 때문입니다. 마찬가지로 기존 구성원들이 새로 입사하신 분들의 리스크립트 코드를 리뷰하는데도 무리가 없었습니다. 그럼에도 불구하고 조만간 전체 프로젝트를 리스크립트로 넘어갈 것입니다. 웹 개발에는 리스크립트가 더 적합하기 때문입니다.\n\n이러한 경험을 바탕으로 이제부터 그린랩스가 국내 리스크립트 생태계에 기여하고자 합니다. 그 첫번째 프로젝트로 공식 문서를 번역해 공개하게 되었습니다.\n\n> **_[리스크립트(ReScript) 한글 공식 문서 (https://green-labs.github.io/rescript-in-korean/)](https://green-labs.github.io/rescript-in-korean/)_**\n\n이 문서가 리스크립트를 시작하는 한국 개발자분들께 많은 도움이 되길 바랍니다.\n\n<br />\n<br />\n<Author\n  email=\"kimchhickey@gmail.com\"\n  name=\"양성민\"\n  description=\"백엔드 엔지니어\"\n  date=\"2021-01-29\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [https://rescript-lang.org/blog/bucklescript-is-rebranding](https://rescript-lang.org/blog/bucklescript-is-rebranding)\n- [https://reasonml.chat/t/rescript-and-the-future-of-reasonml/2559](https://reasonml.chat/t/rescript-and-the-future-of-reasonml/2559)\n- [https://reasonml.org/](https://reasonml.org/)\n- [https://forum.rescript-lang.org/t/rescript-frequently-asked-questions/59](https://forum.rescript-lang.org/t/rescript-frequently-asked-questions/59)\n- [https://rescript-lang.org/blog/bucklescript-8-1-new-syntax](https://rescript-lang.org/blog/bucklescript-8-1-new-syntax)\n- [https://www.tiny.cloud/blog/tinymce-reasonml/](https://www.tiny.cloud/blog/tinymce-reasonml/)\n\n[^1]: 현재는 페이지가 리스크립트로 옮겨져서 찾을 수 없습니다. 구글에서 \"Newcomers Examples ReasonML\"을 검색하시면 그 흔적을 찾을 수 있습니다.\n[^2]: 실제로 Jordan Walke는 발표를 통해서 현재 네이티브에서 동작하는 ReasonML 프로젝트에 더 많은 시간을 쏟고 있다고 이야기했습니다.\n","id":"6d9760d4-7672-538e-b741-8a30e4c0f115"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"},"id":"8235f87d-16a5-58aa-b28d-887a3ece02f4"}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"모노레포 - 마이크로 아키텍처를 지향하며","date":"2023-01-16T00:00:00.000Z","author":"최경식","category":"engineering","description":"모노레포에 대해서 들어보셨나요? 프론트엔드에서 마이크로 아키텍처를 지향하려면 어떻게 해야할까요?","slug":"/monorepo-microfrontend"},"id":"7a6ee670-bba5-5f18-baa1-6fcdda49f8c7"},{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"},"id":"fc5716a7-cb14-5887-bbbc-2868900d4753"},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"},"id":"fbb180f1-e03d-580e-b6b2-72a51db8a3ea"},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"},"id":"31b30552-417d-5cb3-a385-2ba938474bbf"},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"},"id":"ec180bef-ef40-521d-ac6b-9f30abcfef53"},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"},"id":"df129ef4-5001-5c2e-84bf-ee90e41af227"},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"},"id":"7fc5c006-6605-5432-9f94-0789645d355d"},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"},"id":"98914553-efc2-515a-b2d4-7eba07c0bfc5"},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"},"id":"6b9986fe-c5e8-5c79-b3db-31e120ddd392"},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"},"id":"748c611f-6eff-5719-abd8-7779f462e6dd"},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"},"id":"69bae138-e848-5a0c-a59d-deb23964f885"},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"},"id":"d99334fe-3434-552b-8a61-e0eb30248003"},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"},"id":"55c088b8-388b-5217-8021-fb99f880d1e1"},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"},"id":"377d0253-0edd-5b64-b2f5-fd713111de89"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"},"id":"13e3bc56-c56f-514d-be53-6566467c13b4"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"},"id":"b9a9d532-8635-5bea-8287-c0c09465bf76"},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"},"id":"2952a571-bd4e-560e-a887-aa6402832b41"},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"},"id":"127d7aab-cdef-5e35-950d-397bb65e3ae4"},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"},"id":"0d135879-f937-5410-9f1f-8ee2ec32e3e0"},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"},"id":"7a028bb2-5044-59b8-bf6b-27ffdef4bdf0"}]},"allMdx":{"edges":[{"node":{"id":"7a6ee670-bba5-5f18-baa1-6fcdda49f8c7","frontmatter":{"date":"2023-01-16T00:00:00.000Z"}}},{"node":{"id":"e552c767-7d9e-52bd-9d3e-4c6ca527e24a","frontmatter":{"date":"2023-01-02T00:00:00.000Z"}}},{"node":{"id":"288568ed-1bb5-50c9-bae2-7c544f7dd4b3","frontmatter":{"date":"2022-11-28T00:00:00.000Z"}}},{"node":{"id":"c3a9d0c7-d9c1-503a-97bb-06217c70b470","frontmatter":{"date":"2022-11-11T00:00:00.000Z"}}},{"node":{"id":"fc5716a7-cb14-5887-bbbc-2868900d4753","frontmatter":{"date":"2022-10-30T00:00:00.000Z"}}},{"node":{"id":"fbb180f1-e03d-580e-b6b2-72a51db8a3ea","frontmatter":{"date":"2022-10-26T00:00:00.000Z"}}},{"node":{"id":"e17bb8a2-8b48-5bb2-8c7d-47c8ec7e1aec","frontmatter":{"date":"2022-10-14T00:00:00.000Z"}}},{"node":{"id":"31b30552-417d-5cb3-a385-2ba938474bbf","frontmatter":{"date":"2022-08-25T00:00:00.000Z"}}},{"node":{"id":"4060e5a3-6533-50ce-b421-7a109c3c55c4","frontmatter":{"date":"2022-08-16T00:00:00.000Z"}}},{"node":{"id":"ec180bef-ef40-521d-ac6b-9f30abcfef53","frontmatter":{"date":"2022-07-27T00:00:00.000Z"}}},{"node":{"id":"df129ef4-5001-5c2e-84bf-ee90e41af227","frontmatter":{"date":"2022-07-21T00:00:00.000Z"}}},{"node":{"id":"64529c38-681b-553c-9538-f1be3fb41416","frontmatter":{"date":"2022-07-05T00:00:00.000Z"}}},{"node":{"id":"8a93582a-1654-5408-adb1-2547cb585a28","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"7fc5c006-6605-5432-9f94-0789645d355d","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"1c549fa1-f8d2-59be-98a9-7277f4e2367e","frontmatter":{"date":"2022-04-06T00:00:00.000Z"}}},{"node":{"id":"98914553-efc2-515a-b2d4-7eba07c0bfc5","frontmatter":{"date":"2022-01-11T00:00:00.000Z"}}},{"node":{"id":"26fe963e-c04c-59cd-af74-b2e510987154","frontmatter":{"date":"2021-12-29T00:00:00.000Z"}}},{"node":{"id":"6b9986fe-c5e8-5c79-b3db-31e120ddd392","frontmatter":{"date":"2021-11-22T00:00:00.000Z"}}},{"node":{"id":"748c611f-6eff-5719-abd8-7779f462e6dd","frontmatter":{"date":"2021-10-29T00:00:00.000Z"}}},{"node":{"id":"69bae138-e848-5a0c-a59d-deb23964f885","frontmatter":{"date":"2021-09-24T00:00:00.000Z"}}},{"node":{"id":"d99334fe-3434-552b-8a61-e0eb30248003","frontmatter":{"date":"2021-09-17T00:00:00.000Z"}}},{"node":{"id":"55c088b8-388b-5217-8021-fb99f880d1e1","frontmatter":{"date":"2021-09-13T00:00:00.000Z"}}},{"node":{"id":"377d0253-0edd-5b64-b2f5-fd713111de89","frontmatter":{"date":"2021-08-31T00:00:00.000Z"}}},{"node":{"id":"13e3bc56-c56f-514d-be53-6566467c13b4","frontmatter":{"date":"2021-06-01T00:00:00.000Z"}}},{"node":{"id":"b9a9d532-8635-5bea-8287-c0c09465bf76","frontmatter":{"date":"2021-05-30T00:00:00.000Z"}}},{"node":{"id":"2952a571-bd4e-560e-a887-aa6402832b41","frontmatter":{"date":"2021-04-27T00:00:00.000Z"}}},{"node":{"id":"6d9760d4-7672-538e-b741-8a30e4c0f115","frontmatter":{"date":"2021-01-29T00:00:00.000Z"}}},{"node":{"id":"127d7aab-cdef-5e35-950d-397bb65e3ae4","frontmatter":{"date":"2020-12-21T00:00:00.000Z"}}},{"node":{"id":"0d135879-f937-5410-9f1f-8ee2ec32e3e0","frontmatter":{"date":"2020-12-15T00:00:00.000Z"}}},{"node":{"id":"8235f87d-16a5-58aa-b28d-887a3ece02f4","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}},{"node":{"id":"7a028bb2-5044-59b8-bf6b-27ffdef4bdf0","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}}]}},"pageContext":{"slug":"/why-rescript","title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","category":"engineering","email":"kimchhickey@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript","author":"양성민","email":"kimchhickey@gmail.com","date":"2021-01-29T00:00:00.000Z","tags":["ReasonML","ReScript","Bucklescript"],"category":"engineering"}}},"staticQueryHashes":["318001574"]}