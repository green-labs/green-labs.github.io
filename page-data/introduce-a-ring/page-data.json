{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-introduce-a-ring-index-mdx","path":"/introduce-a-ring","result":{"data":{"mdx":{"internal":{"content":null,"description":null,"ignoreType":null,"mediaType":null,"contentFilePath":"/Users/hyejin/Documents/tech-blog/content/posts/introduce-a-ring/index.mdx"},"frontmatter":{"slug":"/introduce-a-ring","email":"dw.kim@greenlabs.co.kr","tags":["클로저","웹 애플리케이션 라이브러리","Ring","튜토리얼"],"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","date":"2021년 9월 17일","category":"engineering","author":"김동욱"},"body":"\n## <a name=\"contents\"/>목차\n\n- [Ring 이란](#what-is-ring)\n- [간단한 요청 - 응답](#simple-request-and-response)\n- [로컬호스트에 웹서버 띄우기](#launch-web-server-in-localhost)\n- [미들웨어 설정해보기](#setting-up-middleware)\n- [정적 자원을 서빙 해보기](#serving-static-resources)\n- [파라미터들 다루기](#params)\n- [세션과 쿠키](#session-and-cookie)\n- [마치며](#end-of-document)\n\n## <a name=\"what-is-ring\"/>Ring 이란\n\nRing은 파이썬의 WSGI(Web Server Gateway Interface)에 영감을 받은 클로저 웹 애플리케이션 라이브러리입니다.\n\nWSGI는 웹 서버와 파이썬 애플리케이션 사이의 표준 인터페이스로서, 웹 서버에 들어온 요청을 애플리케이션으로 전달하는 역할을 합니다.\n클로저에서는 Ring이 이 일을 담당합니다.\nRing은 저수준 인터페이스(handler, middleware, request, response 등)만을 제공합니다.\n고수준 인터페이스(routing 등)를 사용하려면 Ring을 기반으로 하는 다른 라이브러리들을 사용해야 합니다.\n\n이 튜토리얼에서는 Ring의 저수준 인터페이스들을 이용하여 간단한 웹 애플리케이션을 만들어보겠습니다.\n\n**필요한 프로그램 목록**\n\n| 이름               | 버전          |\n| ------------------ | ------------- |\n| Clojure            | 1.10.3        |\n| deps               | 클로저에 포함 |\n| IntelliJ (Cursive) | 2021.2        |\n\n## <a name=\"simple-request-and-response\"/>간단한 요청 - 응답\n\n인텔리제이에서 사용할 프로젝트를 만듭니다.\ndeps를 패키지 매니저로 사용할 것이므로 deps를 지정해주고 적절한 이름으로 만듭니다.\n\n![](/create-project.png)\n\n프로젝트 최상위 경로에 있는 `deps.edn` 을 다음과 같이 변경합니다.\n`deps.edn`은 클로저에서 사용하는 패키지 매니저인 deps 의 설정 파일입니다.\n이 글에서는 자세히 소개하지 않습니다.\n자세한 내용은 [공식문서](https://clojure.org/guides/deps_and_cli)를 참고하세요.\n\n```clojure\n{:paths [\"src\"]\n :deps {ring/ring {:mvn/version \"1.9.3\"}}}\n```\n\n_deps.edn_\n\n`deps.edn` 파일을 만든 뒤 IDE 프로그램인 인텔리제이에서 'Add as Clojure Deps project'를 클릭하여\n프로젝트에 `deps.edn` 파일을 설정 파일로 등록하여 IDE와 연동합니다.\n\n![deps 추가 방법](/add-as-clojure-deps-project.png)\n\n## <a name=\"launch-web-server-in-localhost\"/>로컬호스트에 웹서버 띄우기\n\n`src` 디렉터리를 생성하고, 'mark directory as source folder'를 클릭하여 소스 폴더로 설정합니다.\n소스 폴더 안에는 `hello_world` 라는 이름으로 앱 디렉터리를 지정합니다.\n\n![프로젝트 폴더 구조](/project-layout1.png)\n\n- 폴더 이름에 하이픈(-) 이 들어있으면 \"Namespace name does not correspond to filesystem hierarchy\" 라는 오류 메시지를 보실 수 있습니다.\n  하이픈 대신 언더바(\\_)를 사용해야 합니다.\n\n이제 웹 서버에 들어온 요청을 넘겨받아 적절한 처리를 하고 응답을 넘겨줄 핸들러를 정의할 차례입니다.\n핸들러를 정의할 클로저 namespace 파일을 생성합시다.\n저는 core.clj 라고 이름 지었습니다.\n\n```clojure\n(ns hello-world.core)\n\n(defn handler [request]\n  {:status 200\n   :headers {\"Content-Type\" \"text/html\"}\n   :body \"Hello World\"})\n```\n\n_namespace(ns) 의 폴더명에 섞인 언더바가 하이픈으로 변경된 것에 주의_\n\n이제 인텔리제이에서 REPL을 실행할 수 있게 설정합시다. 특별히 수정할 것 없이 이름만 정해주면 됩니다.\n\n![REPL configuration](/how-to-configure-repl.png)\n\n이제 `run` 메뉴에서 REPL을 실행할 수 있습니다.\n\nREPL에서 아래의 코드를 입력하여 로컬 환경에서 웹 서버 애플리케이션을 띄워봅시다.\n\n```clojure\n(use 'ring.adapter.jetty)\n(use 'hello-world.core)\n(def server (run-jetty handler {:port  3000\n                                :join? false}))\n\n(.stop server)\n(.start server)\n```\n\n_REPL_\n\n![response](/result-simple-response.png)\n\n잘 되었다면 `def server ...` 를 REPL 에서 실행하는 순간 웹서버가 시작되는 것을 로그에서 확인할 수 있습니다.\n웹 브라우저를 이용해 웹 서버의 URL에 접속하면, 핸들러에 정의해 둔 메시지가 응답되는 것을 확인할 수 있습니다.\n\n- Ring 의 응답 데이터 구조\n\n```clojure\n{:ssl-client-cert nil,\n :protocol \"HTTP/1.1\",\n :remote-addr \"127.0.0.1\",\n :headers {\"sec-fetch-site\" \"none\",\n           \"host\" \"localhost:3000\",\n           \"user-agent\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:90.0) Gecko/20100101 Firefox/90.0\",\n           \"cookie\" \"...\",\n           \"sec-fetch-user\" \"?1\",\n           \"connection\" \"keep-alive\",\n           \"upgrade-insecure-requests\" \"1\",\n           \"accept\" \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n           \"accept-language\" \"ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3\",\n           \"sec-fetch-dest\" \"document\",\n           \"accept-encoding\" \"gzip, deflate\",\n           \"sec-fetch-mode\" \"navigate\"},\n  :server-port 3000,\n  :content-length nil,\n  :content-type nil,\n  :character-encoding nil,\n  :uri \"/\",\n  :server-name \"localhost\",\n  :query-string nil,\n  :body #object[org.eclipse.jetty.server.HttpInputOverHTTP 0x6a5c0707 \"HttpInputOverHTTP@6a5c0707[c=0,q=0,[0]=null,s=STREAM]\"],\n  :scheme :http,\n  :request-method :get}\n```\n\n이제 Ring 이 제공하는 `response` 함수를 활용해봅시다. `ring.util.response` 는 아래와 같이 구현되어 있습니다.\n\n```clojure\n(defn response\n  \"Returns a skeletal Ring response with the given body, status of 200, and no\n  headers.\"\n  [body]\n  {:status  200\n   :headers {}\n   :body    body})\n```\n\n_ring.utils.response/response 구현체_\n\n빈 헤더와 HTTP 상태 코드 200, 그리고 사용자가 넘겨준 body를 반환하도록 정의되어 있습니다.\n이를 이용해 우리가 앞서 만든 코드를 아래와 같이 수정 할 수 있습니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.util.response :refer [response]]))\n\n(defn handler [request]\n  (response \"{\\\"test\\\": \\\"asd\\\"}\"))\n```\n\n이 외에도 redirect, created, bad-request 등 HTTP 응답 상태 코드에 대응하는 여러가지 응답 함수가 있으므로 상황에 따라 사용할 수 있습니다.\nHTTP 응답 헤더도 설정할 수 있습니다. 만약 Content-Type 헤더를 `application/json` 으로 설정하여 응답을 주고 싶다면 아래와 같이 핸들러를 정의합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.util.response :refer [response header]]))\n\n(defn handler [request]\n  (header (response \"{\\\"test\\\": \\\"asd\\\"}\") \"Content-Type\" \"application/json\")\n```\n\n헤더를 설정하는 또 다른 방법으로, 아래와 같이 `content-type` 함수를 사용하는 것도 가능합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.util.response :refer [response content-type]]))\n\n(defn handler [request]\n  (content-type (response \"{\\\"test\\\": \\\"asd\\\"}\") \"application/json\")\n```\n\n## <a name=\"setting-up-middleware\"/>미들웨어 설정해보기\n\n모든 핸들러가 `Content-Type` 헤더를 `application/json` 으로 설정하려면 어떻게 해야 할까요?\n각 핸들러마다 헤더를 명시적으로 설정해줘도 되지만, 미들웨어를 이용하면 일괄로 처리할 수 있습니다.\n`Content-type` 헤더 설정을 미들웨어에서 처리해봅시다.\n\n```clojure\n(ns hello-world.core)\n\n(defn handler [request]\n  {:status 200\n   :headers {\"Content-Type\" \"text/html\"}\n   :body \"{\\\"test\\\": \\\"asd\\\"}\"})\n\n(defn wrap-content-type [handler content-type]\n  (fn [request]\n    (let [response (handler request)]\n       (assoc-in response [:headers \"Content-Type\"] content-type))))\n\n(def app\n  (-> handler\n      (wrap-content-type \"application/json\")))\n```\n\n_미들웨어를 추가한 core.clj_\n\n애플리케이션이 실행될 때 `wrap-content-type` 이 `handler` 함수를 감싸므로 `handler` 함수 안에서 헤더 설정을 명시하지 않아도 됩니다.\n애플리케이션에 미들웨어를 등록한 걸 반영하기 위해서는, `run-jetty` 의 실행 대상을 `handler` 대신 `app` 으로 바꿔야 합니다.\n서버를 실행시켜 둔 상태라면 서버도 다시 로드해야 합니다.\n\n```clojure\n(.stop server)\n(use 'hello-world.core :reload)\n(def server (run-jetty app {:port 3000\n                            :join? false}))\n(.start server)\n```\n\n_미들웨어를 적용하기 위해 (run-jetty handler ...) 에서 (run-jetty app ...) 으로 변경한 것에 주목_\n\n웹 브라우저에서 웹 서버에 다시 접속해보면, 응답 헤더가 올바르게 전달되어 브라우저에서 데이터를 JSON으로 인식하는 걸 확인할 수 있습니다.\n\n![미들웨어를 추가한 결과](/result-middleware.png)\n\n미들웨어를 통해 자동 리로딩 기능을 설정할 수 있습니다.\nREPL을 이용하여 서버를 띄웠을 때는 변경을 반영하기 위해 서버를 재시작 해야했습니다.\n자동 리로딩을 이용하면 변경을 파일에 저장하면 서버를 재시작 하지 않아도 변경이 반영됩니다.\n개발 편의성을 위해 설정해 봅시다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.reload :refer [wrap-reload]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [request]\n      {:status 200\n       :headers {\"Content-Type\" \"text/html\"}\n       :body \"{\\\"test\\\": \\\"asd\\\"}\"})\n\n(def reloadable-app\n  (-> handler\n      wrap-reload))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n_자동 리로딩을 적용한 core.clj_\n\n자동 리로딩을 설정하려면 `ring.middlewrae.reload/wrap-reload` 를 불러와야 하고,\n`(defn -main [] ())`를 선언하여 프로그램 실행 지점을 만들어주어야 합니다.\n\n만약 기존에 REPL로 웹 서버 애플리케이션을 띄워둔 게 있다면 꺼주어야 합니다.\n그리고 프로그램 실행 지점을 통해 실행합니다.\n\n![](/run-with-main.png)\n\n이제 자동 리로딩이 잘 동작하는지 확인하기 위해 핸들러 `:body` 를 바꾸겠습니다.\n\n```clojure\n...\n\n(defn handler [request]\n      {:status 200\n       :headers {\"Content-Type\" \"text/html\"}\n       :body \"{\\\"test\\\": \\\"foobar\\\"}\"})\n\n...\n```\n\n파일을 저장하고 웹 브라우저에서 새로고침을 두어번하면 변경한 응답이 반영되어 있습니다.\n\n## <a name=\"serving-static-resources\"/>정적 자원을 서빙 해보기\n\n이제 핸들러를 이용해 정적 자원을 응답하도록 설정해 봅시다.\n여기서 소개하는 것과 똑같은 구조가 아니어도 되지만,\n편의상 프로젝트 최상위 경로를 기준으로 아래와 같은 구조가 되도록 `resources/public` 폴더를 만들겠습니다.\n\n```text\n/app\n  /resources\n    /public\n  /src\n    /hello_world\n      core.clj\n  deps.edn\n```\n\n_폴더 구조_\n\n`resources/public` 에 서빙할 정적 자원을 넣어두시면 됩니다. 아래와 같이 간단한 `index.html` 파일을 만들어 넣습니다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>index</title>\n  </head>\n  <body>\n    Clojure time!\n  </body>\n</html>\n```\n\n_resources/public/index.html_\n\n지금은 라우팅 없이 하나의 핸들러 모든 요청을 처리하고 있습니다. 핸들러를 아래와 같이 수정합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.resource :refer [wrap-resource]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [request]\n  (response (slurp \"resources/public/index.html\")))\n\n(def reloadable-app\n  (-> handler\n      (wrap-resource \"public\")))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n_core.clj_\n\n위의 코드에서 보듯, 정적 자원을 서빙 하기 위해서는 `wrap-resource` 가 필요합니다.\n`wrap-resource` 는 파라미터로 핸들러와 경로를 받습니다.\n`root-path`를 `public` 으로 지정합니다.\n소스 코드를 저장하여 웹 서버가 리로드 되도록 하고, 웹 브라우저에서 [http://localhost:3000/index.html](http://localhost:3000/index.html) 에 접속해 봅시다.\n\n![template response](/result-static-resource.png)\n\n`index.html` 파일의 내용이 잘 출력되는 것을 확인할 수 있습니다.\n\n## <a name=\"params\"/>파라미터들 다루기\n\n다음으로 URL의 쿼리 파라미터와 폼 파라미터(application/x-www-form-urlencoded)를 읽어 처리하는 방법을 알아봅시다.\n먼저 URL의 쿼리 스트링을 파싱하는 미들웨어인 `ring.middleware.params/wrap-params` 를 추가합니다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.session :refer [wrap-session]]\n            [ring.middleware.params :refer [wrap-params]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [{:keys [query-params form-params params]}]\n  (response (str {:query-params query-params\n                  :form-params form-params\n                  :params params})))\n\n(def reloadable-app\n  (-> handler\n      wrap-params\n      wrap-session))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n`wrap-params` 는 요청에 `:query-params` 와 `:form-params`, `:params` 를 각각 키와 값으로 추가해줍니다.\n이름에서 알 수 있다시피 `query-params` 는 URL 쿼리 스트링을,\n`form-params` 은 폼 데이터를 그리고 `params` 는 모든 파라미터를 파싱하여 담고 있습니다.\n웹 서버를 리로드하고, 웹 브라우저에서 URL에 쿼리 스트링을 입력하여 접속하면 `query-params` 와 `params` 에 의도한 값인 `foo: 1` 이 들어감을 볼 수 있습니다.\n\n![query params response](/result-query-params.png)\n\n마찬가지로 x-www-form-urlencoded 데이터를 전달하면 `form-params` 에 요청 내용이 입력되는 것을 확인할 수 있습니다.\n\n![form params response](/result-form-params.png)\n\n하지만 `wrap-params` 는 `x-www-form-urlencoded` 형식의 데이터만을 파싱할 수 있습니다.\n`ring.middleware.params/wrap-params` 의 주석에 자세한 내용이 적혀 있습니다.\n\n> Middleware to parse urlencoded parameters from the query string and form\n> body (if the request is a url-encoded form).\n\n`multipart/form-data` 형식의 데이터를 처리하려면 `ring.middleware.multipart_params/wrap-multipart-params` 를 사용해야 합니다.\n그러면 `wrap-multipart-params` 를 이용해 파일 업로드를 처리해 봅시다.\n파일을 올릴 폴더를 준비합니다.\n\n```\n/app\n  /resources\n    /public\n  /src\n    /hello_world\n      core.clj\n  deps.edn\n```\n\n여기서는 이전에 만들어둔 `public` 폴더를 그대로 사용하도록 하겠습니다.\n`wrap-resource` 를 미들웨어에 추가하고 자원을 저장할 경로로 `public` 폴더를 지정합시다.\n파일 업로드를 처리할 준비가 끝났습니다.\n이제 업로드 요청을 받았을 때 파일이 어떤 식으로 `request-map` 에 실리는지 살펴봅시다.\n\n```clojure\n(ns hello-world.core\n  (:require [ring.adapter.jetty :refer [run-jetty]]\n            [ring.middleware.resource :refer [wrap-resource]]\n            [ring.middleware.params :refer [wrap-params]]\n            [ring.middleware.multipart-params :refer [wrap-multipart-params]]\n            [ring.util.response :refer [response]]))\n\n(defn handler [{params :params}]\n  (prn params)\n  (response \"\"))\n\n(def reloadable-app\n  (-> handler\n      wrap-params\n      wrap-multipart-params\n      (wrap-resource \"public\")))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n{' '}\n\n<br />\n\n```clojure\n{\"test\" {:filename \"20210805_145756.jpg\",\n         :content-type \"image/jpeg\",\n         :tempfile #object[java.io.File 0x805f6d6 \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T/ring-multipart-15013718029732306064.tmp\"],\n         :size 133949}}\n```\n\n_prn 결과_\n\n`request-map` 안에, 키(`test`)에 업로드된 파일의 정보가 들어옵니다.\n`:tempfile` 의 값에 있는 객체를 이용해 파일 내용을 읽거나 저장 할 수 있습니다.\n\n```clojure\n...\n    (:require [clojure.core :refer [bean]]\n              [clojure.java.io :refer [copy file]]\n              ...)\n\n(defn handler [{params :params}]\n  (let [save-path \"/tmp/\"\n        tmp-file (-> (get-in params [\"test\" :tempfile])\n                     bean\n                     :path)]\n    (copy (file tmp-file) (file (str save-path (get-in params [\"test\" :filename])))))\n  (response \"\"))\n```\n\n_업로드한 파일과 동일 이름으로 서버의 `save-path`에 저장_\n\n`:tempfile`의 값은 `java.io.File` 객체입니다. 이 객체를 사용하려면 자바빈 객체의 속성들을\n클로저의 맵으로 바꿔주는 `clojure.core/bean` 이 필요합니다.\n\n```clojure\n(def handler [{params :params}]\n    (prn (bean (get-in params [\"test\" :tempfile]))))\n```\n\n변경된 내용을 확인해봅시다.\n\n```clojure\n{:path \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T/ring-multipart-8223890071443078384.tmp\",\n :freeSpace 398616518656,\n :parent \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T\",\n :directory false,\n :parentFile #object[java.io.File 0x660a21ea \"/var/folders/2d/t4tt59310811tbf48s8xbnpc0000gn/T\"],\n :name \"ring-multipart-8223890071443078384.tmp\",\n :file true,\n ...}\n```\n\n_bean 에 의해 클로저 맵으로 변경된 java.io.File 객체_\n\n올린 임시 파일이 저장된 경로와 파일명을 알아냈으므로,\n`clojure.java.io/copy, file` 을 통해 파일 객체로 변환하여 복사할 수 있습니다.\n웹 브라우저로 파일 업로드를 테스트해보면 파일이 잘 올라가는 것을 확인할 수 있습니다.\n\n![서버에 올라간 파일](/result-upload-file.png)\n\n## <a name=\"session-and-cookie\"/>세션과 쿠키\n\n이번에는 세션과 쿠키를 다뤄 보겠습니다.\n`ring.middleware.session/wrap-session` 과 `ring.middleware.session/wrap-cookies` 가 필요합니다.\n\n```clojure\n(ns hello-world.core\n      (:require [ring.adapter.jetty :refer [run-jetty]]\n                [ring.middleware.session :refer [wrap-session]]\n                [ring.middleware.cookies :refer [wrap-cookies]]\n                [ring.util.response :refer [response]]))\n\n(defn handler [{session :session}]\n  (let [count (:count session 0)\n        session (assoc session :count (inc count))]\n    (-> (response (str (:count session)))\n        (assoc :session session)\n        (assoc :cookies {:cnt (:count session)}))))\n\n(def reloadable-app\n      (-> handler\n          wrap-session\n          wrap-cookies))\n\n(defn -main []\n  (run-jetty #'reloadable-app {:port 3000\n                               :join? false}))\n```\n\n먼저 웹 서버를 실행시켜 결과를 확인해 보겠습니다.\n\n![](/result-session.png)\n\n`count` 는 세션이 유지되는동안 페이지를 새로고침할 때마다 1씩 증가합니다.\n이는 세션에 담긴 값을 보여주는 응답에서 확인할 수 있습니다.\n마찬가지로 응답 쿠키에 `cnt` 도 잘 들어와 있고요.\n\n세션의 경우 요청에서 받아온 정보를 상태로 보관하고 있다가 응답으로 넘겨줄 수 있도록 구성되어 있습니다.\n세션의 저장 방식으로는 Ring에서 지원하는 `ring.middleware.session.memory/memory-store` 와\n`ring.middleware.session.cookie/cookie-store` 가 있습니다.\n또한 사용자가 직접 정의한 저장 방식을 지정하는 것도 가능합니다.\n\nRing의 기본 저장 방식은 `memory-store` 입니다.\n저장 방식을 변경하려면 미들웨어에서 `:store` 값을 변경하면 됩니다.\n\n```clojure\n(use 'ring.middleware.session.cookie)\n\n(def app\n  (wrap-session handler {:store (cookie-store {:key \"a 16-byte secret\"})})\n```\n\n_https://github.com/ring-clojure/ring/wiki/Sessions#session-stores_\n\n쿠키의 경우 아래와 같은 옵션이 지원됩니다.\n\n> `:domain` - restrict the cookie to a specific domain\n>\n> `:path` - restrict the cookie to a specific path\n>\n> `:secure` - restrict the cookie to HTTPS URLs if true\n>\n> `:http-only` - restrict the cookie to HTTP if true (not accessible via e.g. JavaScript)\n>\n> `:max-age` - the number of seconds until the cookie expires\n>\n> `:expires` - a specific date and time the cookie expires\n>\n> `:same-site` - Specify :strict,:lax, or :none to determine whether cookies should be sent with cross-site requests\n\n다음은 쿠키 설정의 한 예입니다.\n\n```clojure\n...\n\n(defn handler [{session :session}]\n  (let [session (update session :count (fnil inc 0))]\n    (-> (response (str (:count session)))\n        (assoc :session session)\n        (assoc :cookies {:cnt (:count session)\n                         :secret {:value \"foobar\", :secure true, :max-age 3600}}))))\n...\n```\n\n_core.clj/handler_\n\n![저장된 쿠키](/result-cookie.png)\n\n위에서 설정한대로, `secret` 키에 `foobar` 라는 값이 들어있고,\n`Secure: true` 와 `max-age` 가 최근 접속 후 1시간까지로 설정된 것을 확인하실 수 있습니다.\n\n## <a name=\"end-of-document\"/>마치며\n\n이것으로 클로저의 저수준 웹 서버 애플리케이션 개발을 해보았습니다.\n\n이 튜토리얼에서 소개된 내용의 대부분 [ring wiki](https://github.com/ring-clojure/ring/wiki) 를 참고하고 정리한 것입니다.\n더 자세한 내용이 필요하다면 참고하시기 바랍니다.\n\n감사합니다.\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"dw.kim@greenlabs.co.kr\"\n  name=\"김동욱\"\n  description=\"백엔드 개발자\"\n  date=\"2021-09-17\"\n/>\n","id":"4a637fde-9c6e-5ace-a010-822ca614e883"},"userFilterAllMdx":{"nodes":[]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"},"id":"f154cb27-cd10-58b6-8b1e-d58973d0f411"},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"},"id":"5eacd25c-be7f-5bbb-b53e-8bbb8bc8bcfd"},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"},"id":"f13162a1-9c05-5a1e-bf85-655b5aace0ae"},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"},"id":"adc71c37-e00e-58e7-83dc-df70f5e6331a"},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"},"id":"9ce74193-f3f1-5daf-ac68-4d9b62712ba5"},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"},"id":"cdd0571d-71f3-509e-ad9c-e294c7567d55"},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"},"id":"503f1b09-b133-5f63-8898-ac5eba7cc0d6"},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"},"id":"b6744efa-9cd1-5ad8-9b12-0a38954ffb4b"},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"},"id":"68a29bba-1b97-586d-a0de-cb6d67c0927f"},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"},"id":"b738b947-e79e-551b-8534-787ebf6e2d9f"},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"},"id":"537a368e-3237-58a2-8691-44450d566d52"},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"},"id":"7b8b38cf-4f0b-5c9d-9bc8-da7dc5b7af6c"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"},"id":"4aa716bb-c5ff-57ae-967e-ee9d2faa9456"},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"},"id":"ee2a79b0-460b-57ad-ad6d-afb831aa3d05"},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"},"id":"ff29574f-ad14-52ca-9aa2-63deb07b8ebc"},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"},"id":"1242c8cd-8847-51c9-84b3-00e8ac025cc0"},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"},"id":"fcd89036-f4c3-53c8-b8b8-cf204e6e2218"},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"},"id":"d2b3e0d3-2d3c-5ddd-9190-a649bd9232d8"},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"},"id":"50b95dc8-1681-5633-a035-cabafbe1fb0a"},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"},"id":"c1f6f719-a083-5eb8-94ec-1f94632ba106"}]},"allMdx":{"edges":[{"node":{"id":"c1b9e090-9ab6-5635-938e-55181ecf3bc2","frontmatter":{"date":"2023-01-02T00:00:00.000Z"}}},{"node":{"id":"23649293-d0ae-5878-809e-e459f2a33862","frontmatter":{"date":"2022-11-28T00:00:00.000Z"}}},{"node":{"id":"a35f56fb-dec5-51dc-8f87-ce415db90df4","frontmatter":{"date":"2022-11-11T00:00:00.000Z"}}},{"node":{"id":"f154cb27-cd10-58b6-8b1e-d58973d0f411","frontmatter":{"date":"2022-10-30T00:00:00.000Z"}}},{"node":{"id":"5eacd25c-be7f-5bbb-b53e-8bbb8bc8bcfd","frontmatter":{"date":"2022-10-26T00:00:00.000Z"}}},{"node":{"id":"f3366c54-e983-5cc1-9ac0-b099ad824dd8","frontmatter":{"date":"2022-10-14T00:00:00.000Z"}}},{"node":{"id":"f13162a1-9c05-5a1e-bf85-655b5aace0ae","frontmatter":{"date":"2022-08-25T00:00:00.000Z"}}},{"node":{"id":"6824dc6c-daa7-5e2b-8b25-283f61471036","frontmatter":{"date":"2022-08-16T00:00:00.000Z"}}},{"node":{"id":"adc71c37-e00e-58e7-83dc-df70f5e6331a","frontmatter":{"date":"2022-07-27T00:00:00.000Z"}}},{"node":{"id":"9ce74193-f3f1-5daf-ac68-4d9b62712ba5","frontmatter":{"date":"2022-07-21T00:00:00.000Z"}}},{"node":{"id":"0cd79f66-41cd-5f02-ac23-99a6b4cfcb3e","frontmatter":{"date":"2022-07-05T00:00:00.000Z"}}},{"node":{"id":"cdd0571d-71f3-509e-ad9c-e294c7567d55","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"7691ceb5-c5de-5d80-b603-20dc8d12c0c9","frontmatter":{"date":"2022-06-17T00:00:00.000Z"}}},{"node":{"id":"89bcab3e-450c-57df-88a2-6dfedc86db73","frontmatter":{"date":"2022-04-06T00:00:00.000Z"}}},{"node":{"id":"503f1b09-b133-5f63-8898-ac5eba7cc0d6","frontmatter":{"date":"2022-01-11T00:00:00.000Z"}}},{"node":{"id":"aa5a422f-8945-52b8-8969-9531f433c561","frontmatter":{"date":"2021-12-29T00:00:00.000Z"}}},{"node":{"id":"b6744efa-9cd1-5ad8-9b12-0a38954ffb4b","frontmatter":{"date":"2021-11-22T00:00:00.000Z"}}},{"node":{"id":"68a29bba-1b97-586d-a0de-cb6d67c0927f","frontmatter":{"date":"2021-10-29T00:00:00.000Z"}}},{"node":{"id":"b738b947-e79e-551b-8534-787ebf6e2d9f","frontmatter":{"date":"2021-09-24T00:00:00.000Z"}}},{"node":{"id":"4a637fde-9c6e-5ace-a010-822ca614e883","frontmatter":{"date":"2021-09-17T00:00:00.000Z"}}},{"node":{"id":"537a368e-3237-58a2-8691-44450d566d52","frontmatter":{"date":"2021-09-13T00:00:00.000Z"}}},{"node":{"id":"7b8b38cf-4f0b-5c9d-9bc8-da7dc5b7af6c","frontmatter":{"date":"2021-08-31T00:00:00.000Z"}}},{"node":{"id":"4aa716bb-c5ff-57ae-967e-ee9d2faa9456","frontmatter":{"date":"2021-06-01T00:00:00.000Z"}}},{"node":{"id":"ee2a79b0-460b-57ad-ad6d-afb831aa3d05","frontmatter":{"date":"2021-05-30T00:00:00.000Z"}}},{"node":{"id":"ff29574f-ad14-52ca-9aa2-63deb07b8ebc","frontmatter":{"date":"2021-04-27T00:00:00.000Z"}}},{"node":{"id":"1242c8cd-8847-51c9-84b3-00e8ac025cc0","frontmatter":{"date":"2021-01-29T00:00:00.000Z"}}},{"node":{"id":"fcd89036-f4c3-53c8-b8b8-cf204e6e2218","frontmatter":{"date":"2020-12-21T00:00:00.000Z"}}},{"node":{"id":"d2b3e0d3-2d3c-5ddd-9190-a649bd9232d8","frontmatter":{"date":"2020-12-15T00:00:00.000Z"}}},{"node":{"id":"50b95dc8-1681-5633-a035-cabafbe1fb0a","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}},{"node":{"id":"c1f6f719-a083-5eb8-94ec-1f94632ba106","frontmatter":{"date":"2020-12-01T00:00:00.000Z"}}}]}},"pageContext":{"slug":"/introduce-a-ring","title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","category":"engineering","email":"dw.kim@greenlabs.co.kr","formatString":"YYYY년 M월 D일","frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring","tags":["클로저","웹 애플리케이션 라이브러리","Ring","튜토리얼"],"author":"김동욱","email":"dw.kim@greenlabs.co.kr","category":"engineering"}}},"staticQueryHashes":["318001574"]}