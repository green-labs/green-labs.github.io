{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-polymorphic-variants-index-mdx","path":"/what-is-polymorphic-variants","result":{"data":{"post":{"slug":"/what-is-polymorphic-variants","title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020년 12월 1일","tags":[{"name":"Polymorphic Variants","slug":"polymorphic-variants"},{"name":"ReasonML","slug":"reason-ml"}],"description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","canonicalUrl":null,"body":"\n> 이 글은 ReasonML에 대한 약간의 이해가 필요합니다.  \n> ReasonML에 대한 소개는 [여기](/what-is-reason-ml)를,  \n> ReasonML 문법에 대한 소개는 [여기](https://rescript-lang.org/docs/manual/latest/overview)를 참고해주세요.\n\n---\n\nReasonML에서 가장 유용한 기능을 꼽으라면 단연 배리언트와 패턴매칭일 것입니다.\n여기에 더해 ReasonML에는 일반 배리언트보다 조금 특별한 폴리모픽 배리언트라는 것이 있습니다.\n\n폴리모픽 배리언트는 `bs-css` 같은 프로젝트나 바인딩 라이브러리를 다루다 보면 빈번하게 마주하게 됩니다.\n그래서 구체적으로 어떤 개념인지 잘 몰라도 일단 사용하는 것에는 큰 어려움이 없습니다.\n\n그렇지만 실제 동작 원리를 알아두면 더 좋을 것입니다.\n블로그를 작성하는 현시점까지 ReScript 공식 문서에는 폴리모픽 배리언트에 대한 설명이 나와있지 않기에,\n이 글에서는 폴리모픽 배리언트의 개념과 이것이 언제 필요한지에 대해 다루어보겠습니다.\n\n본문의 예시는 Real World OCaml[^1]과 OCaml 공식 문서[^2]를 참고하였으며, ReasonML 버전으로 재작성하였습니다.\n\n## 기본적인 문법\n\n폴리모픽 배리언트는 **타입 선언 없이** 바로 사용할 수 있는 것이 가장 큰 특징입니다.\n\n일반 배리언트와 다른게 반드시 대문자로 시작할 필요가 없지만, 태그에 백틱(`` ` ``)을 붙여주어야 합니다.\n참고로 ReasonML과는 사촌지간인 리스크립트(ReScript)에서는 해시(`#`)를 붙이는 것으로 문법이 바뀌었습니다.\n리스크립트는 최대한 자바스크립트와 비슷한 문법을 지향하는데, 자바스크립트의 문자열 인터폴레이션과 헷깔리기 때문에 바꾸었다고 합니다.\n\n아래는 폴리모픽 배리언트의 예입니다.\n\n```reason\nlet three = `Int(3);\n/* [> `Int(int) ] */\n\nlet four = `Float(4.0);\n/* [> `Float(float) ] */\n\nlet nan = `Not_a_number;\n/* [> `Not_a_number ] */\n\n[three, four, nan];\n/* list( [> `Float(float) | `Int(int) | `Not_a_number ] ) */\n```\n\n보다시피 별도의 타입 선언 없이 쓸 수 있으며, 배리언트의 태그들이 대괄호(`[]`)로 감싸져 있는 것이 특징입니다.\n그리고 리스트에 섞어 쓰면 그 결과에 대응되는 새로운 타입도 추론해 줍니다.\n\n참고로 배열에 대해서는 타입 추론이 되지 않고 컴파일 에러가 발생합니다.\n이는 OCaml🐫 구현의 영향을 받은 것인데, 배열은 성능을 위해 사용되는 자료구조이기 때문인 것으로 추측됩니다.\n\n당연하지만 아래와 같이 태그를 혼용하는 것은 안됩니다.\n\n```reason\nlet five = `Int(\"five\")\n/* [> `Int(string) ] */\n\n[three, four, five]\n\n/*\nThis has type: [> `Int(string) ]\nSomewhere wanted: [> `Float(float) | `Int(int) ]\nTypes for tag `Int are incompatible\n*/\n```\n\n<br />\n\n### 폴리모픽 배리언트의 범위(bounds)\n\n아까부터 자동 추론되는 타입 앞에는 `>` 문자가 보입니다.\n\n```reason\n[three, four];\n/* [> `Float(float) | `Int(int) ] */\n```\n\n이런 식으로요.\n\n`>`로 시작하는 타입의 의미는 다음과 같습니다.\n\n> 열거된 태그들을 포함하기만 하면 기타 다른 태그를 포함해도 됨\n\n위 예시는 \"`Float(float)`와 `Int(int)`를 포함, **그리고** 추가적으로 다른 태그도 포함할 수 있는 타입\"의 폴리모픽 배리언트를 의미합니다.\n이를 폴리모픽 배리언트의 하계(a lower bound)라고 합니다.\n\n반대로 컴파일러가 배리언트의 타입을 `<`로 추론하는 경우가 있습니다.\n아까와는 부등호 방향이 반대입니다.\n눈치채셨겠지만 이를 폴리모픽 배리언트의 상계(an upper bound)라고 합니다.\n`<`로 시작하는 타입의 의미는 다음과 같습니다.\n\n> 열거된 태그들로 선언되거나 **혹은** 그보다 부족하게만 선언되면 문제없음\n\n예시를 들어보겠습니다.\n\n```reason\nlet isPositive = x =>\n  switch (x) {\n  | `Int(i) => i > 0\n  | `Float(f) => f > 0.\n  };\n/* [< `Float(float) | `Int(int) ] => bool */\n```\n\n위 함수의 반환 타입이 `<` 인 이유는, `Float`, `Int` 이외의 태그가 들어가면 함수 내부의 스위치 문에서 대응이 안되기 때문입니다.\n이는 안전하지 못한 코드를 의미하므로 컴파일러가 통과시키지 않습니다.\n\n참고로 상계와 하계가 동일한 경우에는 `<`, `>` 표기가 없어집니다.\n\n```reason\nlet exact = Belt.List.keep([three, four], isPositive);\n/* Belt.List.t( [ `Float(float) | `Int(int) ] ) */\n```\n\n상계와 하계가 다른 경우도 만들어낼 수 있습니다.\n\n```reason\nlet isPositive = x =>\n  switch (x) {\n  | `Int(i) => Ok(i > 0)\n  | `Float(f) => Ok(f > 0.)\n  | `Not_a_number => Error(\"not a number\")\n  };\n\nlet exact =\n  Belt.List.keep([three, four], x => {\n    switch (isPositive(x)) {\n    | Error(_) => false\n    | Ok(v) => v\n    }\n  });\n/* Belt.List.t( [< `Float(float) | `Int(int) | `Not_a_number > `Float `Int ] )\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~   */\n```\n\n추론된 타입이 좀 복잡해 보이지만 천천히 살펴보면 그리 어렵지 않습니다.\n이 타입은 Float, Int, NaN 이외의 것을 받을 수는 없지만, 적어도 Float와 Int는 포함해야 함을 의미합니다.\n\n## 폴리모픽 배리언트가 필요한 순간\n\n실전에서 폴리모픽 배리언트가 일반 배리언트보다 유용한 사례를 알아보겠습니다.\n\n색상을 다루어야 하는 상황을 가정해 봅시다.\n\n```reason\n/* 익숙한 일반 배리언트를 사용하여 타이핑 */\ntype color =\n  | RGB(int, int, int) /* 6x6x6 color cube */\n  | Gray(int); /* 24 grayscale */\n\nlet colorToInt = c =>\n  switch (c) {\n  | RGB(r, g, b) => 16 + b + g * 6 + r * 36\n  | Gray(i) => 232 + i\n  };\n```\n\n색상은 RGB 또는 흑백으로 표현할 수 있고, 이를 정수로 변환할 수 있는 로직입니다.\n여기서 요구사항이 바뀌어 투명도를 포함한 색깔을 추가로 다루어야 한다고 해봅시다.\n\n```reason\ntype extColor =\n  | RGB(int, int, int)\n  | Gray(int)\n  | RGBA(int, int, int, int); /* 🆕 6x6x6x6 color space */\n```\n\n기존 로직에 영향을 주지 않기 위해 `color` 타입을 수정하지 않고 새롭게 선언했습니다.\n여기까지는 좋습니다.\n문제는 아까와 비슷하게 `extColorToInt`라는 함수를 작성하는 순간입니다.\n단순한 타입이 아니라 로직의 구현이기 때문에, 기존 `colorToInt` 로직을 재사용하고자 합니다.\n\n```reason\nlet extColorToInt = c =>\n  switch (c) {\n  | RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | (RGB(_) | Gray(_)) as c' => colorToInt(c')\n  };\n\n/*\nThis has type: extColor\nSomewhere wanted: color\n*/\n```\n\n하지만 위와 같이 작성한 코드는 동작하지 않습니다.\n\n사람이 보기에는 문제없는 코드 같지만, 컴파일러가 보기에는 `extColor`와 `color`가 서로 전혀 다른 타입이기 때문입니다.\n에러의 의미도 그것입니다.\n\n하지만 우리가 원하는 것은 저 여지껏 사용된 태그가 적절히 재사용되는 것입니다.\n\n### 폴리모픽 배리언트로\n\n단순히 일반 배리언트를 폴리모픽 배리언트로 바꿔보겠습니다.\n\n1. 기존 코드에서 `type` 으로 선언된 부분은 날려버리고\n2. 패턴매칭에서 백틱(`)만 찍어주면 됩니다.\n\n```reason\nlet colorToInt = c =>\n  switch (c) {\n  | `RGB(r, g, b) => 16 + b + g * 6 + r * 36\n  | `Gray(i) => 232 + i\n  };\n/* [< `Gray(int) | `RGB(int,int,int) ] => int */\n\nlet extColorToInt = c =>\n  switch (c) {\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | (`RGB(_) | `Gray(_)) as c' => colorToInt(c')\n  };\n/* [< `Gray(int) | `RGB(int,int,int) | `RGBA(int,int,int,int) ] => int */\n```\n\n이번에는 문제없이 `extColorToInt`가 컴파일됐습니다.\n그리고 컴파일이 되었으니 문제가 없는 것은 분명합니다.\n원했던 대로 `c'`의 타입이 절절히 축소되어(extColor -> color) `colorToInt`의 인자로 전달되었습니다.\n\n그런데 매칭 구문이 조금 지저분해 보이는데, 차라리 catch-all로 받아버리면 어떨까요?\n\n```reason\nlet extColorToInt = c =>\n  switch (c) {\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | c' => colorToInt(c')\n  };\n\n/*\nThis has type: [> `RGBA(int, int, int, int) ]\nSomewhere wanted: [< `Gray(int) | `RGB(int, int, int) ]\nThe second variant type does not allow tag(s) `RGBA\n*/\n```\n\n아쉽게도 컴파일은 되지 않습니다.\n에러가 친절히 알려주다시피 `c'`의 타입이 굉장히 느슨하게 추론되기 때문입니다.\n\n그 이유는 어렵지 않게 추측할 수 있습니다.\n타입을 별도로 선언하지 않았기 떄문에 `c'`는 어떤 태그도 될 수 있는 반면, `colorToInt`는 상계가 있기 때문입니다.\n\n<br />\n\n#### ⚠️ Catch-all 매칭 ⚠️\n\n앞서 `isPositive`에서 보았듯이, 함수 본문의 패턴매칭은 배리언트의 상계에 영향을 미칩니다.\n그렇지만 패턴매칭에 catch-all을 넣는 순간 반대로 아래와 같이 하계만 결정되고 위로는 제약이 풀려버립니다.\n\n```reason\nlet isPositivePermissive = x =>\n  switch (x) {\n  | `Int(i) => Ok(i > 0)\n  | `Float(f) => Ok(f > 0.)\n  | _ => Error(\"Unknown number type\")\n  };\n/* [> `Float(float) | `Int(int) ] => ... */\n\nisPositivePermissive(`Int(0));\n/* Ok(false) */\nisPositivePermissive(`Ratio(3, 4));\n/* Error(\"Unknown number type\") */\n```\n\nCatch-all 케이스는 일반 배리언트에서도 에러를 일으키지 쉽지만, 폴리모픽 배리언트에서는 더 심합니다.\n왜냐하면 위 예시처럼 코드가 작성된 경우 실수로 오타를 입력해도 컴파일러가 어떤 불평도 하지 않기 때문입니다.\n\n```reason\nisPositivePermissive(`Floot(3.05));\n/* Error(\"Unknown number type\") */\n```\n\n만약 일반 배리언트였다면 이러한 문제는 없었을 것입니다.\n그러니 폴리모픽 배리언트를 쓸 때에는 catch-all 사용에 주의해야 합니다.\n\n## 일반 배리언트 vs. 폴리모픽 배리언트\n\n지금까지의 설명으로는 폴리모픽 배리언트가 일반 배리언트의 상위 호환처럼 느껴집니다.\n약간만 주의하면 일반처럼 쓸 수도 있고, 더 유연하면서 간결하고요.\n\n그렇지만 대부분의 설계에서는 **일반 배리언트가** 더 좋은 선택이라고 합니다.\n폴리모픽 배리언트는 그 유연함의 대가로 아래와 같은 단점을 가집니다.\n\n- 더 높은 복잡도\n  - 동작 방식이 일반 배리언트보다 복잡하기 때문에, 이것을 마구 쓰다가 컴파일이 잘 안되는 상황이 발생했을 때 컴파일러가 뱉어내는 에러메세지가 굉장히 난해해지곤 합니다.\n    일반적으로 **값 수준에서 구현을 단순하게 할수록 타입 수준에서 구현 복잡도가 증가**하는 경향이 있습니다.\n- 더 어려운 디버깅\n  - 타입 시스템이 유연할수록 프로그램의 버그를 찾기 어렵다고 합니다.\n    폴리모픽 배리 역시 타입 안전하긴 하지만, 그 유연함 때문에 에러를 찾기가 좀 더 어려워지는 경향이 있습니다.\n- 낮은 성능\n  - 크게 심각한 것은 아니지만 폴리모픽 배리언트는 일반보다 구현이 좀 복잡합니다.\n    또한 컴파일러가 패턴매칭을 일반 배리언트만큼 효율적으로 처리하는 코드를 생성할 수 없습니다.\n\n이런 단점에도 폴리모픽 배리언트는 여전히 매우 강력하고 유용합니다.\n장점을 다시 정리해보자면,\n\n- 재사용성\n  - 생성자가 매우 다양한 경우에 유용합니다.\n    예를 들어 문자열 인코딩을 종류별로 다뤄야 한다고 했을 때, 이를 미리 선언하지 않고 사용할 수 있어 편리합니다.\n    ```reason\n    type encoding = [ |`base64 | `ascii | `latin1 | `utf8 | `hex ... ]\n    /* 수 많은 인코딩을 일일히 나열하고 싶지 않습니다. 😕 */\n    ```\n- 디커플링\n  - 명시적인 타입 선언을 해야 한다면 이를 사용하는 모든 곳에서 의존성을 갖게 되므로 모듈 관리 비용이 들어갑니다.\n    하지만 타입 선언이 필요치 않기 때문에 태그에 대한 약속은 공유하되 완전히 디커플링된 설계를 할 수 있습니다.\n- 확장성\n\n  - 배리언트가 추후 확장되도록 설계할 수 있습니다. 위의 `extColorToInt`가 그 간단한 예입니다.\n    현실적인 예는 [graphql-ppx](http://graphql-ppx.com/)에서도 찾아볼 수 있습니다.\n    graphql-ppx는 스키마의 enum에 대해 폴리모픽 배리언트를 자동 생성하는데, 생성되는 타입은 암묵적으로 `` `FutureAddedValue(_)``라는 태그를 포함하게 됩니다.\n\n    ```reason\n    type t_someQuery_enumField = [\n      | `FutureAddedValue(string)\n      | `FIRST\n      | `SECOND\n    ];\n    ```\n\n    따라서 클라이언트에서는 위와 같이 `` `FutureAddedValue`` 매칭 코드 작성이 강제되는데, 덕분에 서버 스키마가 조용히 변경되어 새로운 enum 값이 전달되더라도 클라이언트 런타임에러가 발생하지 않도록 해줍니다.\n\n- 간결함\n  - 생성자가 전역 네임스페이스에 있기 때문에 별도로 모듈을 open할 필요가 없습니다.\n    또, 별로 중요하지 않은 곳에서 적당히 태그를 만들어 사용하고 버리기에 편리합니다.\n\n## 맺음말\n\n지금까지 살펴본 내용만으로도 폴리모픽 배리언트를 사용하는 것에는 큰 지장이 없습니다.\n하지만 타입의 상계와 하계가 어떻게 결정되는지 그 동작 방식에 대해 이해하는 것도 좋을 것입니다.\n다음 글에서는 폴리모픽 타입의 추론 과정(unification)이 어떻게 동작하는지 다루어보겠습니다.\n\n<br />\n<br />\n<Author\n  email=\"hw.nam@greenlabs.co.kr\"\n  name=\"남현우\"\n  description=\"소프트웨어 엔지니어\"\n  date=\"2020-12-01\"\n/>\n<br />\n<br />\n\n#### 참고자료\n\n- [2ality - ReasonML: polymorphic variant types](https://2ality.com/2018/01/polymorphic-variants-reasonml.html)\n- [OCaml Book, Hongbo Zhang](https://github.com/bobzhang/ocaml-book/blob/master/lang/features.org#polymorphic-variants)\n\n[^1]: [Real World OCaml](https://dev.realworldocaml.org/variants.html)\n[^2]: [Polymorphic Variants](https://ocaml.org/manual/lablexamples.html#s%3Apolymorphic-variants)\n","excerpt":"이 글은 ReasonML에 대한 약간의 이해가 필요합니다. ReasonML에 대한 소개는 여기를,\nReasonML 문법에 대한 소개는 여기를 참고해주세요.\n\nReasonML에서 가장 유용한 기능을 꼽으라면 단연 배리언트와 패턴매칭일 것입니다…","banner":null,"id":"ebc171ab-322f-5641-88fe-ce2840d3a788","email":"hw.nam@greenlabs.co.kr"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"}}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","author":"문운기","category":"engineering","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","slug":"/rescript-compiler-jsx-ppx"}},{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"}},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"}},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"}},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"}},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"}},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"}},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"}},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"}},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"}},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"}},{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"}},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"}},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"}},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"}},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"}},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"}}]}},"pageContext":{"slug":"/what-is-polymorphic-variants","title":"ReasonML의 폴리모픽 배리언트 알아보기","category":"engineering","email":"hw.nam@greenlabs.co.kr","formatString":"YYYY년 M월 D일","frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants","tags":["Polymorphic Variants","ReasonML"],"author":"남현우","email":"hw.nam@greenlabs.co.kr","category":"engineering"}}},"staticQueryHashes":["3090400250","318001574"]}