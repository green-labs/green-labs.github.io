{"componentChunkName":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-rescript-jsx-ppx-index-mdx","path":"/rescript-compiler-jsx-ppx","result":{"data":{"post":{"slug":"/rescript-compiler-jsx-ppx","title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022년 10월 30일","tags":[{"name":"ReScript","slug":"re-script"},{"name":"JSX","slug":"jsx"},{"name":"PPX","slug":"ppx"},{"name":"compiler","slug":"compiler"},{"name":"React","slug":"react"}],"description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","canonicalUrl":null,"body":"\n> 수정사항 (2022-11-17) <br /> > [JSX의 외연 확대](https://green-labs.github.io/rescript-compiler-jsx-ppx#:~:text=%EA%B0%80%20%EC%9E%88%EB%8A%94%20%EA%B2%BD%EC%9A%B0-,JSX%EC%9D%98%20%EC%99%B8%EC%97%B0%20%ED%99%95%EB%8C%80,-v3%EB%8A%94%20React)의 예로 들었던 `Remix` 대신 `Preact` 로 변경\n\n<br />\n\n리스크립트 컴파일러에 내장된 JSX v4를 개발하게 된 계기와 여정을 소개합니다. 그리고 v3 대비 어떤 점들이 개선되었는지도 소개합니다.\n\n### JSX v3 개선의 움직임 ~~(당시 나는 전혀 몰랐던)~~\n\n코어팀은 기존의 JSX v3의 개선해야할 부분에 대해 정의하고 v4 개발 계획을 수립했던 것 같습니다. 당시 저는 몰랐지만요.\n\n> https://github.com/rescript-lang/syntax/pull/235\n\n- 컴파일러와의 인터페이스를 정리하자\n- 에러를 일으킬 때, 원본 코드의 위치를 더 잘 표시하자\n- 레거시 ReasonReact를 정리하자\n- 테스트를 더 추가하자\n- 돔 요소의 어트리뷰트를 더 추가하자 (예, `aria-*`)\n\n현재 개발된 v4의 모습에 비하면 당시 계획은 v3 대비 크게 달라지는 모습을 그리지는 않았던 것 같습니다. 특히 오브젝트로 표현되는 리액트 컴포넌트 props를 레코드로 바꿔야겠다는 생각은 없었던 것 같습니다.\n\n### JSX v4 개발에 걸려듬(?)\n\n컴파일러 내부를 들여다보고 코드를 읽다보니, 이렇게 해서는 제대로 이해할 수 없겠다는 생각이 들었습니다. 직접 코드를 수정하고 만들어봐야 익힐 수 있겠다는 마음을 먹고 무엇을 만들까 고민했습니다. 그래서 머리속에 떠올랐던 기능이 Spread props였습니다. 자바스크립트나 타입스크립트에서는 자주 쓰는 표현인데, 리스크립트에서는 지원되지 않았습니다.\n\n`{...p}` Spread props 표현을 파싱하고, `p`라는 이름의 레코드를 모듈에서 찾아 각 필드의 값을 prop으로 전달하는 기능을 파서와 JSX PPX에 구현한 PR을 하였습니다.\n\n> https://github.com/rescript-lang/syntax/pull/517\n\nPR에 대해 메인테이너는 몇 가지 한계점을 지적하였습니다.\n\n- 같은 이름의 레코드를 찾아서 필드들을 prop으로 전달하는 방식: alias 된 이름은 찾을 수가 없다.\n\n  ```rescript\n  // A.res\n  type p = {a: int, b: int}\n  let p = {a: 1, b: 2}\n\n  // B.res\n  let q = A.p\n\n  <Comp {...q} />\n  // q는 찾을 수 있지만, 바인딩된 A.p는 문자 정보일 뿐 레코드라는 타입 정보는 없음.\n  ```\n\n- 다른 모듈의 레코드는 참조할 수가 없다.\n\nPPX는 파서가 파싱 결과로 만든 Parsetree를 조작하는 프로그램이기 때문에, 컴파일러가 타입 정보를 추가해준 Typedtree는 PPX가 모르기 때문입니다. PPX가 가진 정보라고는 `q`는 타입 선언이고, `A.p`라는 문자와 바인딩되어 있구나 정도밖에 없습니다. 만약 `A.p`라는 레코드 타입이 다른 모듈에 선언되어있다면, 더더욱 알 길이 없죠. 그 한계를 알고는 있었습니다. 하지만 어떻게 해결할 수 있을 지는 몰랐습니다.\n\n내가 구현하고자 하는 기능이 컴파일러 안에서 작동하게 만들었다는 점에 '그래, 난 성장했어!'라고 만족했거든요.\n\n그런데 메인테이너가 예고없이 v3 개선 논의들과 v4의 청사진을 만들어서 공유해주기 시작합니다. (당황, 나한테 왜 그러는거지..) 그리고 이 한계를 개선할 수 있는 방법은 언어 자체를 활용해야한다는 걸 알려주었습니다. (그게 무슨 말이야..)\n\n### JSX v3의 문제점과 개선 방향\n\nv3를 개선해보자 했던 초기 계획보다 훨씬 큰 계획을 메인테이너가 공유해주었습니다. 저는 '음...이게 다 무슨 말이야?'라고 생각을 했습니다.\n\n> https://github.com/rescript-lang/syntax/issues/521\n\n- `@react.component` 어트리뷰트 없이 함수만으로 리액트 컴포넌트를 표현할 수 있도록 하자.\n- 내부 표현에서 `makeProps` 같은 요술을 제거하자.\n- `makeProps`에서 사용하는 `@obj` 대신 레코드의 표현력을 개선해보자.\n- React v17에 소개된 새로운 JSX transform API를 도입하자.\n- v3와의 하위호환: 가능한 점진적 마이그레이션이 가능한 방법을 찾자.\n\n그리고 제가 이해할 수 있는 팁도 줍니다. `\"레코드를 업데이트하는 문법이 있으니 레코드를 이용하면 Spread props을 구현할 수 있을거야.\"`\n\n```rescript\nlet q = {...p, a: 1} // 오!!\n```\n\n> https://github.com/rescript-lang/syntax/pull/517<br />https://github.com/rescript-lang/syntax/pull/547\n\n첫번째 PR에서는 총 246개의 댓글을 통해 구현에 대해 논의하였고, PR의 제목도 JSX v4 WIP로 변경하였습니다. 본격적인 개발을 위해 새로운 PR을 만들고 메인테이너와 논의하면서 개발을 이어갔습니다.\n\n본격적인 v4 개발이 시작되었습니다.\n\n### JSX v4 개발\n\n#### `makeProps`는 왜 필요한 것일까?\n\n`@obj external makeProps: ...`은 리액트 컴포넌트 props에 해당하는 오브젝트를 생성하고 각 prop의 타입을 체크해주는 역할을 합니다. 오브젝트 대신 레코드를 사용하려면 `makeProps`없이 props를 표현할 수 있어야 합니다.\n\n컴파일러는 리액트 컴포넌트를 정의(Definition)한 원본 코드를 이렇게 변환합니다.\n\n```rescript\n// 원본 코드\nmodule C = {\n  @react.component\n  let make = (~x, ~y) => React.string(x ++ y)\n}\n\n// v3로 변환한 결과\nmodule C = {\n  @obj\n  external makeProps: (\n    ~x: 'x,\n    ~y: 'y,\n    ~key: string=?, // key 타입 체크를 위한 인자 추가\n    unit,\n  ) => {\"x\": 'x, \"y\": 'y} = \"\" // 생성된 오브젝트\n\n  @react.component let make = (~x, ~y) => React.string(x ++ y)\n  let make = {\n    let \\\"C\" = (\\\"Props\": {\"x\": 'x, \"y\": 'y}) =>\n      make(~y=\\\"Props\"[\"y\"], ~x=\\\"Props\"[\"x\"])\n    \\\"C\"\n  }\n}\n\n```\n\n리액트 컴포넌트를 사용(application)하는 곳에서 `makeProps` 함수를 호출해서 `x`와 `y`의 타입을 체크하고, `{\"x\": \"x\", \"y\": \"y\"}` 오브젝트를 생성합니다.\n\n```rescript\n// 원본 코드\n<C x=\"x\" y=\"y\" />\n\n// v3가 변환한 결과\nReact.createElement(C.make, C.makeProps(~x=\"x\", ~y=\"y\", ()))\n    // 타입 체크 & 오브젝트 생성 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\n애초에 props 타입을 레코드 대신 `makeProps`가 생성하는 오브젝트로 대신하는 이유가 있습니다. 왜냐하면, 리액트 컴포넌트의 prop들은 일부만 사용할 수 있기 때문에, 레코드로 표현하면 필드의 타입이 option 타입을 사용해야하기 때문입니다. option 타입을 사용하면 `<C z=Some(\"z\")>`라고 표현할 수 밖에 없으니까요. 그래서 v3는 레코드 대신 `makeProps` 함수가 생성하는 오브젝트를 사용하여 구현할 수 밖에 없었을 것입니다.\n\n<br />\n\n#### 오브젝트 대신 레코드\n\n`makeProps` 함수를 대신하려면 레코드는 표현력이 더 좋아져야만 했습니다.\n\n컴포넌트의 props을 레코드로 표현했을 때, 각 필드는 하나의 prop 입니다. `x`와 `y`는 필수 prop이고, `z`는 선택 prop입니다.\n\n```rescript\ntype props = {\n  x: string,\n  y: string,\n  z: option<string>,\n}\n```\n\n1. props를 사용하지 않은 경우: `let props = {}`\n2. props 중 일부만 사용하는 경우: `let props = {x: \"x\", y: \"y\"}`\n3. props 전부를 사용하는 경우: `let props = {x: \"x\", y: \"y\", z: Some(\"z\")}`\n4. 선택 필드 z를 Some 없이 사용하는 경우: `let props = {x: \"x\", y: \"y\", z: \"z\"}`\n\n이 중 컴파일러 v9에서 레코드로 가능한 표현은 3번 뿐 입니다. 하지만 4번의 경우 리액트 컴포넌트를 표현할 때 꼭 필요합니다.\n\n```rescript\n// 선택 prop에 Some?? 이건 좀 별론데..\n<Profile name=\"정식\" nickname=Some(\"리스크립트 고수\")>\n```\n\n표현력의 한계를 해결하기 위한 방법이 필요했고, 이미 레코드의 구조를 타입 체크할 수 있는 [RFC](https://forum.rescript-lang.org/t/rfc-more-general-type-checking-for-structural-typings/1485)가 있었습니다. 이 RFC는 레코드의 필드 중 일부만 작성해도 안전하게 타입 체크를 해주는 기능입니다. 2번의 경우죠.\n\nJSX v4를 위해 이 RFC를 개선해나갑니다. 1번과 4번을 해결해야 했습니다. 특히 4번 표현은 리액트 컴포넌트를 표현할 때 꼭 필요했기 때문에 RFC를 바탕으로 메인테이너와 기능 설계를 해서 이런 문법을 추가 합니다.\n\n> https://github.com/rescript-lang/rescript-compiler/pull/5423\n\n개선의 결과로 레코드는 1 ~ 4번 모두에 해당하는 표현력을 갖게 됩니다.\n\n```rescript\ntype t = {\n  name: string,\n  nickname?: string, // ?를 붙이면 선택 필드\n}\n\nlet woonki = {name: \"운기\"}\nlet jeongsik = {\n  name: \"정식\",\n  nickname: \"리스크립트 고수\" // Some(\"...\") 하지 않아도 됩니다.\n}\n```\n\n`@optional` 대신 `?` 표현이 추가되고, 옵션 생성자를 사용하지 않고 표현할 수 있도록 개선되어 갑니다.\n그래서 리액트 컴포넌트를 이렇게 표현할 수 있게 됐습니다.\n\n```rescript\n<C name=\"운기\" />\n<C name=\"정식\" nickname=\"리스크립트 고수\" />\n```\n\n명목적 타입(Nominal type)을 사용하고 안전한(Sound) 타입 시스템에서 레코드가 이런 표현력을 갖게 되는 것은 놀라운 일입니다.\n\n<br />\n\n#### React의 새로운 jsx runtime API 도입\n\n리액트 17버젼에서 소개된 [API](https://ko.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) 입니다. 앞서 보여드렸던 내부 표현을 보면서 짐작하셨겠지만, 리스크립트는 JSX를 변환하기 위해 Babel이 필요하지 않습니다. 컴파일러가 변환하기 때문이죠. 그래서 새로운 jsx runtime API를 사용하려면 JSX v4에 구현을 해야했습니다.\n\n`rescript-react` 바인딩 모듈에 PR을 하고, 추가한 API를 v4가 호출했습니다.\n\n> https://github.com/rescript-lang/rescript-react/pull/49<br />https://github.com/rescript-lang/syntax/pull/614\n\n```rescript\n// 원본 코드\n<C x=\"x\" y=\"y\" />\n<C key=\"c\" x=\"x\" y=\"y\" />\n\n// 내부 표현\nReact.jsx(C.make, {x: \"x\", y: \"y\"})\nReact.jsxKeyed(C.make, {x: \"x\", y: \"y\"}, \"c\") // key가 있는 경우\n```\n\n<br />\n\n#### JSX의 외연 확대\n\nv3는 React ppx의 역할이었습니다. `rescript-react`에 바인딩된 리액트 API를 호출해서 내부 표현을 만듭니다. v4 작업 중 코어팀과 논의하는 과정에서 JSX는 리액트만의 표현이 아니기 때문에, Solid.js, ~~Remix~~Preact 와 같은 라이브러리나 프레임워크에도 대응할 수 있게 하자는 의견이 나왔습니다.\n\n그래서 컴파일러 내부에 `Jsx`, `JsxDOM` 등의 모듈을 추가하고, `Jsx.element`, `Jsx.component` 등의 타입을 `rescript-react`에 정의된 타입에 바인딩 하였습니다. 앞으로 `rescript-solid`, ~~`rescript-remix`~~`rescript-preact` 바인딩이 나온다면, `Jsx` 모듈을 바인딩할 수 있습니다. 그럼, JSX 표현을 공유할 수 있게 됩니다. 예를 들어, 리액트 프로젝트에서 만든 모듈을 Solid.js 프로젝트에서 사용할 수 있습니다.\n\n```rescript\n// React.res\ntype element = Jsx.element // Jsx.element는 컴파일러 내부에 정의된 타입입니다.\n```\n\n> https://github.com/rescript-lang/rescript-compiler/pull/5484<br />https://github.com/rescript-lang/rescript-react/pull/49\n\n<br />\n\n#### 점진적 마이그레이션: v3와의 하위 호환\n\nJSX v4의 구현보다 더 어려운 작업이었습니다. 왜냐하면 작업해야하는 레포지토리가 3개 입니다. 컴파일러, syntax, rescript-react에 걸쳐 의존성이 있는 작업이었습니다.\n\n우선, `bsconfig.json`에 v3와 v4를 설정할 수 있는 설정값을 추가하고, 컴파일러에서 그 설정값을 읽고 JSX ppx를 작동시키는 로직을 추가했습니다. 설정에 따라 v3 혹은 v4를 활성화 시킵니다. 기존의 `\"reason\".\"react-jsx\"`와 같은 속성은 제거하고, 새로운 `\"jsx\"` 속성을 추가했습니다.\n\n또, v3와 v4는 서로 다른 내부 표현을 생성하기 때문에, `rescript-react`의 리액트 바인딩도 `ReactV3` 모듈을 추가해서 v3를 계속 사용하는 프로젝트에서 사용이 가능하도록 하였습니다. 최신 버젼의 컴파일러와 `rescript-react`를 설치한 프로젝트에서 v3와 v4를 모두 사용할 수 있습니다.\n\n> https://github.com/rescript-lang/rescript-compiler/pull/5484\n\n<br />\n\n`bsconfig.json` 설정\n\n- V3\n\n```json\n{\n  \"jsx\": {\n    \"version\": 3,\n    \"v3-dependencies\": [\n      \"rescript-relay\" // v3를 사용할 의존 모듈을 추가해줍니다.\n    ]\n  },\n  \"bsc-flags\": [\"-open ReactV3\"]\n}\n```\n\n- V4\n\n```json\n{\n  \"jsx\": {\n    \"version\": 4,\n    \"mode\": \"classic\", // \"automatic\" 는 jsx runtime API 사용\n    \"module\": \"react\" // 생략 가능. 향후 \"solidjs\", \"preact\" 등 가능할지도..\n  }\n}\n```\n\n이 무렵 컴파일러, syntax에 걸쳐있는 작업들을 효율적으로 하기 위해 리스크립트 GitHub 조직에 초대를 받았습니다. ✌️\n\n![](rescript-github-org-member.png)\n\n### JSX v4의 개선점\n\n새로운 JSX v4는 v3와 비교했을 때 어떤 점이 개선되고 어떤 장점이 있는 지 살펴보겠습니다.\n\n> 스펙 문서<br />https://github.com/rescript-lang/syntax/blob/master/cli/JSXV4.md\n\n<br />\n\n#### `@react.component` 없이 표현할 수 있습니다\n\n<br />\n\n```rescript\nmodule C = {\n  type props = {x: string, y: string}\n  let make = {x, y} => React.string(x ++ y)\n}\n```\n\n타입스크립트 코드와 비슷하게 표현하지만, 강력한 타입 시스템이 타입을 추론해주고 체크해줍니다. v3 대비 표현력이 좋아지고, 코드가 간결해졌습니다.\n\n특히 `Context` API를 사용할 때, `@react.component`를 사용하지 않고 표현하면 훨씬 간결해집니다.\n\n```rescript\n// v3\nmodule Context = {\n  let context = React.createContext(() => ())\n\n  module Provider = {\n    let provider = React.Context.provider(context)\n\n    @react.component\n    let make = (~value, ~children) => {\n      React.createElement(provider,\n        {\"value\": value, \"children\": children} // Error\n      )\n    }\n  }\n}\n\n// v4\nmodule Context = {\n  let context = React.createContext(() => ())\n\n  module Provider = {\n    let make = React.Context.provider(context)\n  }\n}\n```\n\n다만, `@react.component`가 하는 일 중 하나가 함수의 이름을 대문자로 만들어주는 것인데요. 리스크립트에서 대문자 이름은 모듈이나 배리언트 생성자에게 허용되어 있고, `let` 바인딩 값에는 허용되지 않기 때문입니다. 리액트 컴포넌트 이름은 대문자로 시작하지 않으면 React Fast Refresh가 작동하지 않는다는 이슈가 보고되어서, 이 부분은 메인테이너와 함께 더 살펴볼 예정 입니다. 그래서 React Fast Refresh 이슈가 있는 경우에는 `@react.component`를 사용하시는 편이 좋을 것 같습니다.\n\n<br />\n\n#### Spread props을 사용할 수 있습니다.\n\n특히, DOM 요소의 어트리뷰트에 해당하는 props를 전달할 때 유용하게 사용할 수 있을 것 같습니다.\n\n<br />\n\n```rescript\n// 사용자 정의 컴포넌트\n<Comp {...props} x=\"x\" />\n\n// DOM 요소 컴포넌트\nlet props: Jsx.domProps = {id: \"id\", name: \"그린랩스\"}\n<div {...props} />\n```\n\n<br />\n\n#### 새로운 jsx runtime API를 활용할 수 있습니다.\n\n리액트를 import 하지 않아도 리액트 컴포넌트를 생성할 수 있는 API를 활용해서 번들 사이즈를 조금 더 줄일 수 있습니다. 리액트 팀 감사합니다. 😉\n\n<br />\n\n#### 컴포넌트들 간 props 타입을 공유할 수 있습니다.\n\n<br />\n\n```rescript\ntype sharedProps = {\n  x: string,\n  y: string,\n}\n\nmodule A = {\n  @react.component(:sharedProps)\n  let make = (~x, ~y) => React.string(x ++ y)\n}\n\nmodule B = {\n  @react.component(:sharedProps)\n  let make = (~x, ~y) => React.string(x ++ y)\n}\n```\n\n리스크립트는 명목적 타입(Nominal type)을 사용하고 있습니다. A 모듈의 `props`와 B 모듈의 `props`는 다른 타입이죠. 예를 들어, React Native Navigation의 Screen 컴포넌트에 `component` prop에 A, B 컴포넌트를 전달하는 경우 타입 에러가 발생합니다.\n\n```rescript\ntype screenProps = { navigation: navigation, route: route }\n\nmodule Screen: {\n  @react.component\n  let make: (\n    ~name: string,\n    ~component: React.component<screenProps>,\n    ...\n  ) => React.element\n}\n\n// 타입 에러\n// component: React.component<screenProps>\n// A.make: React.component<A.props>\n<Screen name=\"A\" component={A.make} />\n<Screen name=\"B\" component={B.make} />\n```\n\n이런 경우 shared props 기능을 사용할 수 있습니다.\n\n```rescript\nmodule A = {\n  @react.component(:screenProps)\n  let make = (\n    ~navigation: navigation,\n    ~route: route\n  ) => ...\n}\n\nmodule B = {\n  @react.component(:screenProps)\n  let make = (\n    ~navigation: navigation,\n    ~route: route\n  ) => ...\n}\n```\n\n<br />\n\n### 기여를 하며 배운 점\n\n돌이켜보면 어쩌다 여기까지 오게 됐는지 잘 알 수 없지만, 필요한 건 직접 PR을 만들어서 제안해보면 좋겠다는 시도에서 시작된 것 같습니다. 그 시작은 보잘 것 없어서 머지가 되지 못할 Spread props 문법의 구현이었지만, 운좋게도 코어팀의 필요와 맞물려서 컨트리뷰터가 될 수 있었습니다.\n\n컴파일러 8개, syntax 22개, rescript-react 9개, 총 39개의 PR을 만들면서 배운점과 느낀점을 정리해보았습니다.\n\n![](jsx-ppx-v4-congrats.jpg)\n\n> 1차 마무리 후 메인테이너의 감사 코멘트. ~~덕분에 제가 많이 배웠습니다, 근데 이제 시작이었다..~~\n\n<br />\n\n#### RFC -> 기술 스펙 -> 구현 -> 테스트, TDD\n\n오픈 소스에 기여한 적이 처음은 아니지만, 긴 기간(약 4개월) 동안 꾸준히 개발하고 같이 협업을 한 적은 처음이었습니다. RFC를 만들어서 공개하고, 커뮤니티에 의견을 묻고, 코어팀 뿐만 아니라 커뮤니티 개발자들과 함께 기능과 구현을 논의하는 과정을 경험해볼 수 있었습니다. 기술 스펙 문서를 작성하고, 구현하고, 테스트 후 알파, RC 버젼을 배포해서 다시 테스트하고 테스트를 커뮤니티에 요청하는 하나의 개발 싸이클 속에 있어 본 좋은 기회였습니다.\n\n그리고 TDD라고 거창하게 말할 수준은 아니지만, 구현하거나 수정해야할 테스트 샘플을 추가한 뒤 원본 코드가 파싱된 AST(Parsetree), Typedtree, Lambda 표현, 그리고 자바스크립트 결과물을 prettier printer로 출력하면서 원하는 구현을 해나가는 방식은 인상적이었습니다.\n\n<br />\n\n#### 영어가 한계가 될 수 있지만, 코드가 좋은 소통 수단\n\n구현의 방향을 논의하고 리뷰를 주고 받는 과정은 모두 영어로 해야했습니다. 영어 글쓰기가 편할리만은 없었고, 내 생각과 맥락을 충분히 표현하기는 쉽지 않았습니다. 오히려 구현하는데 드는 시간보다 설명하는데 시간이 더 필요한 경우도 종종 있었습니다. 하지만 코드가 훌륭한 소통 수단이어서, 오픈 소스에 기여하기 위해서 물론 영어 공부를 하는 것도 중요하지만, 코드를 더 잘 짜고 기여를 많이 하는 편이 더 나을 수 있겠다는 생각을 했습니다.\n\n<br />\n\n#### 리스크립트 컴파일러 내부를 더 잘 이해하는 계기\n\n리스크립트 컴파일러 내부와 소스 코드를 이해하고 싶어서 기웃 기웃 레포를 뒤지고 코드를 읽어보긴 했지만, 직접 개발에 참여하는 것만큼 이해하는데 좋은 계기는 없는 것 같습니다. 컴파일러의 설정 값을 파싱하여 사용하는 모듈, syntax 모듈의 인터페이스와 호출되는 방식, 내장 PPX들의 구현, 테스트 방법, 타입 체커, 람다 표현, 자바스크립트 코드 생성이 어떤 모듈에서 어떻게 작동하는지 더 많이 알게 된 좋은 기회였습니다.\n\n<br />\n\n#### 리스크립트, 오캐믈에 대한 믿음\n\n컴파일러 코드는 대부분 오캐믈로 작성되어있습니다. 코드를 더 잘 읽고, 구현을 하는데 있어서 오캐믈의 타입 시스템이 큰 도움이 되었습니다. 그리고 배리언트로 표현된 AST인 Parsetree, Typedtree, Lambda, 그리고 모듈 시스템은 이해하기 쉽고 안전한 코드를 작성하는데 든든한 길잡이었습니다.\n\n그만큼 오캐믈과 동일한 타입시스템을 갖고 있는 리스크립트에 대한 믿음과 기대도 더 커졌습니다.\n\n### 마치며\n\nJSX v4 개발에 기여하면서 느낀 점 중 하나가 리스크립트는 자바스크립트, 타입스크립트 개발자들에게 더 친숙한 문법과 표현력을 가지는 방향으로 개발되어가고 있다는 점 입니다. 현재 진행 중인 `Uncurried as default`도 같은 목표 아래에서 개발되고 있는 기능이구요. 더 많은 자바스크립트, 타입스크립트 개발자들에게 더 친숙하게 접근할 수 있는 언어가 되어서, 훌륭하고 안전한 타입 시스템의 혜택을 더 많은 분들이 즐길 수 있게 되면 좋겠습니다.\n\n<br />\n\n> [그린랩스 Dev Dive 2022, 발표 영상](https://youtu.be/Ql-YAnVneGA)\n\n<iframe\n  width=\"560\"\n  height=\"315\"\n  src=\"https://www.youtube.com/embed/Ql-YAnVneGA\"\n  title=\"YouTube video player\"\n  frameborder=\"0\"\n  allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n  allowfullscreen\n></iframe>\n\n<br />\n<br />\n<hr />\n<br />\n<Author\n  email=\"woonki.moon@gmail.com\"\n  name=\"문운기\"\n  description=\"프론트엔드 개발자\"\n  date=\"2022-10-30\"\n/>\n","excerpt":"수정사항 (2022-11-17)  > JSX의 외연 확대의 예로 들었던 Remix 대신 Preact 로 변경 리스크립트 컴파일러에 내장된 JSX v4를 개발하게 된 계기와 여정을 소개합니다. 그리고 v3 대비 어떤 점들이 개선되었는지도 소개합니다…","banner":null,"id":"0048ad06-fe85-5b48-a3bb-a13dcad5b3ee","email":"woonki.moon@gmail.com"},"userFilterAllMdx":{"nodes":[{"frontmatter":{"title":"대수적 데이터 타입과 리액트 상태 관리","date":"2021-08-31T00:00:00.000Z","author":"문운기","category":"engineering","description":"대수적 데이터 타입을 이용한 상태관리를 통해 리액트 컴포넌트의 복잡도를 낮추는 방법을 알아봅니다.","slug":"/algebraic-data-type"}}]},"dateSortAllMdx":{"nodes":[{"frontmatter":{"title":"Feature flags 적용 (1)","date":"2022-10-26T00:00:00.000Z","author":"김정우, 양정윤, 이낙원","category":"engineering","description":"Release Toggles 적용","slug":"/feature-flags-1"}},{"frontmatter":{"title":"그린랩스 프론트엔드 길드의 페어 프로그래밍 문화를 소개합니다 :)","date":"2022-08-25T00:00:00.000Z","author":"조효정","category":"engineering","description":"페어 어때요? 그린랩스 프론트엔트 길드에서의 페어 프로그래밍 경험을 공유합니다.","slug":"/pair-programming"}},{"frontmatter":{"title":"함수만으로 지연성까지","date":"2022-07-27T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/lazy-sequence-from-scratch"}},{"frontmatter":{"title":"제목은 그린랩스 1년 후기로 하겠습니다. 근데 이제 클로저를 곁들인","date":"2022-07-21T00:00:00.000Z","author":"차민철","category":"engineering","description":"그린랩스 입사로 클로저를 처음 접해본 백엔드 개발자의 솔직한 후기를 공유합니다.","slug":"/with-greenlabs-for-1yr"}},{"frontmatter":{"title":"클로저(Clojure) 코드는 정말 읽기 어려운가?","date":"2022-06-17T00:00:00.000Z","author":"박연오","category":"engineering","description":"클로저에는 슬픈 전설이 있어. 무슨... 전설인데요?...혹시 코드가 읽기 어렵다는 그 전설인가요? 난 전설같은 건 믿지 않아.","slug":"/is-clojure-hard-to-read"}},{"frontmatter":{"title":"그린랩스 클로저 사용 실태 조사 2022","date":"2022-01-11T00:00:00.000Z","author":"남현우","category":"engineering","description":"그린랩스의 클로저 사용자를 대상으로 설문조사를 진행했습니다.","slug":"/greenlabs-clojurians-2022"}},{"frontmatter":{"title":"클로저 매크로에 대해 알아보자","date":"2021-11-22T00:00:00.000Z","author":"남영환","category":"engineering","description":"그만 알아보자","slug":"/the-macro"}},{"frontmatter":{"title":"그린랩스에서 리스크립트 시작하기","date":"2021-10-29T00:00:00.000Z","author":"김효은","category":"engineering","description":"프론트엔드 환경에서도 함수형 패러다임으로 개발한다고요? 타입스크립트보다 더 강력한 타입 시스템을 적용했다고요? 그 회사... 제가 살아남을 수 있는 곳인가요? 걱정하지 마세요. 그린랩스에서는 프론트엔드 개발자들이 함수형 프로그래밍에 쉽게 적응할 수 있도록 3주 동안의 부트캠프를 제공합니다! 그린랩스의 부트캠프와 리스크립트 언어에 대해 알아봅시다.","slug":"/rescript-bootcamp"}},{"frontmatter":{"title":"프로그래머를 위한 이름 짓는 원리","date":"2021-09-24T00:00:00.000Z","author":"박연오","category":"engineering","description":"이름은 정말로 중요할까요? 좋은 이름의 판단 기준은 무엇일까요? <클로저 기본원리>에서 이름 짓는 원리를 알아봅시다.","slug":"/programmers-naming"}},{"frontmatter":{"title":"클로저로 웹 서버 애플리케이션 개발을 시작하는 사람들을 위한 Ring 소개서","date":"2021-09-17T00:00:00.000Z","author":"김동욱","category":"engineering","description":"클로저 문법을 모두 익힌 뒤, 첫걸음으로 웹 개발을 시작하는 분들을 위해 웹 서버 어플리케이션 라이브러리 Ring이 제공하는 여러 도구들을 소개합니다.","slug":"/introduce-a-ring"}},{"frontmatter":{"title":"그린랩스에서 클로저 시작하기","date":"2021-09-13T00:00:00.000Z","author":"권정인","category":"engineering","description":"그린랩스에는 입사자를 위한 클로저 부트캠프 과정이 있습니다. 그린랩스의 클로저 부트캠프를 소개하고 경험을 공유합니다.","slug":"/clojure-bootcamp"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 2부","date":"2021-06-01T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 2부에서는 클로저의 가능성과 여러 도움이 되는 사이트들을 정리해보았습니다.","slug":"/start-your-clojure-project-now-2"}},{"frontmatter":{"title":"(번역) 클로저, 지금 바로 시작합시다! - 1부","date":"2021-05-30T00:00:00.000Z","author":"김상현","category":"engineering","description":"클로저는 리습(Lisp)의 방언으로, 단순함과 실용성을 모두 갖춘 언어입니다. 1부에서는 클로저의 탄생 배경과, 특징에 대해 알아봅니다.","slug":"/start-your-clojure-project-now-1"}},{"frontmatter":{"title":"함수형 프로그래밍과 중위연산자","date":"2021-04-27T00:00:00.000Z","author":"김춘구","category":"engineering","description":"show me the $","slug":"/apply-and-compose"}},{"frontmatter":{"title":"그린랩스가 ReasonML에서 리스크립트로 바꾸는 이유","date":"2021-01-29T00:00:00.000Z","author":"양성민","category":"engineering","description":"버클스크립트가 리스크립트로 리브랜딩한 배경을 살펴보고 리스크립트 문법과 ReasonML 문법의 차이점을 간단하게 알아봅니다. 마지막으로 이 과정에서 그린랩스는 어떤 선택을 했는지 이야기합니다.","slug":"/why-rescript"}},{"frontmatter":{"title":"앗, ReasonML의 분기문에서는 타입이 다른 데이터를 리턴할 수 없다고요?!","date":"2020-12-21T00:00:00.000Z","author":"김상현","category":"engineering","description":"자바스크립트에서는 함수나 분기문에서 타입이 다른 데이터를 리턴할 수 있는데, ReasonML에선 그럴 수 없습니다. 이 문제를 어떻게 해결할 수 있을까요?","slug":"/reasonml-ways-with-types"}},{"frontmatter":{"title":"프론트엔드 개발 ReasonML이라 좋았던 점","date":"2020-12-15T00:00:00.000Z","author":"윤정식","category":"engineering","description":"자바스크립트, 타입스크립트만 사용해본 프론트엔드 개발자가 ReasonML 개발 경험 중 장점을 공유합니다.","slug":"/reason-ml-the-good-parts"}},{"frontmatter":{"title":"자바스크립트 개발자를 위한 ReasonML","date":"2020-12-01T00:00:00.000Z","author":"양성민","category":"engineering","description":"ReasonML의 특징과 그런 특징을 가지게 된 역사적 이유에 대해 이야기합니다. 또한 타입스크립트와 어떤 차이점이 있는지 설명합니다.","slug":"/what-is-reason-ml"}},{"frontmatter":{"title":"ReasonML의 폴리모픽 배리언트 알아보기","date":"2020-12-01T00:00:00.000Z","author":"남현우","category":"engineering","description":"ReasonML의 독특한 기능 중 하나인 폴리모픽 배리언트(Polymorphic Variants). 그 사용법과 동작 원리에 대해 소개합니다.","slug":"/what-is-polymorphic-variants"}}]}},"pageContext":{"slug":"/rescript-compiler-jsx-ppx","title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","category":"engineering","email":"woonki.moon@gmail.com","formatString":"YYYY년 M월 D일","frontmatter":{"title":"리스크립트 컴파일러의 JSX v4를 개발한 여정","date":"2022-10-30T00:00:00.000Z","description":"JSX v4을 개발하게 된 과정과 v3 대비 개선된 점을 소개합니다.","author":"문운기","email":"woonki.moon@gmail.com","slug":"/rescript-compiler-jsx-ppx","tags":["ReScript","JSX","PPX","compiler","React"],"category":"engineering"}}},"staticQueryHashes":["3090400250","318001574"]}