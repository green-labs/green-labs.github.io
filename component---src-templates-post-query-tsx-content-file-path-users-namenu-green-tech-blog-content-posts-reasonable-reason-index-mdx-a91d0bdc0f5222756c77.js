"use strict";(self.webpackChunkmy=self.webpackChunkmy||[]).push([[538],{5635:function(e,n,t){t.r(n),t.d(n,{default:function(){return s}});var l=t(7294),a=t(9626);function r(e){var n=Object.assign({blockquote:"blockquote",p:"p",a:"a",strong:"strong",h3:"h3",code:"code",div:"div",pre:"pre",ul:"ul",li:"li",h2:"h2",h4:"h4"},(0,a.ah)(),e.components),t=n.Author;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Author",!0),l.createElement(l.Fragment,null,l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://reasonml.github.io/"},"ReasonML"),"의 기본적인 정보는 그린랩스 기술 블로그의 ",l.createElement(n.a,{href:"/what-is-reason-ml"},"자바스크립트 개발자를 위한 ReasonML"),"을 참고해주세요!"),"\n"),"\n",l.createElement(n.p,null,"저는 이전까지 자바스크립트와 타입스크립트 환경의 리액트 프론트엔드 프로젝트를 진행했었습니다. 그러나 그린랩스에선 프론트엔드 프로젝트에 ReasonML과 ReasonReact를 사용합니다. ReasonML은 강력한 정적 타입 시스템을 장착한 함수형 언어인 OCaml에 뿌리를 둔 ReScript 컴파일러에 의해 자바스크립트 코드로 변환되고, 이는 브라우저나 Node.js 기반에서 실행됩니다."),"\n",l.createElement(n.p,null,"이 포스팅에서는 ",l.createElement(n.strong,null,"ReasonML")," 로 프로젝트를 진행하며 느낀 ",l.createElement(n.strong,null,"장점을")," 이야기합니다. 아마 제가 기존까지 사용했던 자바스크립트와 타입스크립트 환경과의 비교 과정일 것입니다."),"\n",l.createElement(n.h3,null,"1. 자바스크립트 import, export 구문과 ReasonML의 모듈 레졸루션"),"\n",l.createElement(n.p,null,"첫째로 말하고 싶은 장점은 ",l.createElement(n.strong,null,"모듈을 다루는 ReasonML/OCaml의 방식"),"입니다."),"\n",l.createElement(n.p,null,"프로젝트의 성장에 따라 새로 탄생하는 코드도 있고, 더이상 사용하지 않는 코드도 생깁니다. 만일 코드를 주기적으로 정리하지 않는다면, 어떤 모듈은 import 된 채 아무도 찾지 않는 유령처럼 프로덕션 코드 더미를 떠돕니다. 이렇게 되면 번들 사이즈가 불필요하게 증가합니다. 또한 사용처 없이 떠도는 import는 코드 히스토리를 잘 알지 못하면 지워야할지 남겨야할지, 나중에 그 코드를 확인하는 개발자는 혼동스러울 겁니다."),"\n",l.createElement(n.p,null,"제가 경험한 자바스크립트나 타입스크립트 프론트엔드 프로젝트 엔트리 파일의 구조는 회사나 프로젝트마다 달랐습니다. 그러나 초기 환경구성작업은 대부분 비슷한 일을 필요로 합니다. 브라우저 지원 범위나 서비스의 크기에 따라 브라우저 폴리필 삽입, 글로벌 스타일 삽입, 기능에 따라 라우팅 설정을합니다. 또 리액트 프로젝트라면 각종 프로바이더를 엔트리 컴포넌트에서 불러오는 경우도 있었습니다."),"\n",l.createElement(n.p,null,"환경 구성을 하기위해 모듈을 불러야 하고, 모듈은 ",l.createElement(n.strong,null,"import, export")," 구문을 사용하여 부릅니다. 물론 IDE 종류에 따라 import 구문이 자동 완성되는 경우도 있습니다."),"\n",l.createElement(n.p,null,"리덕스같은 상태관리 도구를 프로젝트에 추가하는 경우를 생각해보겠습니다. 리덕스의 액션과 리듀서, 비동기 처리를 위해 미들웨어를 추가하고 배포 가능한 수준까지 만들기위해 여러 패키지와 import 구문을 계속 추가해야합니다. 만일 타입스크립트를 사용하기로 했다면 작성해야 할 코드의 양은 더 늘어납니다. ",l.createElement(n.code,null,"immer-reducer"),"나 ",l.createElement(n.code,null,"typesafe-actions"),"처럼 타입 안정성을 해치지 않으면서 코드의 양을 줄여주는 라이브러리들이 있지만 역설적이게도 이에 따른 import 구문은 더 늘어납니다."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"끝나지 않는 export"),"\n",l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 742px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/e91a8218d501d5906425cdca85404f7b/0f2bc/so-many-export.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 248.59437751004015%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,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\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="so-many-export"\n        title="so-many-export"\n        src="/static/e91a8218d501d5906425cdca85404f7b/0f2bc/so-many-export.png"\n        srcset="/static/e91a8218d501d5906425cdca85404f7b/6a5fb/so-many-export.png 249w,\n/static/e91a8218d501d5906425cdca85404f7b/79e1b/so-many-export.png 498w,\n/static/e91a8218d501d5906425cdca85404f7b/0f2bc/so-many-export.png 742w"\n        sizes="(max-width: 742px) 100vw, 742px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",l.createElement(n.p,null,"그래서 누군가는 import 구문을 행사(Ceremony) 코드로 분류하기도 합니다. 행사 코드는 프로그램의 핵심 동작에 직접적인 영향을 끼치지 않지만 언어와 프레임워크에 의해서 작성이 강제되는 코드를 뜻합니다."),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://dev.to/yysun/ceremony-vs-essence-revisited-5e77"},"Ceremony vs. Essence Revisited")," ",l.createElement("br")," Plain JavaScript vs Svelte vs React vs Vue의 Ceremony 코드 비율 비교"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"ReasonML에서는 import 구문을 쓰지 않아도 컴파일러가 알아서 해당하는 모듈을 찾아줍니다.")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://reasonml.github.io/docs/ko/faq#i-dont-see-any-import-or-require-in-my-file-how-does-module-resolution-work"},"ReasonML에서 모듈 레졸루션은 어떻게 동작하나요?")," ",l.createElement("br"),"\nReason/OCaml doesn't require you to write any import; modules being referred to in the file are automatically searched in the project. Specifically, a module Hello asks the compiler to look for the file hello.re or hello.ml (and their corresponding interface file, hello.rei or hello.mli, if available). ",l.createElement("br"),l.createElement("br"),"\nReason/OCaml은 import 구문이 필요없습니다. 모듈은 프로젝트 안에서 자동적으로 찾아집니다. ",l.createElement(n.code,null,"Hello")," 라는 모듈은 컴파일러를 통해 Hello.re 또는 Hello.ml 파일을 찾습니다. (만약 그에 대응하는 인터페이스 파일인 Hello.rei, Hello.mli이 존재한다면 이것도 같이 찾습니다)"),"\n"),"\n",l.createElement(n.p,null,"ReasonML을 사용해 ",l.createElement(n.code,null,"Farm.re")," 컴포넌트를 만들어보겠습니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"[@react.component]\nlet make = () => {\n  <>\n    <Farmer.Novice>\n      <Greenhouse> <Broccoli /> </Greenhouse>\n      <Greenhouse> <Pumpkin /> </Greenhouse>\n    </Farmer.Novice>\n    <Farmer.Expert>\n      <Greenhouse> <Potato /> </Greenhouse>\n      <Greenhouse> <Pumpkin /> </Greenhouse>\n      <Greenhouse.GableRoof> <Pumpkin /> </Greenhouse.GableRoof>\n      <Greenhouse.GableRoof> <Pumpkin /> </Greenhouse.GableRoof>\n      <Greenhouse.GothicArch> <Broccoli /> </Greenhouse.GothicArch>\n    </Farmer.Expert>\n  </>;\n};\n")),"\n",l.createElement(n.p,null,"어떠한 import 구문도 사용하지 않았지만 ",l.createElement(n.strong,null,"정상 컴파일"),"됩니다. 결과적으로 import로 인한 Ceremony 코드를 줄일 수 있습니다. ReasonML로 된 파일을 열면, 긴 import 구문 대신, 타입 선언과 비즈니스 로직이 제일 위에 보입니다."),"\n",l.createElement(n.h3,null,"2. es-lint, prettier 설정이 필요없는 자체 포매터"),"\n",l.createElement(n.p,null,"ReasonML 포매터(refmt)의 장점은 모듈 레졸루션이 가지는 장점처럼 Ceremony 코드를 줄이는 효과도 있고 다른 장점도 있습니다."),"\n",l.createElement(n.p,null,"자바스크립트와 타입스크립트로 프론트엔드 작업을 했을 때, 린팅 및 포매팅 자동화는 협업의 생산성을 높여줍니다. 하지만 유용하게 사용하기 위해서는 설치하는 패키지가 적지 않습니다."),"\n",l.createElement(n.p,null,"린팅 규칙 설정은 개인 성향이나 회사 성향따라 조금씩 다릅니다. 그래서 특정 벤더의 린팅 규칙을 모태로 확장하거나 축소합니다. 그리고 변경되는 개별 룰에 대해서는 팀의 동의도 얻어야 합니다. 여기다 타입스크립트 규칙이나 리액트만 적용되는 규칙을 추가하고 또 웹 접근성 관련 린팅 규칙을 추가하다보면 ",l.createElement(n.code,null,".eslintrc")," 파일이 결국 프로젝트 라이프사이클에 포함됩니다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"ReasonML 에서는 ",l.createElement(n.code,null,"refmt")," 라는 컴파일러 차원에서 지원해주는 포매터"),"가 있습니다. 또한 ReasonML은 자바스크립트나 타입스크립트가 아니기 때문에 eslint 관련 패키지 설치와 관리가 전혀 필요 없습니다."),"\n",l.createElement(n.p,null,"ReasonML의 핵심 기여자 중 한 명인 Cheng Lou는 ",l.createElement(n.code,null,"refmt"),"에 대해 몇가지 장점을 이야기합니다."),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://medium.com/@chenglou/cool-things-reason-formatter-does-9e1f79e25a82"},"Cool Things Reason Formatter Does - 리즌 포매터가 하는 멋진 일들")," ",l.createElement("br")," Think of it as Prettier or Gofmt but for Reason. - 리즌을 위한 Prettier 또는 Gofmt(Golang 포매터)"),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"코드를 더 읽기 쉽게 시맨틱하게 변경"),"\n",l.createElement(n.li,null,"변경 전과 후의 추상 구문 트리는 동일"),"\n",l.createElement(n.li,null,"공짜 커리(Curring)를 🍛 얻을 수 있음"),"\n",l.createElement(n.li,null,"자바스크립트 interop 때 코드를 알아서 구문 변환"),"\n",l.createElement(n.li,null,"들여쓰기 자동 처리"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://reasonml.github.io/en/try?rrjsx=true&reason=C4TwDgpgBMBOHQLxQDIQIYDMoB8oDkB7AEwgAoBLAO2ABoZ4J64EBKAbgChOAbCYKPADGUAM4BXALZRklYBEmsZAPigBvTlDEB3CsCEALKHIVKNWvGiwqoABk24CJcgDd0PcUyh9MdQRQBzA2AlRFU3D2gAajEpMh8QqBiJSTJYQOCOBwBfTmyuXn4oSRAAFUYZByJSMgctAEZaOqcagCZ6avIAFnorTF6MTFYO5zIANgGsSaHh5s6yAGYRmoBWaenhlvIAdnXUQdZWByzOAClRADoeQgCyFLIS8rYOIA"},"여기서 ",l.createElement(n.strong,null,"Refmt (Reformat)")," 를 바로 테스트해볼 수 있습니다")),"\n",l.createElement(n.h3,null,"3. 타입스크립트보다 읽기 쉬운 컴파일러 오류 메시지"),"\n",l.createElement(n.p,null,"타입스크립트는 정적 타이핑을 가능하게 해줍니다. 덕분에 바닐라 자바스크립트보다 협업하기 좋습니다. 현재 타입스크립트 생태계는 활발하고 문서도 많고 예제도 많기 때문에 타입스크립트로 처음 프론트엔드 개발을 시작하는 것이 어렵지 않습니다."),"\n",l.createElement(n.p,null,"저도 이전까지 타입스크립트에 타입 추론과 타입 체킹에 감탄했고 그 생태계에 여전히 지지를 보냅니다만 아쉬운 점 하나를 말해보겠습니다."),"\n",l.createElement(n.p,null,"타입스크립트는 컴파일 오류 메시지가 읽기 어렵습니다. 친절한 거 같은데 너무 과도해서 무엇이 잘못됐는지 헛갈릴 때가 많습니다. 특히 ",l.createElement(n.code,null,"ts(2322)"),", ",l.createElement(n.code,null,"ts(2345)")," 등이 그랬습니다. 그럼 오류를 안나오는 코드를 만들면 될텐데 사실 그게 쉽지는 않습니다. 🥲"),"\n",l.createElement(n.p,null,"특히 계층 구조 객체 특정 필드의 타입 지정 오류가 생겼을 때, 오류 메시지가 너무 장황하고 길어 정확하게 어떤 부분이 오류인지 찾기 힘들었습니다."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"자세하고 읽기 어려운 타입스크립트 오류 메시지"),"\n",l.createElement(n.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 996px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/3aeb45cead455bfe467c9b1e60118492/5d957/ts-error.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 50.20080321285141%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkUlEQVQoz01S21LCMBDtF/lj/of/os8++e6jOCoDOl5AECjQQtOmadokPc7ZEobM7GQzu3v27NkklXUoG4fWBzSdR+eDmOk8fOhh3fDmHeOlddDWn2Osdb6HaT0S1TiMFgp/xwb7qsXy0OBQd/jJDFZFg8XpvS0tNmqw5bHBZFPhPdX4zQ3m+ZDLvAQAtHUYLZUEMt1K8Gtfi9EvjEOuO+yqFrPMCPjnrsY01XIzh7VkmvR9T0wo4/C2rpCWVjqtCysgZLMqrEzAN4tTZfGx1cj0kBcZspEwjKAEiuOTKcGYPMuN+GTKkRn/PQzTfO9rYUnmzElC6OFCj3ACzetOmDKZI/Lelq1oOj8BE5TaMk72lIxN2FgYxhMumD4tlBTTF5aZETYRiFuW8UsrDbkkMk1eVyVuRxspvATlxhkTndRQFEd9WZXCjD8kLpExNkqu7ya4unmULfPw70VNOdrzUgkris+tj9eVgKanb0T/rHVmkDxMM9yPd6JdXFA0HjKTj++C3FwMzfnhfTQddOvPWv8DIfb7IBNk7QIAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="typescript-error"\n        title="typescript-error"\n        src="/static/3aeb45cead455bfe467c9b1e60118492/5caea/ts-error.png"\n        srcset="/static/3aeb45cead455bfe467c9b1e60118492/6a5fb/ts-error.png 249w,\n/static/3aeb45cead455bfe467c9b1e60118492/79e1b/ts-error.png 498w,\n/static/3aeb45cead455bfe467c9b1e60118492/5caea/ts-error.png 996w,\n/static/3aeb45cead455bfe467c9b1e60118492/7db30/ts-error.png 1494w,\n/static/3aeb45cead455bfe467c9b1e60118492/cc418/ts-error.png 1992w,\n/static/3aeb45cead455bfe467c9b1e60118492/5d957/ts-error.png 5400w"\n        sizes="(max-width: 996px) 100vw, 996px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}})),"\n",l.createElement(n.p,null,"그러나 ReasonML 컴파일러는 오류 메시지는 타입스크립트 오류 메시지보다는 적당히 😅 구체적입니다. 때문에 오류를 찾을 때 더 짧은 시간이 걸렸습니다."),"\n",l.createElement(n.h3,null,"4. 배리언트(Variant)와 패턴 매칭으로 논리적인 코드 생산"),"\n",l.createElement(n.p,null,"잘 돌아가는 코드를 일부러 복잡하게 만드는 일은 누구도 원하지 않겠지만, 조건 렌더링이 필요한 상황은 종종 찾아옵니다."),"\n",l.createElement(n.p,null,"조건의 조건, 조건의 조건의 조건, 조건의 조건의 조건의 조건에 따라 각기 다른 컴포넌트가 렌더링 되어야 할 때도 있습니다. 이 경우 코드를 분리하거나 공통 부분을 추출해 리팩토링 하면 좋을 것입니다."),"\n",l.createElement(n.p,null,"ReasonML은 배리언트를 이용해 논리 전개를 직관적으로 작성할 수 있습니다. 배리언트는 다른 언어의 enums과 비슷하지만 선택적으로 데이터를 포함시키는 것이 가능합니다. 아래는 ",l.createElement(n.strong,null,"로딩, 로드 됨, 오류 3가지 상태"),"에 따라 렌더링하는 간단한 예제입니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"type state =\n  | Loading\n  | Loaded(detail)\n  | Error(error);\n...\n  id->doSomething->Js.Promise.then_((result) => {\n    setData(_prevState => Loaded(result));\n  })\n  |> Js.Promise.catch((error) => {\n    setData(_prevState => Error(error));\n  });\n  switch (data) {\n    | Loading => <Loading />\n    | Loaded(contents) => <Detail contents>\n    | Error(error) => <Error error/>;\n  };\n")),"\n",l.createElement(n.p,null,"GraphQL 쿼리를 포함한 코드도 한 번 보겠습니다. 패턴 매칭을 통해 각 상태를 렌더링합니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"let farm = Query.MyFarm.use({id: int_of_string(id)});\nswitch (farm) {\n  | {loading: true, data: None} => <Spinner />\n  | {error: Some(error)} => <Error error=error/>\n  | {data: None, error: None, loading: false} => <Error />\n  | {data: Some({myFarm})} =>\n    <Farm key={string_of_int(myFarm.id)} farm=myFarm />\n}\n")),"\n",l.createElement(n.p,null,"각 패턴마다 ",l.createElement(n.strong,null,"무엇을, 왜 렌더링"),"하는지 쉽게 읽힙니다. 배리언트와 패턴매칭은 상태 관련 렌더링 코드 쓰기에 효과적입니다."),"\n",l.createElement(n.p,null,"패턴매칭과 배리언트의 또한가지 장점은 서술되지 않은 케이스에 대해서는 Warning으로 알려줘서 모든 case에 대해 렌더링 코드를 작성하게끔 도와줍니다."),"\n",l.createElement(n.p,null,"처음 예시의 코드에서 ",l.createElement(n.code,null,"Loaded")," 케이스를 제외해보겠습니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"type state =\n  | Loading\n  | Loaded(detail)\n  | Error(error);\n...\nswitch (data) {\n  | Loading => <Loading />\n  | Error(error) => <Error error/>;\n};\n")),"\n",l.createElement(n.p,null,"이러면 나머지 케이스(즉, 여기서는 ",l.createElement(n.code,null,"Loaded"),") 대해 렌더링 코드를 작성하지 않았음을 명시적으로 알려줍니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-sh"},"Warning 8: You forgot to handle a possible case here, for example:\n  Loaded _\n")),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"배리언트와 패턴매칭은 코드로 쓰여진 논리가 허술하지 않도록 도와줍니다.")),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://rescript-lang.org/docs/manual/latest/variant"},"배리언트 공식 문서")," ",l.createElement("br")," ",l.createElement(n.a,{href:"https://rescript-lang.org/docs/manual/latest/pattern-matching-destructuring"},"패턴매칭/구조분해 공식 문서")),"\n"),"\n",l.createElement(n.h3,null,"5. 컴파일 시점에 CSS 타입 체크"),"\n",l.createElement(n.p,null,"올바른 CSS를 작성했는지 확인하기 위해 스타일 관련 린팅 도구를 설치해본 적 있으신가요? ",l.createElement(n.a,{href:"https://2020.stateofcss.com/en-US/technologies/other-tools/"},"State of CSS 2020")," 에서는 설문에 참여한 ",l.createElement(n.code,null,"43.2%"),"중 ",l.createElement(n.code,null,"75%"),"의 개발자가 ",l.createElement(n.code,null,"Stylelint"),"를 사용한다고 답변했습니다."),"\n",l.createElement(n.p,null,"자바스크립트 생태계에서 CSS를 작성하는 방식은 여러가지가 있습니다. 그린랩스는 CSS-in-CSS와 CSS-in-JS를 상황에 따라 결정해 사용합니다. 여기서는 CSS-in-JS 자체에 대해서는 깊게 다루지 않겠습니다. (위의 State of CSS 2020을 참고해주세요!)"),"\n",l.createElement(n.p,null,"저는 프론트엔드 개발자로서 ",l.createElement(n.strong,null,"스타일링 버그도 프로젝트에 따라 서비스에 치명적인 상처"),"를 줄 수 있는 부분이라 생각합니다. 개발자가 단위를 혼동하거나 쓸 수 없는 속성을 넣을 경우, 기대했던 디자인이 나오지 않거나 어쩌면 기능이 오동작하기도 합니다. 때문에 간단한 스타일링 실수로도 나쁜 사용자 경험을 만들수 있습니다."),"\n",l.createElement(n.p,null,"ReasonML에서는 ",l.createElement(n.a,{href:"https://github.com/reasonml-labs/bs-css"},"bs-css")," 패키지를 통해 컴파일 시점에 CSS 체크가 가능합니다. bs-css의 사용 방법은 CSS-in-JS 라이브러리로 유명한 ",l.createElement(n.code,null,"Emotion"),"인터페이스와 유사합니다. (Emotion을 ReasonML에서 쓸 수 있도록 바인딩했기 때문입니다. ",l.createElement(n.a,{href:"https://rescript-lang.org/docs/manual/latest/external"},"바인딩"),"에 대해서는 다른 포스팅에서 다루겠습니다)"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},'module Styles = {\n  open Css;\n  let card = style([\n    display(flexBox),\n    flexDirection(column),\n    alignItems(stretch),\n    backgroundColor(white),\n    boxShadow(Shadow.box(~y=px(3), ~blur=px(5), rgba(0, 0, 0, 0.3))),\n  ]);\n  let actionButton = disabled =>\n    style([\n      background(disabled ? darkgray : white),\n      color(black),\n      border(px(1), solid, black),\n      borderRadius(px(3)),\n    ])\n};\n<div className=Styles.card>\n  <h1 className=Styles.title> "Hello"->React.string </h1>\n  <button className=Styles.actionButton(false) />\n</div>\n')),"\n",l.createElement(n.p,null,"스타일링과 관계 된 패키지 중 또 하나 소개하고 싶은 라이브러리가 있습니다. ReasonML 문법 안에서 ",l.createElement(n.code,null,"styled-component")," 형식으로 스타일 작성을 도와주는 ",l.createElement(n.strong,null,l.createElement(n.a,{href:"https://github.com/davesnx/styled-ppx"},"styled-ppx"))," 입니다."),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"styled"),"는 느낌적인 느낌으로 알겠는데 ",l.createElement(n.code,null,"ppx"),"는 뭘까요?"),"\n",l.createElement(n.p,null,"ReasonML의 부모인 OCaml에는 **",l.createElement(n.a,{href:"https://ocamlverse.github.io/content/ppx.html"},"PPX(PreProcessor eXtensions)"),"**라는 기능이 있습니다. PPX를 통해 문법적 확장이 가능합니다. 마치 새로운 문법이 만들어진 것처럼 구문을 작성할 수 있습니다."),"\n",l.createElement(n.p,null,"다음은 styled-ppx를 이용해 컴포넌트를 작성한 예시입니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"module Title = [%styled.h1\n  {|\n    font-size: 1.5rem;\n    font-weight: 700;\n  |}\n];\nmodule Description = [%styled.p\n  {|\n    color: #76798A;\n  |}\n];\n<>\n  <Title> {j|Like-Styled-Component|j}->React.string </Title>\n  <Description> {j|How About This?|j}->React.string </Description>\n</>\n")),"\n",l.createElement(n.p,null,"PPX에 대한 설명은 쉽지 않기 때문에 다른 포스팅에서 더 깊게 다루겠습니다. 😅 궁금하신 분은 밑의 링크를 참고해주세요!"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://ppxlib.readthedocs.io/en/latest/what-is-ppx.html"},"What is PPX?")),"\n"),"\n",l.createElement(n.p,null,"중요한 것은 ",l.createElement(n.code,null,"bs-css"),"를 사용하든 ",l.createElement(n.code,null,"styled-ppx"),"를 사용하든 ",l.createElement(n.strong,null,"컴파일 시점에 CSS 프로퍼티에대해 타입체킹")," 받을 수 있다는 사실입니다. 각 프로퍼티에 맞지 않는 타입을 넣으면 컴파일이 안 됩니다! 👍  "),"\n",l.createElement(n.p,null,"혹시 스타일까지 타입체킹을 받는 건 가혹하다 생각하시나요? 😉 이 부분은 팀마다 다른 결론이 나올 것 같습니다만 그린랩스 웹 개발팀에서는 ",l.createElement(n.code,null,"bs-css"),"의 사용비중을 높게 가져가고 있습니다!"),"\n",l.createElement(n.h3,null,"6. GraphQL 사용할 때 전방위적 타입 체크"),"\n",l.createElement(n.p,null,"그린랩스 백엔드와 프론트엔드팀은 GraphQL 스키마를 공통으로 사용합니다. 프론트엔드에서는 GraphQL에 대한 타입체킹 및 ReasonML 문법 확장을 위해 ",l.createElement(n.a,{href:"https://graphql-ppx.com/"},"graphql-ppx"),"를 사용합니다."),"\n",l.createElement(n.p,null,"이런 스키마가 있습니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-graphql"},"...\ntype MyFarm {\n  id: Int!\n  name: String!\n  area: Float!\n  crop: Crop!\n}\n...\n")),"\n",l.createElement(n.p,null,"ReasonML 설정 파일인 ",l.createElement(n.code,null,"bsconfig.json"),"에 graphql-ppx 의존성을 추가하면 위 스키마로 ",l.createElement(n.strong,null,"Fragment와 Query"),"를 ReasonML 문법으로 작성할 수 있습니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"[%graphql\n{|\n  fragment Farm on MyFarm {\n    id\n    name\n    crop {\n      ...Crop\n    }\n  }\n|}\n];\nmodule MyFarm = [%graphql\n  {|\n    query myFarm($id:Int!){\n      myFarm(id:$id){\n        ...Farm\n      }\n    }\n  |}\n];\n")),"\n",l.createElement(n.p,null,"위 ReasonML 코드를 작성하면 graphql-ppx가 ",l.createElement(n.code,null,"MyFarm"),"에 대해 타입을 자동 생성합니다. (이 코드를 개발자가 작성할 필요 없습니다)"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-reason"},"type t = {\n  __typename: string,\n  id: int,\n  name: string,\n  crop: Crop.t\n}\n")),"\n",l.createElement(n.p,null,"그럼 컴파일러는 위 타입을 기준으로 타입검사를 해줍니다. IDE에서 자동완성과 타입힌트 역시 추가적으로 누릴 수 있습니다. 덕분에 쿼리 또는 뮤테이션을 올바르게 작성했는지 알려주고, 사용처에서 올바른 타입을 사용하는지 알려줍니다."),"\n",l.createElement(n.p,null,"프로덕션 스키마의 크기는 예제와 비교할 수 없을만큼 늘어날겁니다. 그럴 때 주의하지 않으면 놓칠 수 있는 부분을 ",l.createElement(n.strong,null,"ReasonML + graphql-ppx의 도움으로 컴파일 시점에 방지"),"할 수 있습니다."),"\n",l.createElement(n.h3,null,"7. 그밖에 장점이라 느낀 것"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"비슷한 규모의 타입스크립트 프로젝트보다 빠른 빌드 속도를 체감했습니다. 현재 Github 액션을 통해 빌드 및 배포를하고 있습니다. ReasonML 빌드 시간은 11초가 걸립니다. Webpack 빌드를 포함하면 1분 30초 이내로 모든 빌드가 완료됩니다.",l.createElement(n.a,{href:"%5BTypeScript-VS-ReasonML%5D(https://blog.dubenko.dev/typescript-vs-reason/)"},"^1")),"\n",l.createElement(n.li,null,"타입스크립트로 프로젝트를 진행했을 때보다 타입정의를 덜 했지만, 더 타입추론이 잘 된다고 느꼈습니다. 때문에 인터페이스나 타입작성을 많이 할 필요가 없었습니다.[^2]"),"\n"),"\n",l.createElement(n.h2,null,"정리"),"\n",l.createElement(n.p,null,"위에 나열한 장점 말고도 다른 팀원 분이 올려주신 ",l.createElement(n.a,{href:"/what-is-reason-ml"},"포스팅"),"에도 장점이 많이 설명 되어있습니다. 시간이 괜찮으시다면 읽어보시는 걸 추천드립니다. ReasonML의 매력을 좀 더 느낄 수 있습니다."),"\n",l.createElement(n.p,null,"물론 이 포스팅에서는 장점만 이야기했습니다. 그러나 ",l.createElement(n.strong,null,"IDE 지원 미비, 불편한 유니코드 사용 방법, 아직 부족한 공식문서 등"),"은 단점입니다. 단점은 다른 포스팅에서 더 자세히 다룰 예정입니다."),"\n",l.createElement(n.p,null,"그리고 개발 환경구성을 타입스크립트로 구성할 때보다 금방할 수 있었습니다. 불필요한 패키지 설정과 트랜스파일 설정이 필요없기 때문입니다."),"\n",l.createElement(n.p,null,"불필요한 패키지 설치와 린팅 설정, import 구문 사용은 결국 Ceremony 코드에 가깝습니다. 그린랩스 웹 개발팀은 ReasonML을 사용해 프론트엔드 개발을 하며 많은 Ceremony 코드를 줄였고 ",l.createElement(n.strong,null,"핵심 로직 개발에 더 집중"),"할 수 있었습니다."),"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://greenlabs.co.kr/%EC%B1%84%EC%9A%A9%EC%A0%95%EB%B3%B4/%EC%B1%84%EC%9A%A9%EC%A0%95%EB%B3%B4/"},"저희와 ReasonML에 대해 같이 이야기 나누실 분을 애타게 기다리고 있습니다. 😃🐫")),"\n",l.createElement(t,{email:"yousleepwhen@gmail.com",name:"윤정식",description:"프론트엔드 개발자",date:"2020-12-15"}),"\n",l.createElement(n.p,null,"[^2]: ",l.createElement(n.a,{href:"https://codeburst.io/inference-engines-5-examples-with-typescript-flow-and-reason-edef2f4cf2d3"},"5 examples with TypeScript, Flow and ReasonML")),"\n",l.createElement("hr"),"\n",l.createElement(n.h4,null,"Thanks to"),"\n",l.createElement(n.p,null,"프리뷰 해주신 ",l.createElement(n.strong,null,"change.my.uniform")," 채널 분들께 감사드립니다."))}var o=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?l.createElement(n,e,l.createElement(r,e)):r(e)};var c=t(3710);function s(e){return l.createElement(c.Z,e,l.createElement(o,e))}c.Z}}]);
//# sourceMappingURL=component---src-templates-post-query-tsx-content-file-path-users-namenu-green-tech-blog-content-posts-reasonable-reason-index-mdx-a91d0bdc0f5222756c77.js.map