"use strict";(self.webpackChunkmy=self.webpackChunkmy||[]).push([[760],{1943:function(e,n,l){l.r(n),l.d(n,{default:function(){return m}});var t=l(7294),a=l(9626);function r(e){var n=Object.assign({blockquote:"blockquote",p:"p",br:"br",a:"a",hr:"hr",code:"code",h2:"h2",strong:"strong",pre:"pre",h3:"h3",ol:"ol",li:"li",h4:"h4",ul:"ul"},(0,a.ah)(),e.components),l=n.Author;return l||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Author",!0),t.createElement(t.Fragment,null,t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"이 글은 ReasonML에 대한 약간의 이해가 필요합니다.",t.createElement(n.br),"\n","ReasonML에 대한 소개는 ",t.createElement(n.a,{href:"/what-is-reason-ml"},"여기"),"를,",t.createElement(n.br),"\n","ReasonML 문법에 대한 소개는 ",t.createElement(n.a,{href:"https://rescript-lang.org/docs/manual/latest/overview"},"여기"),"를 참고해주세요."),"\n"),"\n",t.createElement(n.hr),"\n",t.createElement(n.p,null,"ReasonML에서 가장 유용한 기능을 꼽으라면 단연 배리언트와 패턴매칭일 것입니다.\n여기에 더해 ReasonML에는 일반 배리언트보다 조금 특별한 폴리모픽 배리언트라는 것이 있습니다."),"\n",t.createElement(n.p,null,"폴리모픽 배리언트는 ",t.createElement(n.code,null,"bs-css")," 같은 프로젝트나 바인딩 라이브러리를 다루다 보면 빈번하게 마주하게 됩니다.\n그래서 구체적으로 어떤 개념인지 잘 몰라도 일단 사용하는 것에는 큰 어려움이 없습니다."),"\n",t.createElement(n.p,null,"그렇지만 실제 동작 원리를 알아두면 더 좋을 것입니다.\n블로그를 작성하는 현시점까지 ReScript 공식 문서에는 폴리모픽 배리언트에 대한 설명이 나와있지 않기에,\n이 글에서는 폴리모픽 배리언트의 개념과 이것이 언제 필요한지에 대해 다루어보겠습니다."),"\n",t.createElement(n.p,null,"본문의 예시는 Real World OCaml[^1]과 OCaml 공식 문서[^2]를 참고하였으며, ReasonML 버전으로 재작성하였습니다."),"\n",t.createElement(n.h2,null,"기본적인 문법"),"\n",t.createElement(n.p,null,"폴리모픽 배리언트는 ",t.createElement(n.strong,null,"타입 선언 없이")," 바로 사용할 수 있는 것이 가장 큰 특징입니다."),"\n",t.createElement(n.p,null,"일반 배리언트와 다른게 반드시 대문자로 시작할 필요가 없지만, 태그에 백틱(",t.createElement(n.code,null,"`"),")을 붙여주어야 합니다.\n참고로 ReasonML과는 사촌지간인 리스크립트(ReScript)에서는 해시(",t.createElement(n.code,null,"#"),")를 붙이는 것으로 문법이 바뀌었습니다.\n리스크립트는 최대한 자바스크립트와 비슷한 문법을 지향하는데, 자바스크립트의 문자열 인터폴레이션과 헷깔리기 때문에 바꾸었다고 합니다."),"\n",t.createElement(n.p,null,"아래는 폴리모픽 배리언트의 예입니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"let three = `Int(3);\n/* [> `Int(int) ] */\n\nlet four = `Float(4.0);\n/* [> `Float(float) ] */\n\nlet nan = `Not_a_number;\n/* [> `Not_a_number ] */\n\n[three, four, nan];\n/* list( [> `Float(float) | `Int(int) | `Not_a_number ] ) */\n")),"\n",t.createElement(n.p,null,"보다시피 별도의 타입 선언 없이 쓸 수 있으며, 배리언트의 태그들이 대괄호(",t.createElement(n.code,null,"[]"),")로 감싸져 있는 것이 특징입니다.\n그리고 리스트에 섞어 쓰면 그 결과에 대응되는 새로운 타입도 추론해 줍니다."),"\n",t.createElement(n.p,null,"참고로 배열에 대해서는 타입 추론이 되지 않고 컴파일 에러가 발생합니다.\n이는 OCaml🐫 구현의 영향을 받은 것인데, 배열은 성능을 위해 사용되는 자료구조이기 때문인 것으로 추측됩니다."),"\n",t.createElement(n.p,null,"당연하지만 아래와 같이 태그를 혼용하는 것은 안됩니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},'let five = `Int("five")\n/* [> `Int(string) ] */\n\n[three, four, five]\n\n/*\nThis has type: [> `Int(string) ]\nSomewhere wanted: [> `Float(float) | `Int(int) ]\nTypes for tag `Int are incompatible\n*/\n')),"\n",t.createElement("br"),"\n",t.createElement(n.h3,null,"폴리모픽 배리언트의 범위(bounds)"),"\n",t.createElement(n.p,null,"아까부터 자동 추론되는 타입 앞에는 ",t.createElement(n.code,null,">")," 문자가 보입니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"[three, four];\n/* [> `Float(float) | `Int(int) ] */\n")),"\n",t.createElement(n.p,null,"이런 식으로요."),"\n",t.createElement(n.p,null,t.createElement(n.code,null,">"),"로 시작하는 타입의 의미는 다음과 같습니다."),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"열거된 태그들을 포함하기만 하면 기타 다른 태그를 포함해도 됨"),"\n"),"\n",t.createElement(n.p,null,'위 예시는 "',t.createElement(n.code,null,"Float(float)"),"와 ",t.createElement(n.code,null,"Int(int)"),"를 포함, ",t.createElement(n.strong,null,"그리고"),' 추가적으로 다른 태그도 포함할 수 있는 타입"의 폴리모픽 배리언트를 의미합니다.\n이를 폴리모픽 배리언트의 하계(a lower bound)라고 합니다.'),"\n",t.createElement(n.p,null,"반대로 컴파일러가 배리언트의 타입을 ",t.createElement(n.code,null,"<"),"로 추론하는 경우가 있습니다.\n아까와는 부등호 방향이 반대입니다.\n눈치채셨겠지만 이를 폴리모픽 배리언트의 상계(an upper bound)라고 합니다.\n",t.createElement(n.code,null,"<"),"로 시작하는 타입의 의미는 다음과 같습니다."),"\n",t.createElement(n.blockquote,null,"\n",t.createElement(n.p,null,"열거된 태그들로 선언되거나 ",t.createElement(n.strong,null,"혹은")," 그보다 부족하게만 선언되면 문제없음"),"\n"),"\n",t.createElement(n.p,null,"예시를 들어보겠습니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"let isPositive = x =>\n  switch (x) {\n  | `Int(i) => i > 0\n  | `Float(f) => f > 0.\n  };\n/* [< `Float(float) | `Int(int) ] => bool */\n")),"\n",t.createElement(n.p,null,"위 함수의 반환 타입이 ",t.createElement(n.code,null,"<")," 인 이유는, ",t.createElement(n.code,null,"Float"),", ",t.createElement(n.code,null,"Int")," 이외의 태그가 들어가면 함수 내부의 스위치 문에서 대응이 안되기 때문입니다.\n이는 안전하지 못한 코드를 의미하므로 컴파일러가 통과시키지 않습니다."),"\n",t.createElement(n.p,null,"참고로 상계와 하계가 동일한 경우에는 ",t.createElement(n.code,null,"<"),", ",t.createElement(n.code,null,">")," 표기가 없어집니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"let exact = Belt.List.keep([three, four], isPositive);\n/* Belt.List.t( [ `Float(float) | `Int(int) ] ) */\n")),"\n",t.createElement(n.p,null,"상계와 하계가 다른 경우도 만들어낼 수 있습니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},'let isPositive = x =>\n  switch (x) {\n  | `Int(i) => Ok(i > 0)\n  | `Float(f) => Ok(f > 0.)\n  | `Not_a_number => Error("not a number")\n  };\n\nlet exact =\n  Belt.List.keep([three, four], x => {\n    switch (isPositive(x)) {\n    | Error(_) => false\n    | Ok(v) => v\n    }\n  });\n/* Belt.List.t( [< `Float(float) | `Int(int) | `Not_a_number > `Float `Int ] )\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~   */\n')),"\n",t.createElement(n.p,null,"추론된 타입이 좀 복잡해 보이지만 천천히 살펴보면 그리 어렵지 않습니다.\n이 타입은 Float, Int, NaN 이외의 것을 받을 수는 없지만, 적어도 Float와 Int는 포함해야 함을 의미합니다."),"\n",t.createElement(n.h2,null,"폴리모픽 배리언트가 필요한 순간"),"\n",t.createElement(n.p,null,"실전에서 폴리모픽 배리언트가 일반 배리언트보다 유용한 사례를 알아보겠습니다."),"\n",t.createElement(n.p,null,"색상을 다루어야 하는 상황을 가정해 봅시다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"/* 익숙한 일반 배리언트를 사용하여 타이핑 */\ntype color =\n  | RGB(int, int, int) /* 6x6x6 color cube */\n  | Gray(int); /* 24 grayscale */\n\nlet colorToInt = c =>\n  switch (c) {\n  | RGB(r, g, b) => 16 + b + g * 6 + r * 36\n  | Gray(i) => 232 + i\n  };\n")),"\n",t.createElement(n.p,null,"색상은 RGB 또는 흑백으로 표현할 수 있고, 이를 정수로 변환할 수 있는 로직입니다.\n여기서 요구사항이 바뀌어 투명도를 포함한 색깔을 추가로 다루어야 한다고 해봅시다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"type extColor =\n  | RGB(int, int, int)\n  | Gray(int)\n  | RGBA(int, int, int, int); /* 🆕 6x6x6x6 color space */\n")),"\n",t.createElement(n.p,null,"기존 로직에 영향을 주지 않기 위해 ",t.createElement(n.code,null,"color")," 타입을 수정하지 않고 새롭게 선언했습니다.\n여기까지는 좋습니다.\n문제는 아까와 비슷하게 ",t.createElement(n.code,null,"extColorToInt"),"라는 함수를 작성하는 순간입니다.\n단순한 타입이 아니라 로직의 구현이기 때문에, 기존 ",t.createElement(n.code,null,"colorToInt")," 로직을 재사용하고자 합니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"let extColorToInt = c =>\n  switch (c) {\n  | RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | (RGB(_) | Gray(_)) as c' => colorToInt(c')\n  };\n\n/*\nThis has type: extColor\nSomewhere wanted: color\n*/\n")),"\n",t.createElement(n.p,null,"하지만 위와 같이 작성한 코드는 동작하지 않습니다."),"\n",t.createElement(n.p,null,"사람이 보기에는 문제없는 코드 같지만, 컴파일러가 보기에는 ",t.createElement(n.code,null,"extColor"),"와 ",t.createElement(n.code,null,"color"),"가 서로 전혀 다른 타입이기 때문입니다.\n에러의 의미도 그것입니다."),"\n",t.createElement(n.p,null,"하지만 우리가 원하는 것은 저 여지껏 사용된 태그가 적절히 재사용되는 것입니다."),"\n",t.createElement(n.h3,null,"폴리모픽 배리언트로"),"\n",t.createElement(n.p,null,"단순히 일반 배리언트를 폴리모픽 배리언트로 바꿔보겠습니다."),"\n",t.createElement(n.ol,null,"\n",t.createElement(n.li,null,"기존 코드에서 ",t.createElement(n.code,null,"type")," 으로 선언된 부분은 날려버리고"),"\n",t.createElement(n.li,null,"패턴매칭에서 백틱(`)만 찍어주면 됩니다."),"\n"),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"let colorToInt = c =>\n  switch (c) {\n  | `RGB(r, g, b) => 16 + b + g * 6 + r * 36\n  | `Gray(i) => 232 + i\n  };\n/* [< `Gray(int) | `RGB(int,int,int) ] => int */\n\nlet extColorToInt = c =>\n  switch (c) {\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | (`RGB(_) | `Gray(_)) as c' => colorToInt(c')\n  };\n/* [< `Gray(int) | `RGB(int,int,int) | `RGBA(int,int,int,int) ] => int */\n")),"\n",t.createElement(n.p,null,"이번에는 문제없이 ",t.createElement(n.code,null,"extColorToInt"),"가 컴파일됐습니다.\n그리고 컴파일이 되었으니 문제가 없는 것은 분명합니다.\n원했던 대로 ",t.createElement(n.code,null,"c'"),"의 타입이 절절히 축소되어(extColor -> color) ",t.createElement(n.code,null,"colorToInt"),"의 인자로 전달되었습니다."),"\n",t.createElement(n.p,null,"그런데 매칭 구문이 조금 지저분해 보이는데, 차라리 catch-all로 받아버리면 어떨까요?"),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"let extColorToInt = c =>\n  switch (c) {\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\n  | c' => colorToInt(c')\n  };\n\n/*\nThis has type: [> `RGBA(int, int, int, int) ]\nSomewhere wanted: [< `Gray(int) | `RGB(int, int, int) ]\nThe second variant type does not allow tag(s) `RGBA\n*/\n")),"\n",t.createElement(n.p,null,"아쉽게도 컴파일은 되지 않습니다.\n에러가 친절히 알려주다시피 ",t.createElement(n.code,null,"c'"),"의 타입이 굉장히 느슨하게 추론되기 때문입니다."),"\n",t.createElement(n.p,null,"그 이유는 어렵지 않게 추측할 수 있습니다.\n타입을 별도로 선언하지 않았기 떄문에 ",t.createElement(n.code,null,"c'"),"는 어떤 태그도 될 수 있는 반면, ",t.createElement(n.code,null,"colorToInt"),"는 상계가 있기 때문입니다."),"\n",t.createElement("br"),"\n",t.createElement(n.h4,null,"⚠️ Catch-all 매칭 ⚠️"),"\n",t.createElement(n.p,null,"앞서 ",t.createElement(n.code,null,"isPositive"),"에서 보았듯이, 함수 본문의 패턴매칭은 배리언트의 상계에 영향을 미칩니다.\n그렇지만 패턴매칭에 catch-all을 넣는 순간 반대로 아래와 같이 하계만 결정되고 위로는 제약이 풀려버립니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},'let isPositivePermissive = x =>\n  switch (x) {\n  | `Int(i) => Ok(i > 0)\n  | `Float(f) => Ok(f > 0.)\n  | _ => Error("Unknown number type")\n  };\n/* [> `Float(float) | `Int(int) ] => ... */\n\nisPositivePermissive(`Int(0));\n/* Ok(false) */\nisPositivePermissive(`Ratio(3, 4));\n/* Error("Unknown number type") */\n')),"\n",t.createElement(n.p,null,"Catch-all 케이스는 일반 배리언트에서도 에러를 일으키지 쉽지만, 폴리모픽 배리언트에서는 더 심합니다.\n왜냐하면 위 예시처럼 코드가 작성된 경우 실수로 오타를 입력해도 컴파일러가 어떤 불평도 하지 않기 때문입니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},'isPositivePermissive(`Floot(3.05));\n/* Error("Unknown number type") */\n')),"\n",t.createElement(n.p,null,"만약 일반 배리언트였다면 이러한 문제는 없었을 것입니다.\n그러니 폴리모픽 배리언트를 쓸 때에는 catch-all 사용에 주의해야 합니다."),"\n",t.createElement(n.h2,null,"일반 배리언트 vs. 폴리모픽 배리언트"),"\n",t.createElement(n.p,null,"지금까지의 설명으로는 폴리모픽 배리언트가 일반 배리언트의 상위 호환처럼 느껴집니다.\n약간만 주의하면 일반처럼 쓸 수도 있고, 더 유연하면서 간결하고요."),"\n",t.createElement(n.p,null,"그렇지만 대부분의 설계에서는 ",t.createElement(n.strong,null,"일반 배리언트가")," 더 좋은 선택이라고 합니다.\n폴리모픽 배리언트는 그 유연함의 대가로 아래와 같은 단점을 가집니다."),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"더 높은 복잡도","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"동작 방식이 일반 배리언트보다 복잡하기 때문에, 이것을 마구 쓰다가 컴파일이 잘 안되는 상황이 발생했을 때 컴파일러가 뱉어내는 에러메세지가 굉장히 난해해지곤 합니다.\n일반적으로 ",t.createElement(n.strong,null,"값 수준에서 구현을 단순하게 할수록 타입 수준에서 구현 복잡도가 증가"),"하는 경향이 있습니다."),"\n"),"\n"),"\n",t.createElement(n.li,null,"더 어려운 디버깅","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"타입 시스템이 유연할수록 프로그램의 버그를 찾기 어렵다고 합니다.\n폴리모픽 배리 역시 타입 안전하긴 하지만, 그 유연함 때문에 에러를 찾기가 좀 더 어려워지는 경향이 있습니다."),"\n"),"\n"),"\n",t.createElement(n.li,null,"낮은 성능","\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"크게 심각한 것은 아니지만 폴리모픽 배리언트는 일반보다 구현이 좀 복잡합니다.\n또한 컴파일러가 패턴매칭을 일반 배리언트만큼 효율적으로 처리하는 코드를 생성할 수 없습니다."),"\n"),"\n"),"\n"),"\n",t.createElement(n.p,null,"이런 단점에도 폴리모픽 배리언트는 여전히 매우 강력하고 유용합니다.\n장점을 다시 정리해보자면,"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"재사용성"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"생성자가 매우 다양한 경우에 유용합니다.\n예를 들어 문자열 인코딩을 종류별로 다뤄야 한다고 했을 때, 이를 미리 선언하지 않고 사용할 수 있어 편리합니다.","\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"type encoding = [ |`base64 | `ascii | `latin1 | `utf8 | `hex ... ]\n/* 수 많은 인코딩을 일일히 나열하고 싶지 않습니다. 😕 */\n")),"\n"),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"디커플링"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"명시적인 타입 선언을 해야 한다면 이를 사용하는 모든 곳에서 의존성을 갖게 되므로 모듈 관리 비용이 들어갑니다.\n하지만 타입 선언이 필요치 않기 때문에 태그에 대한 약속은 공유하되 완전히 디커플링된 설계를 할 수 있습니다."),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"확장성"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"배리언트가 추후 확장되도록 설계할 수 있습니다. 위의 ",t.createElement(n.code,null,"extColorToInt"),"가 그 간단한 예입니다.\n현실적인 예는 ",t.createElement(n.a,{href:"http://graphql-ppx.com/"},"graphql-ppx"),"에서도 찾아볼 수 있습니다.\ngraphql-ppx는 스키마의 enum에 대해 폴리모픽 배리언트를 자동 생성하는데, 생성되는 타입은 암묵적으로 ",t.createElement(n.code,null," `FutureAddedValue(_)"),"라는 태그를 포함하게 됩니다."),"\n",t.createElement(n.pre,null,t.createElement(n.code,{className:"language-reason"},"type t_someQuery_enumField = [\n  | `FutureAddedValue(string)\n  | `FIRST\n  | `SECOND\n];\n")),"\n",t.createElement(n.p,null,"따라서 클라이언트에서는 위와 같이 ",t.createElement(n.code,null," `FutureAddedValue")," 매칭 코드 작성이 강제되는데, 덕분에 서버 스키마가 조용히 변경되어 새로운 enum 값이 전달되더라도 클라이언트 런타임에러가 발생하지 않도록 해줍니다."),"\n"),"\n"),"\n"),"\n",t.createElement(n.li,null,"\n",t.createElement(n.p,null,"간결함"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,"생성자가 전역 네임스페이스에 있기 때문에 별도로 모듈을 open할 필요가 없습니다.\n또, 별로 중요하지 않은 곳에서 적당히 태그를 만들어 사용하고 버리기에 편리합니다."),"\n"),"\n"),"\n"),"\n",t.createElement(n.h2,null,"맺음말"),"\n",t.createElement(n.p,null,"지금까지 살펴본 내용만으로도 폴리모픽 배리언트를 사용하는 것에는 큰 지장이 없습니다.\n하지만 타입의 상계와 하계가 어떻게 결정되는지 그 동작 방식에 대해 이해하는 것도 좋을 것입니다.\n다음 글에서는 폴리모픽 타입의 추론 과정(unification)이 어떻게 동작하는지 다루어보겠습니다."),"\n",t.createElement("br"),"\n",t.createElement("br"),"\n",t.createElement(l,{email:"hw.nam@greenlabs.co.kr",name:"남현우",description:"소프트웨어 엔지니어",date:"2020-12-01"}),"\n",t.createElement("br"),"\n",t.createElement("br"),"\n",t.createElement(n.h4,null,"참고자료"),"\n",t.createElement(n.ul,null,"\n",t.createElement(n.li,null,t.createElement(n.a,{href:"https://2ality.com/2018/01/polymorphic-variants-reasonml.html"},"2ality - ReasonML: polymorphic variant types")),"\n",t.createElement(n.li,null,t.createElement(n.a,{href:"https://github.com/bobzhang/ocaml-book/blob/master/lang/features.org#polymorphic-variants"},"OCaml Book, Hongbo Zhang")),"\n"),"\n",t.createElement(n.p,null,"[^1]: ",t.createElement(n.a,{href:"https://dev.realworldocaml.org/variants.html"},"Real World OCaml"),"\n[^2]: ",t.createElement(n.a,{href:"https://ocaml.org/manual/lablexamples.html#s%3Apolymorphic-variants"},"Polymorphic Variants")))}var c=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?t.createElement(n,e,t.createElement(r,e)):r(e)};var o=l(6488);function m(e){return t.createElement(o.Z,e,t.createElement(c,e))}o.Z}}]);
//# sourceMappingURL=component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-polymorphic-variants-index-mdx-53efab1fcabb5c753d95.js.map