{"version":3,"file":"component---src-templates-post-query-tsx-content-file-path-users-hyejin-documents-tech-blog-content-posts-polymorphic-variants-index-mdx-47932ccf134b4f2b39df.js","mappings":"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","sources":["webpack://my/./content/posts/polymorphic-variants/index.mdx","webpack://my/./src/templates/post-query.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    blockquote: \"blockquote\",\n    p: \"p\",\n    br: \"br\",\n    a: \"a\",\n    hr: \"hr\",\n    code: \"code\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\",\n    h4: \"h4\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components), {Author} = _components;\n  if (!Author) _missingMdxReference(\"Author\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"이 글은 ReasonML에 대한 약간의 이해가 필요합니다.\", React.createElement(_components.br), \"\\n\", \"ReasonML에 대한 소개는 \", React.createElement(_components.a, {\n    href: \"/what-is-reason-ml\"\n  }, \"여기\"), \"를,\", React.createElement(_components.br), \"\\n\", \"ReasonML 문법에 대한 소개는 \", React.createElement(_components.a, {\n    href: \"https://rescript-lang.org/docs/manual/latest/overview\"\n  }, \"여기\"), \"를 참고해주세요.\"), \"\\n\"), \"\\n\", React.createElement(_components.hr), \"\\n\", React.createElement(_components.p, null, \"ReasonML에서 가장 유용한 기능을 꼽으라면 단연 배리언트와 패턴매칭일 것입니다.\\n여기에 더해 ReasonML에는 일반 배리언트보다 조금 특별한 폴리모픽 배리언트라는 것이 있습니다.\"), \"\\n\", React.createElement(_components.p, null, \"폴리모픽 배리언트는 \", React.createElement(_components.code, null, \"bs-css\"), \" 같은 프로젝트나 바인딩 라이브러리를 다루다 보면 빈번하게 마주하게 됩니다.\\n그래서 구체적으로 어떤 개념인지 잘 몰라도 일단 사용하는 것에는 큰 어려움이 없습니다.\"), \"\\n\", React.createElement(_components.p, null, \"그렇지만 실제 동작 원리를 알아두면 더 좋을 것입니다.\\n블로그를 작성하는 현시점까지 ReScript 공식 문서에는 폴리모픽 배리언트에 대한 설명이 나와있지 않기에,\\n이 글에서는 폴리모픽 배리언트의 개념과 이것이 언제 필요한지에 대해 다루어보겠습니다.\"), \"\\n\", React.createElement(_components.p, null, \"본문의 예시는 Real World OCaml[^1]과 OCaml 공식 문서[^2]를 참고하였으며, ReasonML 버전으로 재작성하였습니다.\"), \"\\n\", React.createElement(_components.h2, null, \"기본적인 문법\"), \"\\n\", React.createElement(_components.p, null, \"폴리모픽 배리언트는 \", React.createElement(_components.strong, null, \"타입 선언 없이\"), \" 바로 사용할 수 있는 것이 가장 큰 특징입니다.\"), \"\\n\", React.createElement(_components.p, null, \"일반 배리언트와 다른게 반드시 대문자로 시작할 필요가 없지만, 태그에 백틱(\", React.createElement(_components.code, null, \"`\"), \")을 붙여주어야 합니다.\\n참고로 ReasonML과는 사촌지간인 리스크립트(ReScript)에서는 해시(\", React.createElement(_components.code, null, \"#\"), \")를 붙이는 것으로 문법이 바뀌었습니다.\\n리스크립트는 최대한 자바스크립트와 비슷한 문법을 지향하는데, 자바스크립트의 문자열 인터폴레이션과 헷깔리기 때문에 바꾸었다고 합니다.\"), \"\\n\", React.createElement(_components.p, null, \"아래는 폴리모픽 배리언트의 예입니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let three = `Int(3);\\n/* [> `Int(int) ] */\\n\\nlet four = `Float(4.0);\\n/* [> `Float(float) ] */\\n\\nlet nan = `Not_a_number;\\n/* [> `Not_a_number ] */\\n\\n[three, four, nan];\\n/* list( [> `Float(float) | `Int(int) | `Not_a_number ] ) */\\n\")), \"\\n\", React.createElement(_components.p, null, \"보다시피 별도의 타입 선언 없이 쓸 수 있으며, 배리언트의 태그들이 대괄호(\", React.createElement(_components.code, null, \"[]\"), \")로 감싸져 있는 것이 특징입니다.\\n그리고 리스트에 섞어 쓰면 그 결과에 대응되는 새로운 타입도 추론해 줍니다.\"), \"\\n\", React.createElement(_components.p, null, \"참고로 배열에 대해서는 타입 추론이 되지 않고 컴파일 에러가 발생합니다.\\n이는 OCaml🐫 구현의 영향을 받은 것인데, 배열은 성능을 위해 사용되는 자료구조이기 때문인 것으로 추측됩니다.\"), \"\\n\", React.createElement(_components.p, null, \"당연하지만 아래와 같이 태그를 혼용하는 것은 안됩니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let five = `Int(\\\"five\\\")\\n/* [> `Int(string) ] */\\n\\n[three, four, five]\\n\\n/*\\nThis has type: [> `Int(string) ]\\nSomewhere wanted: [> `Float(float) | `Int(int) ]\\nTypes for tag `Int are incompatible\\n*/\\n\")), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.h3, null, \"폴리모픽 배리언트의 범위(bounds)\"), \"\\n\", React.createElement(_components.p, null, \"아까부터 자동 추론되는 타입 앞에는 \", React.createElement(_components.code, null, \">\"), \" 문자가 보입니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"[three, four];\\n/* [> `Float(float) | `Int(int) ] */\\n\")), \"\\n\", React.createElement(_components.p, null, \"이런 식으로요.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.code, null, \">\"), \"로 시작하는 타입의 의미는 다음과 같습니다.\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"열거된 태그들을 포함하기만 하면 기타 다른 태그를 포함해도 됨\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"위 예시는 \\\"\", React.createElement(_components.code, null, \"Float(float)\"), \"와 \", React.createElement(_components.code, null, \"Int(int)\"), \"를 포함, \", React.createElement(_components.strong, null, \"그리고\"), \" 추가적으로 다른 태그도 포함할 수 있는 타입\\\"의 폴리모픽 배리언트를 의미합니다.\\n이를 폴리모픽 배리언트의 하계(a lower bound)라고 합니다.\"), \"\\n\", React.createElement(_components.p, null, \"반대로 컴파일러가 배리언트의 타입을 \", React.createElement(_components.code, null, \"<\"), \"로 추론하는 경우가 있습니다.\\n아까와는 부등호 방향이 반대입니다.\\n눈치채셨겠지만 이를 폴리모픽 배리언트의 상계(an upper bound)라고 합니다.\\n\", React.createElement(_components.code, null, \"<\"), \"로 시작하는 타입의 의미는 다음과 같습니다.\"), \"\\n\", React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"열거된 태그들로 선언되거나 \", React.createElement(_components.strong, null, \"혹은\"), \" 그보다 부족하게만 선언되면 문제없음\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"예시를 들어보겠습니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let isPositive = x =>\\n  switch (x) {\\n  | `Int(i) => i > 0\\n  | `Float(f) => f > 0.\\n  };\\n/* [< `Float(float) | `Int(int) ] => bool */\\n\")), \"\\n\", React.createElement(_components.p, null, \"위 함수의 반환 타입이 \", React.createElement(_components.code, null, \"<\"), \" 인 이유는, \", React.createElement(_components.code, null, \"Float\"), \", \", React.createElement(_components.code, null, \"Int\"), \" 이외의 태그가 들어가면 함수 내부의 스위치 문에서 대응이 안되기 때문입니다.\\n이는 안전하지 못한 코드를 의미하므로 컴파일러가 통과시키지 않습니다.\"), \"\\n\", React.createElement(_components.p, null, \"참고로 상계와 하계가 동일한 경우에는 \", React.createElement(_components.code, null, \"<\"), \", \", React.createElement(_components.code, null, \">\"), \" 표기가 없어집니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let exact = Belt.List.keep([three, four], isPositive);\\n/* Belt.List.t( [ `Float(float) | `Int(int) ] ) */\\n\")), \"\\n\", React.createElement(_components.p, null, \"상계와 하계가 다른 경우도 만들어낼 수 있습니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let isPositive = x =>\\n  switch (x) {\\n  | `Int(i) => Ok(i > 0)\\n  | `Float(f) => Ok(f > 0.)\\n  | `Not_a_number => Error(\\\"not a number\\\")\\n  };\\n\\nlet exact =\\n  Belt.List.keep([three, four], x => {\\n    switch (isPositive(x)) {\\n    | Error(_) => false\\n    | Ok(v) => v\\n    }\\n  });\\n/* Belt.List.t( [< `Float(float) | `Int(int) | `Not_a_number > `Float `Int ] )\\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~   */\\n\")), \"\\n\", React.createElement(_components.p, null, \"추론된 타입이 좀 복잡해 보이지만 천천히 살펴보면 그리 어렵지 않습니다.\\n이 타입은 Float, Int, NaN 이외의 것을 받을 수는 없지만, 적어도 Float와 Int는 포함해야 함을 의미합니다.\"), \"\\n\", React.createElement(_components.h2, null, \"폴리모픽 배리언트가 필요한 순간\"), \"\\n\", React.createElement(_components.p, null, \"실전에서 폴리모픽 배리언트가 일반 배리언트보다 유용한 사례를 알아보겠습니다.\"), \"\\n\", React.createElement(_components.p, null, \"색상을 다루어야 하는 상황을 가정해 봅시다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"/* 익숙한 일반 배리언트를 사용하여 타이핑 */\\ntype color =\\n  | RGB(int, int, int) /* 6x6x6 color cube */\\n  | Gray(int); /* 24 grayscale */\\n\\nlet colorToInt = c =>\\n  switch (c) {\\n  | RGB(r, g, b) => 16 + b + g * 6 + r * 36\\n  | Gray(i) => 232 + i\\n  };\\n\")), \"\\n\", React.createElement(_components.p, null, \"색상은 RGB 또는 흑백으로 표현할 수 있고, 이를 정수로 변환할 수 있는 로직입니다.\\n여기서 요구사항이 바뀌어 투명도를 포함한 색깔을 추가로 다루어야 한다고 해봅시다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"type extColor =\\n  | RGB(int, int, int)\\n  | Gray(int)\\n  | RGBA(int, int, int, int); /* 🆕 6x6x6x6 color space */\\n\")), \"\\n\", React.createElement(_components.p, null, \"기존 로직에 영향을 주지 않기 위해 \", React.createElement(_components.code, null, \"color\"), \" 타입을 수정하지 않고 새롭게 선언했습니다.\\n여기까지는 좋습니다.\\n문제는 아까와 비슷하게 \", React.createElement(_components.code, null, \"extColorToInt\"), \"라는 함수를 작성하는 순간입니다.\\n단순한 타입이 아니라 로직의 구현이기 때문에, 기존 \", React.createElement(_components.code, null, \"colorToInt\"), \" 로직을 재사용하고자 합니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let extColorToInt = c =>\\n  switch (c) {\\n  | RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\\n  | (RGB(_) | Gray(_)) as c' => colorToInt(c')\\n  };\\n\\n/*\\nThis has type: extColor\\nSomewhere wanted: color\\n*/\\n\")), \"\\n\", React.createElement(_components.p, null, \"하지만 위와 같이 작성한 코드는 동작하지 않습니다.\"), \"\\n\", React.createElement(_components.p, null, \"사람이 보기에는 문제없는 코드 같지만, 컴파일러가 보기에는 \", React.createElement(_components.code, null, \"extColor\"), \"와 \", React.createElement(_components.code, null, \"color\"), \"가 서로 전혀 다른 타입이기 때문입니다.\\n에러의 의미도 그것입니다.\"), \"\\n\", React.createElement(_components.p, null, \"하지만 우리가 원하는 것은 저 여지껏 사용된 태그가 적절히 재사용되는 것입니다.\"), \"\\n\", React.createElement(_components.h3, null, \"폴리모픽 배리언트로\"), \"\\n\", React.createElement(_components.p, null, \"단순히 일반 배리언트를 폴리모픽 배리언트로 바꿔보겠습니다.\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"기존 코드에서 \", React.createElement(_components.code, null, \"type\"), \" 으로 선언된 부분은 날려버리고\"), \"\\n\", React.createElement(_components.li, null, \"패턴매칭에서 백틱(`)만 찍어주면 됩니다.\"), \"\\n\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let colorToInt = c =>\\n  switch (c) {\\n  | `RGB(r, g, b) => 16 + b + g * 6 + r * 36\\n  | `Gray(i) => 232 + i\\n  };\\n/* [< `Gray(int) | `RGB(int,int,int) ] => int */\\n\\nlet extColorToInt = c =>\\n  switch (c) {\\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\\n  | (`RGB(_) | `Gray(_)) as c' => colorToInt(c')\\n  };\\n/* [< `Gray(int) | `RGB(int,int,int) | `RGBA(int,int,int,int) ] => int */\\n\")), \"\\n\", React.createElement(_components.p, null, \"이번에는 문제없이 \", React.createElement(_components.code, null, \"extColorToInt\"), \"가 컴파일됐습니다.\\n그리고 컴파일이 되었으니 문제가 없는 것은 분명합니다.\\n원했던 대로 \", React.createElement(_components.code, null, \"c'\"), \"의 타입이 절절히 축소되어(extColor -> color) \", React.createElement(_components.code, null, \"colorToInt\"), \"의 인자로 전달되었습니다.\"), \"\\n\", React.createElement(_components.p, null, \"그런데 매칭 구문이 조금 지저분해 보이는데, 차라리 catch-all로 받아버리면 어떨까요?\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let extColorToInt = c =>\\n  switch (c) {\\n  | `RGBA(r, g, b, a) => 256 + a + b * 6 + g * 36 + r * 216\\n  | c' => colorToInt(c')\\n  };\\n\\n/*\\nThis has type: [> `RGBA(int, int, int, int) ]\\nSomewhere wanted: [< `Gray(int) | `RGB(int, int, int) ]\\nThe second variant type does not allow tag(s) `RGBA\\n*/\\n\")), \"\\n\", React.createElement(_components.p, null, \"아쉽게도 컴파일은 되지 않습니다.\\n에러가 친절히 알려주다시피 \", React.createElement(_components.code, null, \"c'\"), \"의 타입이 굉장히 느슨하게 추론되기 때문입니다.\"), \"\\n\", React.createElement(_components.p, null, \"그 이유는 어렵지 않게 추측할 수 있습니다.\\n타입을 별도로 선언하지 않았기 떄문에 \", React.createElement(_components.code, null, \"c'\"), \"는 어떤 태그도 될 수 있는 반면, \", React.createElement(_components.code, null, \"colorToInt\"), \"는 상계가 있기 때문입니다.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.h4, null, \"⚠️ Catch-all 매칭 ⚠️\"), \"\\n\", React.createElement(_components.p, null, \"앞서 \", React.createElement(_components.code, null, \"isPositive\"), \"에서 보았듯이, 함수 본문의 패턴매칭은 배리언트의 상계에 영향을 미칩니다.\\n그렇지만 패턴매칭에 catch-all을 넣는 순간 반대로 아래와 같이 하계만 결정되고 위로는 제약이 풀려버립니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"let isPositivePermissive = x =>\\n  switch (x) {\\n  | `Int(i) => Ok(i > 0)\\n  | `Float(f) => Ok(f > 0.)\\n  | _ => Error(\\\"Unknown number type\\\")\\n  };\\n/* [> `Float(float) | `Int(int) ] => ... */\\n\\nisPositivePermissive(`Int(0));\\n/* Ok(false) */\\nisPositivePermissive(`Ratio(3, 4));\\n/* Error(\\\"Unknown number type\\\") */\\n\")), \"\\n\", React.createElement(_components.p, null, \"Catch-all 케이스는 일반 배리언트에서도 에러를 일으키지 쉽지만, 폴리모픽 배리언트에서는 더 심합니다.\\n왜냐하면 위 예시처럼 코드가 작성된 경우 실수로 오타를 입력해도 컴파일러가 어떤 불평도 하지 않기 때문입니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"isPositivePermissive(`Floot(3.05));\\n/* Error(\\\"Unknown number type\\\") */\\n\")), \"\\n\", React.createElement(_components.p, null, \"만약 일반 배리언트였다면 이러한 문제는 없었을 것입니다.\\n그러니 폴리모픽 배리언트를 쓸 때에는 catch-all 사용에 주의해야 합니다.\"), \"\\n\", React.createElement(_components.h2, null, \"일반 배리언트 vs. 폴리모픽 배리언트\"), \"\\n\", React.createElement(_components.p, null, \"지금까지의 설명으로는 폴리모픽 배리언트가 일반 배리언트의 상위 호환처럼 느껴집니다.\\n약간만 주의하면 일반처럼 쓸 수도 있고, 더 유연하면서 간결하고요.\"), \"\\n\", React.createElement(_components.p, null, \"그렇지만 대부분의 설계에서는 \", React.createElement(_components.strong, null, \"일반 배리언트가\"), \" 더 좋은 선택이라고 합니다.\\n폴리모픽 배리언트는 그 유연함의 대가로 아래와 같은 단점을 가집니다.\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"더 높은 복잡도\", \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"동작 방식이 일반 배리언트보다 복잡하기 때문에, 이것을 마구 쓰다가 컴파일이 잘 안되는 상황이 발생했을 때 컴파일러가 뱉어내는 에러메세지가 굉장히 난해해지곤 합니다.\\n일반적으로 \", React.createElement(_components.strong, null, \"값 수준에서 구현을 단순하게 할수록 타입 수준에서 구현 복잡도가 증가\"), \"하는 경향이 있습니다.\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"더 어려운 디버깅\", \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"타입 시스템이 유연할수록 프로그램의 버그를 찾기 어렵다고 합니다.\\n폴리모픽 배리 역시 타입 안전하긴 하지만, 그 유연함 때문에 에러를 찾기가 좀 더 어려워지는 경향이 있습니다.\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"낮은 성능\", \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"크게 심각한 것은 아니지만 폴리모픽 배리언트는 일반보다 구현이 좀 복잡합니다.\\n또한 컴파일러가 패턴매칭을 일반 배리언트만큼 효율적으로 처리하는 코드를 생성할 수 없습니다.\"), \"\\n\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"이런 단점에도 폴리모픽 배리언트는 여전히 매우 강력하고 유용합니다.\\n장점을 다시 정리해보자면,\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"재사용성\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"생성자가 매우 다양한 경우에 유용합니다.\\n예를 들어 문자열 인코딩을 종류별로 다뤄야 한다고 했을 때, 이를 미리 선언하지 않고 사용할 수 있어 편리합니다.\", \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"type encoding = [ |`base64 | `ascii | `latin1 | `utf8 | `hex ... ]\\n/* 수 많은 인코딩을 일일히 나열하고 싶지 않습니다. 😕 */\\n\")), \"\\n\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"디커플링\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"명시적인 타입 선언을 해야 한다면 이를 사용하는 모든 곳에서 의존성을 갖게 되므로 모듈 관리 비용이 들어갑니다.\\n하지만 타입 선언이 필요치 않기 때문에 태그에 대한 약속은 공유하되 완전히 디커플링된 설계를 할 수 있습니다.\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"확장성\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"배리언트가 추후 확장되도록 설계할 수 있습니다. 위의 \", React.createElement(_components.code, null, \"extColorToInt\"), \"가 그 간단한 예입니다.\\n현실적인 예는 \", React.createElement(_components.a, {\n    href: \"http://graphql-ppx.com/\"\n  }, \"graphql-ppx\"), \"에서도 찾아볼 수 있습니다.\\ngraphql-ppx는 스키마의 enum에 대해 폴리모픽 배리언트를 자동 생성하는데, 생성되는 타입은 암묵적으로 \", React.createElement(_components.code, null, \" `FutureAddedValue(_)\"), \"라는 태그를 포함하게 됩니다.\"), \"\\n\", React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-reason\"\n  }, \"type t_someQuery_enumField = [\\n  | `FutureAddedValue(string)\\n  | `FIRST\\n  | `SECOND\\n];\\n\")), \"\\n\", React.createElement(_components.p, null, \"따라서 클라이언트에서는 위와 같이 \", React.createElement(_components.code, null, \" `FutureAddedValue\"), \" 매칭 코드 작성이 강제되는데, 덕분에 서버 스키마가 조용히 변경되어 새로운 enum 값이 전달되더라도 클라이언트 런타임에러가 발생하지 않도록 해줍니다.\"), \"\\n\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"간결함\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"생성자가 전역 네임스페이스에 있기 때문에 별도로 모듈을 open할 필요가 없습니다.\\n또, 별로 중요하지 않은 곳에서 적당히 태그를 만들어 사용하고 버리기에 편리합니다.\"), \"\\n\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, null, \"맺음말\"), \"\\n\", React.createElement(_components.p, null, \"지금까지 살펴본 내용만으로도 폴리모픽 배리언트를 사용하는 것에는 큰 지장이 없습니다.\\n하지만 타입의 상계와 하계가 어떻게 결정되는지 그 동작 방식에 대해 이해하는 것도 좋을 것입니다.\\n다음 글에서는 폴리모픽 타입의 추론 과정(unification)이 어떻게 동작하는지 다루어보겠습니다.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(Author, {\n    email: \"hw.nam@greenlabs.co.kr\",\n    name: \"남현우\",\n    description: \"소프트웨어 엔지니어\",\n    date: \"2020-12-01\"\n  }), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.h4, null, \"참고자료\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.a, {\n    href: \"https://2ality.com/2018/01/polymorphic-variants-reasonml.html\"\n  }, \"2ality - ReasonML: polymorphic variant types\")), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.a, {\n    href: \"https://github.com/bobzhang/ocaml-book/blob/master/lang/features.org#polymorphic-variants\"\n  }, \"OCaml Book, Hongbo Zhang\")), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"[^1]: \", React.createElement(_components.a, {\n    href: \"https://dev.realworldocaml.org/variants.html\"\n  }, \"Real World OCaml\"), \"\\n[^2]: \", React.createElement(_components.a, {\n    href: \"https://ocaml.org/manual/lablexamples.html#s%3Apolymorphic-variants\"\n  }, \"Polymorphic Variants\")));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import React from \"react\";\nimport GATSBY_COMPILED_MDX from \"/Users/hyejin/Documents/tech-blog/content/posts/polymorphic-variants/index.mdx\";\nimport PostComponent from \"../components/post\";\nPostComponent\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(PostComponent, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nvar query = \"2231403947\";\n"],"names":["_createMdxContent","props","_components","Object","assign","blockquote","p","br","a","hr","code","h2","strong","pre","h3","ol","li","h4","ul","_provideComponents","components","Author","id","component","Error","_missingMdxReference","React","href","className","email","name","description","date","MDXLayout","wrapper","GatsbyMDXWrapper","PostComponent","GATSBY_COMPILED_MDX"],"sourceRoot":""}