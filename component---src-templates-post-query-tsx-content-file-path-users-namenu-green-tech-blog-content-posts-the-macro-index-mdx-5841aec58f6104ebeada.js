"use strict";(self.webpackChunkmy=self.webpackChunkmy||[]).push([[436],{2905:function(e,n,t){t.r(n),t.d(n,{default:function(){return o}});var l=t(7294),a=t(9626);function r(e){var n=Object.assign({h2:"h2",p:"p",ol:"ol",li:"li",code:"code",h3:"h3",pre:"pre",a:"a",blockquote:"blockquote",ul:"ul"},(0,a.ah)(),e.components),t=n.Author;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Author",!0),l.createElement(l.Fragment,null,l.createElement(n.h2,null,"매크로에 대한 기억"),"\n",l.createElement(n.p,null,"어린 시절 즐기던 게임에서는 레벨 업을 위해 지루한 반복 사냥을 해야 할 때가 많았습니다. 제 친구 중 몇 명은 매크로 프로그램을 이용해 반복 사냥을 컴퓨터가 대신하게 했습니다. 매크로를 이용하면 캐릭터가 어떤 방향으로 공격을 하게 하거나, 몇 분에 한 번씩 아이템을 사용하도록 하는 등 일련의 작업을 자동으로 실행할 수 있었습니다. 이처럼, '매크로'란 미리 정해놓은 명령을 자동으로 실행하여 단순 반복 작업을 줄이는 기능입니다. 그런데 프로그래밍에서도 따분한 반복 작업을 해야 하는 경우가 있습니다. 프로그래밍 언어에는 일정한 문법과 규칙이 있기 때문입니다. 예를 들어, 자바에서 새 객체를 만들려면 다음과 같은 절차를 반드시 따라야 합니다."),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.code,null,"class")," 키워드로 클래스를 정의한다."),"\n",l.createElement(n.li,null,l.createElement(n.code,null,"new")," 키워드로 객체를 생성한다."),"\n"),"\n",l.createElement(n.p,null,"이 두 문장은 뒤바뀔 수 없습니다. 둘 중 하나의 행위만으로는 객체를 만들 수 없죠. 프로그래밍 언어의 문법의 틀을 당연시한다면 생각은 그와 유사한 방식으로만 상상할 수밖에 없다고 생각합니다. 클로저(Clojure)의 매크로는 주어진 규칙을 허무는 데 도움을 줄 것입니다."),"\n",l.createElement(n.h2,null,"프로그래밍 언어의 매크로"),"\n",l.createElement(n.h3,null,"C 언어의 매크로"),"\n",l.createElement(n.p,null,"클로저의 매크로에 관해 알아보기 전에, 더 많은 분들이 알고 계실 C 언어의 매크로를 잠시 살펴봅시다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c"},'#include <stdio.h>\n\n#define CUBE_MACRO(n) n*n*n\n\nint main()\n{\n  printf("%d", CUBE_MACRO(1+2));  // 1+2*1+2*1+2 -> 7\n  return 0;\n}\n')),"\n",l.createElement(n.p,null,"위 코드에서는 ",l.createElement(n.code,null,"#define")," 전처리 명령으로 n을 세제곱하는 ",l.createElement(n.code,null,"CUBE_MACRO"),"라는 매크로 함수를 정의했습니다. ",l.createElement(n.code,null,"CUBE_MACRO")," 매크로는 일반 함수를 호출하는 것처럼 사용할 수 있습니다. 한편, 아래의 코드에서는 ",l.createElement(n.code,null,"CUBE_MACRO")," 매크로의 ",l.createElement(n.code,null,"n*n*n"),"과 동일한 식을 일반 함수 ",l.createElement(n.code,null,"cube_func()"),"로 정의했습니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-c"},'#include <stdio.h>\n\nint cube_func(int n)\n{\n  return n*n*n;\n}\n\nint main()\n{\n  printf("%d", cube_func(1+2));  // 3*3*3 -> 27\n  return 0;\n}\n')),"\n",l.createElement(n.p,null,"이 두 코드는 동일한 일을 하는 것 같지만, 결과 값이 다릅니다.",l.createElement(n.a,{href:"#ref-2"},"[2]"),l.createElement(n.a,{href:"#ref-3"},"[3]")," ",l.createElement(n.code,null,"CUBE_MACRO"),"는 ",l.createElement(n.code,null,"7"),"이 출력되며, ",l.createElement(n.code,null,"cube_func"),"는 ",l.createElement(n.code,null,"27"),"이 출력되었습니다. C언어 매크로는 기호(여기서는 ",l.createElement(n.code,null,"1+2"),")를 다른 기호로 치환한 뒤, 코드를 컴파일하고 실행합니다. 함수는 이미 코드가 컴파일 된 상태에서, 기호를 값으로 평가한 후에(",l.createElement(n.code,null,"2+1 -> 3"),") 실행합니다. 컴파일 전에는 ",l.createElement(n.code,null,"1+2"),"라는 코드가 ",l.createElement(n.code,null,"3"),"이라는 값으로 평가되지 않으므로, ",l.createElement(n.code,null,"n*n*n"),"은 ",l.createElement(n.code,null,"3*3*3"),"이 아니라 ",l.createElement(n.code,null,"1+2*1+2*1+2"),"로 치환됩니다. 따라서 매크로 함수와 일반 함수의 실행 결과에 차이가 생기는 것입니다. C 언어의 매크로는 이처럼 코드 자체를 변경하며, 이를 이용하면 제한적으로나마 기존 언어에서 정한 규칙의 선을 넘을 수 있습니다."),"\n",l.createElement(n.h2,null,"클로저 매크로"),"\n",l.createElement(n.p,null,"클로저 매크로도 C언어 매크로와 비슷하지만, 단순히 문자열 치환이 아닙니다. 코드를 프로그래밍하는 것에 가깝습니다. 코드를 치환한다는 점에서 클로저의 매크로는 C언어 매크로와 비슷하지만, 리스프 계열 언어의 특징인 동형성으로 특별해집니다. ",l.createElement(n.a,{href:"#ref-4"},"[4]"),l.createElement(n.a,{href:"#ref-5"},"[5]"),l.createElement(n.a,{href:"#ref-6"},"[6]")),"\n",l.createElement(n.h3,null,"동형성"),"\n",l.createElement(n.p,null,'클로저는 리스프 계열 언어입니다. 리스프(LISP)라는 이름은 "리스트 처리(LISt Processing)"에서 딴 것입니다. 그 이름에서도 짐작할 수 있듯이, 연결 리스트(linked list)가 리스프의 핵심 자료구조입니다. 심지어 코드 자체도 리스트로 구성할 정도이죠. 그래서 클로저에서는 코드가 리스트 자료구조와 같은 방식으로 표현·저장됩니다. 코드를 변경하는 것이 리스트를 변경하는 것과 똑같은 일입니다. 클로저에서는 소괄호 안에 요소들을 나열하는 방식으로 리스트를 표기합니다. 다음 두 코드는 각각 자바와 클로저로 리스트를 표현한 것입니다.'),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-java"},"List.of(1,2,3,4)\n")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},"(list 1 2 3 4)  ;; (1 2 3 4)\n")),"\n",l.createElement(n.p,null,"클로저에서는 식을 계산하거나 함수를 호출할 때 코드를 리스트로 작성합니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},'(+ 1 2)\n(* 2 3)\n(/ 3 4)\n\n(println "Hello, Clojure")\n')),"\n",l.createElement(n.p,null,"함수 정의도 마찬가지입니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},'(defn hello-world [name]\n  (println (str "Hello, " name)))\n\n(defn add1 [number]\n  (+ 1 number))\n')),"\n",l.createElement(n.p,null,"코드가 리스트 자료구조로 구성되어 있으므로, 코드를 다른 리스트를 조작할 때와 똑같이 조작할 수 있습니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},"(count (list * 3 3 3)) ;; 4\n(first (list * 3 3 3)) ;; *\n(rest (list * 3 3 3))  ;; (3 3 3)\n(concat (list * 3 3 3) '(5)) ;; (3 3 3 5)\n")),"\n",l.createElement(n.p,null,"클로저 코드는 소괄호를 적극적으로 활용하여 문법을 최소화하였습니다. 일반적으로 리스트의 첫 번째 요소를 연산자(함수)로, 나머지 요소들을 피연산자(인자)로 취급합니다. 동형성은 매크로를 사용할 때 아주 강력한 힘이 됩니다. 우리는 '코드를 생산하는 코드'를 만들 능력을 얻은 것입니다."),"\n",l.createElement(n.h2,null,"클로저 매크로로 문법을 뛰어넘기"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"비아웹(Viaweb) 편집기의 전체 소스 코드 중 약 20%에서 25% 정도가 매크로였다. (중략) 그 프로그램에 포함된 모든 매크로는 꼭 필요해서 넣은 것이다. 이는 이 프로그램 중 최소 20%에서 25%가량의 코드는 다른 언어로는 하기 어려운 일을 하고 있음을 의미한다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"평균을 넘어서기, 폴 그레이엄(Paul Graham)"),"\n"),"\n"),"\n",l.createElement(n.p,null,"다른 언어에서는 구현하기가 몹시 까다로운 문제들을, 클로저의 매크로를 이용하면 평상시의 코딩과 다름없이 간단히 처리할 수 있는 경우가 많습니다. 몇 가지 사례를 소개해 드리겠습니다. 자세한 문법 설명은 생략하겠습니다. 그저 이런 것이 가능하다는 것만 즐겨주시면 좋겠습니다."),"\n",l.createElement(n.h3,null,"매크로 맛보기"),"\n",l.createElement(n.p,null,"C언어 매크로 소개 예시와 비슷한 일을 하는 코드를 소개합니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},";; 매크로 정의\n(defmacro cube-macro [n]\n  (list '* n n n))\n\n(cube-macro 3) ;; 27\n\n;; 함수 정의\n(defn cube-fn [n]\n  (* n n n))\n\n(cube-fn 3) ;; 27\n")),"\n",l.createElement(n.p,null,"C언어 매크로와는 다르게 함수 정의와 이질감이 없습니다. 그리고 결괏값이 함수 호출과 동일하게 나오는 것도 다릅니다."),"\n",l.createElement(n.h3,null,"예제 1 - anaphoric macro"),"\n",l.createElement(n.p,null,"anaphoric은 '앞서 나온 어구'를 지칭할 때 사용합니다. 대명사라고 이해하면 쉬울 것 같습니다. ",l.createElement(n.a,{href:"#ref-9"},"[9]")," if문에서 검사한 값을 그대로 사용하고 싶지는 않으신가요? 자바를 예로 들면 ",l.createElement(n.code,null,"null"),"을 관리하기 위해 종종 아래와 같은 코드를 만들 것입니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-java"},"SomeObject someObject = someMethod(arg1, arg2);\nif (someObject != null) {\n  doSomeThing(someObject);\n}\n// 또는\nOptional<SomeObject> someObjectOption = Optional.ofNullable(someMethod(arg1, arg2));\nif (!someObjectOption.isEmpty()) {\n  doSomething(someObjectOption.get());\n}\n// 또는\nOptional<SomeObject> someObjectOption = Optional.ofNullable(someMethod(arg1, arg2));\nsomeObjectOption.ifPresent(someObject -> {\n  doSomething(someObject);\n}\n")),"\n",l.createElement(n.p,null,"그렇다면 혹시 이런 것은 가능할까요? ",l.createElement(n.code,null,"someMethod(arg1, arg2)")," 의 결괏값이 ",l.createElement(n.code,null,"null"),"이 아니라면 ",l.createElement(n.code,null,"someMethod(arg1, arg2)"),"의 리턴문을 ",l.createElement(n.code,null,"it"),"이라는 키워드로 직접 사용할 수는 없을까요? 가능한지는 차치하고 새로운 문법을 상상해봅시다. ",l.createElement(n.code,null,"ifexists"),"는 값이 ",l.createElement(n.code,null,"null"),"이거나 ",l.createElement(n.code,null,"false"),"가 아니라면 중괄호 안의 statement를 수행한다고 상상해보죠."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-java"},"ifexists (someMethod(arg1, arg2)) {\n  doSomething(it);  // it을 someMethod의 리턴값에 바인딩이 가능할까?\n}\n")),"\n",l.createElement(n.p,null,"이런 코드를 자바에서 만들 수 있을까요? 아뇨, 우리는 이런 코드를 만들 수 없습니다. 예약어들은 정해져있습니다. 우리가 마음대로 추가할 수 없지요. ",l.createElement(n.code,null,"it"),"처럼 정의되지도 않은 이름을 바로 쓸 수도 없습니다. 누군가는 '당연히 정의부터 해야지. 순서라는 것이 있잖아.' 라고 생각할지도 모르죠. 하지만 클로저에서는 가능합니다. ",l.createElement(n.code,null,"aif"),", ",l.createElement(n.code,null,"aand")," 라는 매크로를 만들어 보겠습니다.(코드를 이해하실 필요는 없습니다. 가능하다는 것만 느껴주시면 좋겠습니다.)"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},"(defmacro aif [test then else]\n  `(let [~'it ~test]\n     (if `'it ~then ~else)))\n\n(defmacro aand [& body]\n  (cond (nil? body) true\n        (nil? (next body)) (first body)\n        :else `(aif ~(first body)\n                     (aand ~@(rest body))\n                     false)))\n\n(aif 1\n  (inc it)\n  \"Nope\")\n;; 2\n\n(aand 1\n  (inc it)\n  (* 100 it)\n  (= 200 it))\n;; true\n\n(aand 1\n  (inc it)\n  (* 2 it)\n  (= 5 it))\n;; false\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"aif"),"는 첫번째 인자가 ",l.createElement(n.code,null,"false"),", ",l.createElement(n.code,null,"nil"),"(자바의 ",l.createElement(n.code,null,"null"),"과 비슷)이 아닌경우 ",l.createElement(n.code,null,"it"),"에 바인딩되어 사용할 수 있습니다. ",l.createElement(n.code,null,"aand"),"는 더 나아가서 함수들을 체이닝해서 수행할 수 있지요. ",l.createElement(n.code,null,"it"),"은 이전 함수의 리턴값으로 체이닝됩니다."),"\n",l.createElement(n.h3,null,"예제 2 - for-loop문 만들기"),"\n",l.createElement(n.p,null,"Clojure에는 for-loop가 없습니다. 하지만 사용하고 싶다면 만들면 됩니다.",l.createElement(n.a,{href:"#ref-10"},"[10]")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},"(defmacro for-loop [[sym init check change :as params] & steps]\n `(loop [~sym ~init value# nil]\n    (if ~check\n      (let [new-value# (do ~@steps)]\n        (recur ~change new-value#))\n      value#)))\n\n(for-loop [i 0 (< i 10) (inc i)]\n  (println i))\n")),"\n",l.createElement(n.p,null,"마치 새로운 문법이 추가된 것처럼 보이네요!"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"리스트의 첫번째 요소 이름을 두번째 요소의 값으로 정의"),"\n",l.createElement(n.li,null,"리스트의 3번째 요소의 함수가 true 일때까지 재귀를 돈다."),"\n",l.createElement(n.li,null,"리스트의 4번째 요소는 첫번째 요소에 적용한 값으로 재귀호출한다."),"\n"),"\n",l.createElement(n.p,null,"이런 규칙을 단 6줄로 만들 수 있습니다."),"\n",l.createElement(n.h3,null,"예제 3 - 간단한 패턴매칭 만들기"),"\n",l.createElement(n.p,null,"위 예제는 매크로가 할 수 있는 일을 보여드리긴 했지만, 너무 작은 변화이기에 쓸모를 못 느낄 수도 있으신 분들을 위한 소개입니다. 클로저는 기본적으로 패턴매칭기능이 없습니다. 하지만 패턴매칭도 필요하면 만들 수 있습니다. 아래의 코드는 다음에 우리가 만들어볼 ",l.createElement(n.code,null,"my-match"),"를 사용하는 예시입니다.",l.createElement(n.a,{href:"#ref-11"},"[11]"),l.createElement(n.a,{href:"#ref-12"},"[12]"),l.createElement(n.a,{href:"#ref-14"},"[14]")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},'(doseq [n (range 1 101)]\n  (println\n   (my-match [(mod n 3) (mod n 5)]\n             [0 0] (str "FizzBuzz")\n             [0 _] (str "Fizz")\n             [_ 0] (str "Buzz")\n             :else n)))\n;; 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz ,,,\n')),"\n",l.createElement(n.p,null,"위 코드는 간단한 FizzBuzz 문제를 우리가 만들 ",l.createElement(n.code,null,"my-match"),"를 사용하여 푼 모습입니다. 3의 배수이면 Fizz를 5의 배수이면 Buzz를 3의 배수이며 5의 배수는 FizzBuzz를 출력합니다. 그리고 아무런 배수가 아니면 해당 숫자를 출력합니다. 여기서 특이한 점은 ",l.createElement(n.code,null,"_")," 입니다. 이 값은 하스켈 패턴매칭의 와일드카드처럼 어떤 값이 와도 상관없도록 만듭니다.",l.createElement(n.a,{href:"#ref-13"},"[13]")," 그리고 심볼 바인딩도 가능하도록 할 것입니다. 아래 예제를 소개합니다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},'(doseq [n (range 1 101)]\n  (println\n   (my-match [(mod n 3) (mod n 5)]\n             [0 0] (str "FizzBuzz with n=" n)\n             [0 a] (str "Fizz with a=" a ", n=" n)\n             [b 0] (str "Buzz with b=" b ", n=" n)\n             :else n)))\n;; 1\n;; 2\n;; Fizz with a=3, n=3\n;; 4\n;; Buzz with b=2, n=5\n;; Fizz with a=1, n=6 ...\n')),"\n",l.createElement(n.p,null,"같은 FizzBuzz 문제이지만 이번에는 와일드카드 대신 심볼을 바인딩하였습니다. 각 심볼에 해당하는 값이 바인딩 됩니다. ",l.createElement(n.code,null,"n"),"이 3의 배수일 때, 5의 mod 값을 ",l.createElement(n.code,null,"a"),"에 바인딩하여 사용할 수 있게 됩니다."),"\n",l.createElement(n.p,null,"이를 구현한 코드는 아래와 같습니다. (굳이 이해하실 필요는 없습니다. 몇 개의 함수와 매크로로 매턴매칭이 가능하다는 것을 느끼시면 좋겠습니다.)"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-clojure"},';; https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8\n(ns pattern-match.diy)\n\n(defn process-vars\n  [vars]\n  (letfn [(process-var [var]\n            (if-not (symbol? var)\n              (gensym "ocr-")\n              var))]\n    (vec (map process-var vars))))\n\n(defn make-default-match [vars cs]\n  (let [cs (partition 2 cs)\n        [p a] (last cs) ;; 심볼의 경우 p를 a에 바인딩하는 기능 추가 필요.\n        last-match (vec (repeat (count vars) \'_))]\n    (if (= p :else)\n        (conj (vec (butlast cs)) [last-match a])\n        (throw (RuntimeException. "last match must be :else")))))\n\n(defn make-pattern-let-binding\n  "let 바인딩을 위한 자료구조 생성"\n  [vs vars]\n  (interleave vs vars))\n\n(defn make-cond\n  "cond predicate을 만들기 위한 비교문"\n  [vs cls]\n  (map (fn [v c]\n         `(= ~v ~c)) vs cls))\n\n(def backtrack-exception (Exception. "BackTrack!"))\n\n(defn catch-error\n  "예외를 잡는 자료구조 추가"\n  [& body]\n  `(catch Exception e#\n     (if (identical? e# ~\'backtrack-exception)\n       (do\n         ~@body)\n       (throw e#))))\n\n(defn compile-rec\n  "재귀적으로 try문 안에 있는 비교문을 생성."\n  [cnds return]\n  (let [cnd (first cnds)\n        [v c] (vec (rest cnd))] ;; c가 심볼인 경우 v를 바인딩하도록 해야함.\n    (if (seq cnd)\n      (cond\n        (symbol? c)\n        `(let [~c ~v] (do ~(compile-rec (rest cnds) return)))\n\n        (= \'_ c)\n        `(do ~(compile-rec (rest cnds) return))\n\n        :else\n        `(do (cond ~cnd ~(compile-rec (rest cnds) return)\n                   :else ~\'(throw backtrack-exception))))\n      return)))\n\n(defn match-compile\n  [conds+return]\n  (let [[cnds return] (first conds+return)\n        cnd (first cnds)\n        [v c] (vec (rest cnd))] ;; c가 심볼인 경우 v를 바인딩하도록 해야함.\n    (if (seq cnd)\n      (cond\n        (symbol? c)\n        `(let [~c ~v]\n           (try ~(compile-rec (rest cnds) return)\n             ~(catch-error (match-compile (rest conds+return)))))\n\n        (= \'_ c)\n        `(try ~(compile-rec (rest cnds) return)\n           ~(catch-error (match-compile (rest conds+return))))\n\n        :else\n        `(try (cond ~cnd ~(compile-rec (rest cnds) return)\n                    :else ~\'(throw backtrack-exception))\n           ~(catch-error (match-compile (rest conds+return)))))\n      return)))\n\n(defmacro my-match\n  [vars & clauses]\n  (let [vs (process-vars vars)\n        cs (make-default-match vars clauses)\n        pattern-let-binding (vec (make-pattern-let-binding vs vars))\n        conds (map (fn [c] [(make-cond vs (first c)) (second c)]) cs)]\n    `(let ~pattern-let-binding\n       ~(match-compile conds))))\n')),"\n",l.createElement(n.p,null,"기존 함수 정의 및 호출과 동일한 형태의 코드임을 알 수 있습니다. 생성하는 결괏값이 소스 코드인 것만 다릅니다."),"\n",l.createElement(n.p,null,"만약에 여러분이 사용하는 언어에서 패턴매칭이 없을 때, 여러분은 임의로 이 기능을 추가할 수 있으신가요 아니면 새로운 버전이 나오기를 기다리실 수밖에 없으신가요? 리스프의 매크로라면 여러분이 원하는 것을 무엇이든 손쉽게 만들 수 있습니다. 여러분은 문법에 구애받지 않고 작성할 힘을 갖게 됩니다. ",l.createElement(n.a,{href:"#ref-7"},"[7]"),l.createElement(n.a,{href:"#ref-8"},"[8]")),"\n",l.createElement(n.p,null,"언어가 여러분을 제약하지 않도록 하세요. 여러분이 언어를 제약하세요."),"\n",l.createElement(n.h2,null,"참고문헌"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"언어는 어떻게 생각하는 방식을 형성하는가","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"[1] : ",l.createElement(n.a,{href:"https://www.ted.com/talks/lera_boroditsky_how_language_shapes_the_way_we_think"},"how language shapes the way we think")," ",l.createElement("a",{name:"ref-1"})),"\n"),"\n"),"\n",l.createElement(n.li,null,"C 언어 매크로","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"[2] : ",l.createElement(n.a,{href:"https://www.geeksforgeeks.org/macros-vs-functions/"},"https://www.geeksforgeeks.org/macros-vs-functions/")," ",l.createElement("a",{name:"ref-2"})),"\n",l.createElement(n.li,null,"[3] : ",l.createElement(n.a,{href:"https://stackoverflow.com/questions/9104568/macro-vs-function-in-c"},"https://stackoverflow.com/questions/9104568/macro-vs-function-in-c")," ",l.createElement("a",{name:"ref-3"})),"\n"),"\n"),"\n",l.createElement(n.li,null,"리스프의 이상한 문법","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"[4] : ",l.createElement(n.a,{href:"http://www.paulgraham.com/weird.html"},"http://www.paulgraham.com/weird.html")," ",l.createElement("a",{name:"ref-4"})),"\n",l.createElement(n.li,null,"[5] : ",l.createElement(n.a,{href:"https://www.defmacro.org/ramblings/lisp.html"},"https://www.defmacro.org/ramblings/lisp.html")," ",l.createElement("a",{name:"ref-5"})),"\n",l.createElement(n.li,null,"[6] : ",l.createElement(n.a,{href:"https://helloworld.kurly.com/blog/y-combinator/"},"https://helloworld.kurly.com/blog/y-combinator/")," ",l.createElement("a",{name:"ref-6"})),"\n"),"\n"),"\n",l.createElement(n.li,null,"리스프 매크로에 대한 논의","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"[7] : ",l.createElement(n.a,{href:"http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html"},"http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html")," ",l.createElement("a",{name:"ref-7"})),"\n",l.createElement(n.li,null,"[8] : ",l.createElement(n.a,{href:"https://arxiv.org/pdf/1608.02621.pdf"},"https://arxiv.org/pdf/1608.02621.pdf")," ",l.createElement("a",{name:"ref-8"})),"\n"),"\n"),"\n",l.createElement(n.li,null,"anaphoric macro","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"[9] : ",l.createElement(n.a,{href:"http://www.paulgraham.com/onlisptext.html"},"onlisp p.189")," ",l.createElement("a",{name:"ref-9"})),"\n"),"\n"),"\n",l.createElement(n.li,null,"for-loop","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://stackoverflow.com/questions/9981943/how-to-implement-a-for-loop-in-clojure"},"https://stackoverflow.com/questions/9981943/how-to-implement-a-for-loop-in-clojure")," ",l.createElement("a",{name:"ref-10"})),"\n"),"\n"),"\n",l.createElement(n.li,null,"패턴매칭","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"패턴매칭 알고리즘 소개 : ",l.createElement(n.a,{href:"https://www.ccs.neu.edu/~types/resources/a-fpca-1985.pdf"},"https://www.ccs.neu.edu/~types/resources/a-fpca-1985.pdf")," ",l.createElement("a",{name:"ref-11"})),"\n",l.createElement(n.li,null,"clojure core.match 라이브러리 : ",l.createElement(n.a,{href:"https://github.com/clojure/core.match"},"https://github.com/clojure/core.match")," ",l.createElement("a",{name:"ref-12"})),"\n",l.createElement(n.li,null,"하스켈 wildcard 설명 : ",l.createElement(n.a,{href:"https://www.haskell.org/tutorial/patterns.html"},"https://www.haskell.org/tutorial/patterns.html")," ",l.createElement("a",{name:"ref-13"})),"\n",l.createElement(n.li,null,"직접 구현한 패턴매칭 소스코드 링크 : ",l.createElement(n.a,{href:"https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8"},"https://gist.github.com/ssisksl77/4ea8f4945d52a054802e29a5b58337f8")," ",l.createElement("a",{name:"ref-14"})),"\n"),"\n"),"\n"),"\n",l.createElement("br"),"\n",l.createElement("br"),"\n",l.createElement("hr"),"\n",l.createElement("br"),"\n",l.createElement(t,{email:"ssisksl77@gmail.com",name:"남영환",description:"백엔드 개발자",date:"2021-11-22"}))}var c=function(e){void 0===e&&(e={});var n=Object.assign({},(0,a.ah)(),e.components).wrapper;return n?l.createElement(n,e,l.createElement(r,e)):r(e)};var m=t(3710);function o(e){return l.createElement(m.Z,e,l.createElement(c,e))}m.Z}}]);
//# sourceMappingURL=component---src-templates-post-query-tsx-content-file-path-users-namenu-green-tech-blog-content-posts-the-macro-index-mdx-5841aec58f6104ebeada.js.map